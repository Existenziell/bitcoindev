[
  {
    "path": "/whitepaper",
    "title": "Bitcoin Whitepaper",
    "section": "whitepaper",
    "body": "Bitcoin Whitepaper. Satoshi Nakamoto announced the whitepaper on the cryptography mailing list on October 31, 2008. The Bitcoin network launched on January 3, 2009, when Satoshi mined the Genesis Block. Open the Bitcoin whitepaper PDF. Related: Problems Bitcoin Solved, The Blockchain, Proof of Work, Consensus, Satoshi Nakamoto, Cypherpunk Philosophy.",
    "keywords": [
      "whitepaper"
    ]
  },
  {
    "path": "/interactive-tools/terminal",
    "title": "CLI Terminal",
    "section": "tools",
    "body": "Bitcoin CLI Terminal. Run Bitcoin RPC commands in the browser. getblockchaininfo, getblockcount, getblock, getblockhash, getrawtransaction, getmempoolinfo, getnetworkinfo, help. Connected to a public Bitcoin node. No node setup required.",
    "keywords": [
      "rpc",
      "cli",
      "terminal",
      "bitcoin core",
      "getblock",
      "getblockchaininfo",
      "getblockhash",
      "getrawtransaction",
      "bitcoin cli"
    ]
  },
  {
    "path": "/interactive-tools/stack-lab",
    "title": "Stack Lab",
    "section": "tools",
    "body": "Stack Lab. Interactive Bitcoin Script playground. Build and execute locking and unlocking scripts. Drag and drop OP codes. Learn Bitcoin Script, P2PKH, multisig, hash locks. Script interpreter, stack visualization.",
    "keywords": [
      "script",
      "op codes",
      "opcode",
      "stack",
      "script builder",
      "interpreter",
      "stacklab",
      "stack lab",
      "script lab",
      "playground",
      "bitcoin script"
    ]
  },
  {
    "path": "/interactive-tools/block-visualizer",
    "title": "Block Visualizer",
    "section": "tools",
    "body": "Block Visualizer. Live Bitcoin blockchain visualization showing the latest block with transaction treemap. Explore transactions, fee rates, and block data in real-time. Interactive transaction treemap. Each rectangle represents a transaction, sized by vBytes, value, or fee. Click on transactions to view inputs and outputs.",
    "keywords": [
      "visualizer",
      "visualiser",
      "block visualizer",
      "block visualiser",
      "blockchain visualization",
      "transaction treemap",
      "block explorer",
      "blockexplorer",
      "block data",
      "blocks"
    ]
  },
  {
    "path": "/interactive-tools/hash",
    "title": "Hash Tool",
    "section": "tools",
    "body": "Hash Tool. Compute SHA-256, HASH256 (double SHA-256), and HASH160 in the browser. Used in Bitcoin for block hashes, TXIDs, addresses, and script. No installation required.",
    "keywords": [
      "hash",
      "sha256",
      "sha-256",
      "hash256",
      "hash160",
      "ripemd160",
      "double sha256",
      "txid",
      "address",
      "calculator",
      "hash calculator",
      "sha256 calculator",
      "hash256 calculator",
      "hash160 calculator"
    ]
  },
  {
    "path": "/interactive-tools/address-decoder",
    "title": "Address Decoder",
    "section": "tools",
    "body": "Address Decoder. Decode and inspect Bitcoin addresses. See type (P2PKH, P2SH, P2WPKH, P2WSH, P2TR), network, version byte or witness version, hash, and checksum. Base58Check and Bech32/Bech32m.",
    "keywords": [
      "address",
      "decoder",
      "address decoder",
      "p2pkh",
      "p2sh",
      "p2wpkh",
      "p2wsh",
      "p2tr",
      "base58",
      "bech32",
      "bech32m",
      "decode address"
    ]
  },
  {
    "path": "/interactive-tools/transaction-decoder",
    "title": "Transaction Decoder",
    "section": "tools",
    "body": "Transaction Decoder. Decode raw Bitcoin transaction hex. See version, inputs (outpoint, scriptSig, sequence), outputs (value, scriptPubKey), locktime. Supports SegWit.",
    "keywords": [
      "transaction",
      "decoder",
      "transaction decoder",
      "raw transaction",
      "decode tx",
      "hex",
      "scriptSig",
      "scriptPubKey",
      "locktime"
    ]
  },
  {
    "path": "/interactive-tools/fee-estimator",
    "title": "Fee Estimator",
    "section": "tools",
    "body": "Fee Estimator. Estimate Bitcoin transaction fee from size (vBytes) and current network rate. See fee in sats and USD for 1-block and 6-block targets.",
    "keywords": [
      "fee",
      "estimator",
      "fee estimator",
      "fee rate",
      "sat/vB",
      "vbytes",
      "transaction fee",
      "estimatesmartfee"
    ]
  },
  {
    "path": "/interactive-tools/denominations-calculator",
    "title": "Denomination Calculator",
    "section": "tools",
    "body": "Denomination Calculator. Convert between Bitcoin units: satoshis (sats), BTC, bits (µBTC), millibits (mBTC), and more. Interactive calculator with live conversion.",
    "keywords": [
      "calculator",
      "denomination calculator",
      "convert",
      "sats",
      "satoshis",
      "btc",
      "units",
      "satoshi",
      "denominations",
      "bits",
      "millibit"
    ]
  },
  {
    "path": "/about",
    "title": "About BitcoinDev",
    "section": "about",
    "body": "About BitcoinDev. Existenziell. Developer and Bitcoin Enthusiast. Why BitcoinDev. Bitcoin education. Open source. Free. No ads. No paywalls. Support. Donate. Nostr.",
    "keywords": [
      "about",
      "existenziell",
      "author",
      "support",
      "donate"
    ]
  },
  {
    "path": "/feedback",
    "title": "Feedback",
    "section": "feedback",
    "body": "Feedback. Share your thoughts about BitcoinDev. What worked for you? What didn't? Help us improve Bitcoin education. Your feedback helps us make BitcoinDev better.",
    "keywords": [
      "feedback",
      "suggestions",
      "improvements",
      "contact",
      "help"
    ]
  },
  {
    "path": "/docs/history/people#david-chaum",
    "title": "David Chaum",
    "section": "history",
    "body": "Contribution: eCash (1982) - The godfather of cryptocurrency David Chaum is widely regarded as the inventor of digital cash. In 1982, he published \"Blind Signatures for Untraceable Payments,\" introducing the concept of cryptographically secure anonymous payments. His company DigiCash launched eCash in the 1990s, which allowed users to withdraw digital tokens from a bank and spend them "
  },
  {
    "path": "/docs/history/people#eric-hughes",
    "title": "Eric Hughes",
    "section": "history",
    "body": "Contribution: \"A Cypherpunk's Manifesto\" (1993) - Privacy through cryptography Eric Hughes is a mathematician and privacy advocate who wrote \"A Cypherpunk's Manifesto\" in 1993, which became one of the foundational documents of the cypherpunk movement. The manifesto articulated that privacy in an open society requires cryptography, not laws or the good intentions of institutions. Along with "
  },
  {
    "path": "/docs/history/people#timothy-c-may",
    "title": "Timothy C. May",
    "section": "history",
    "body": "Contribution: \"The Crypto Anarchist Manifesto,\" cypherpunk mailing list co-founder Timothy C. May was an American physicist and writer who authored \"The Crypto Anarchist Manifesto\" (1988) and co-founded the cypherpunk mailing list with Eric Hughes and John Gilmore in 1992. His manifesto envisioned a future where cryptography would enable anonymous markets and transactions beyond the reach of "
  },
  {
    "path": "/docs/history/people#john-gilmore",
    "title": "John Gilmore",
    "section": "history",
    "body": "Contribution: Cypherpunk mailing list co-founder (1992) John Gilmore is a computer scientist, entrepreneur, and civil-liberties advocate who co-founded the cypherpunk mailing list with Eric Hughes and Timothy C. May in 1992. The list became the main forum where ideas that would eventually produce Bitcoin, including David Chaum's eCash, Adam Back's Hashcash, and Nick Szabo's Bit Gold, were "
  },
  {
    "path": "/docs/history/people#adam-back",
    "title": "Adam Back",
    "section": "history",
    "body": "Contribution: Hashcash (1997) - Proof-of-Work for spam prevention Adam Back is a British cryptographer who invented Hashcash in 1997, a proof-of-work system designed to limit email spam and denial-of-service attacks. The core idea was elegant: require senders to perform computational work before sending an email, making mass spam economically infeasible. Hashcash's proof-of-work mechanism became "
  },
  {
    "path": "/docs/history/people#nick-szabo",
    "title": "Nick Szabo",
    "section": "history",
    "body": "Contribution: Bit Gold (1998) - Decentralized digital currency concept Nick Szabo is a computer scientist, legal scholar, and cryptographer who designed Bit Gold in 1998, often called the direct precursor to Bitcoin. Bit Gold proposed a decentralized digital currency where participants would use computational power to solve cryptographic puzzles, with solutions timestamped and published to a "
  },
  {
    "path": "/docs/history/people#wei-dai",
    "title": "Wei Dai",
    "section": "history",
    "body": "Contribution: b-money (1998) - Digital scarcity and distributed consensus Wei Dai is a computer engineer and cryptographer who proposed b-money in 1998, a theoretical system for an anonymous, distributed electronic cash system. His proposal described two protocols: one where all participants maintain a database of account balances, and another using a subset of participants (similar to modern "
  },
  {
    "path": "/docs/history/people#ralph-merkle",
    "title": "Ralph Merkle",
    "section": "history",
    "body": "Contribution: Merkle trees (1979) - Efficient verification of block contents Ralph Merkle is a computer scientist who invented Merkle trees (also called hash trees) in 1979. In this structure, leaf nodes contain hashes of data, and each parent node is the hash of its children, building up to a single root hash. The Bitcoin whitepaper uses this construction to enable compact proofs: SPV clients "
  },
  {
    "path": "/docs/history/people#stuart-haber-and-scott-stornetta",
    "title": "Stuart Haber and Scott Stornetta",
    "section": "history",
    "body": "Contribution: Secure timestamps (1990-91) - \"How to time-stamp a digital document\" Stuart Haber and W. Scott Stornetta are cryptographers who, in a 1991 paper, solved the problem of timestamping digital documents so that they cannot be backdated or tampered with. Their scheme linked each new timestamp to the previous one in a chain, creating a cryptographically secured sequence that could prove "
  },
  {
    "path": "/docs/history/people#satoshi-nakamoto",
    "title": "Satoshi Nakamoto",
    "section": "history",
    "body": "Contribution: Bitcoin (2008-2010) - Creator of Bitcoin Satoshi Nakamoto is the pseudonymous person or group who created Bitcoin. On October 31, 2008, Nakamoto published the Bitcoin whitepaper, \"Bitcoin: A Peer-to-Peer Electronic Cash System.\" On January 3, 2009, they mined the Genesis Block, embedding the message: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.\" Satoshi "
  },
  {
    "path": "/docs/history/people#hal-finney",
    "title": "Hal Finney",
    "section": "history",
    "body": "Contribution: RPOW, PGP 2.0, first Bitcoin transaction recipient Hal Finney was a cryptographic pioneer and one of Bitcoin's most important early contributors. Before Bitcoin, he developed RPOW (Reusable Proofs of Work) in 2004, a system that allowed proof-of-work tokens to be reused as digital cash, building on Adam Back's Hashcash. He was also the lead developer of PGP 2.0 (Pretty Good "
  },
  {
    "path": "/docs/history/people#len-sassaman",
    "title": "Len Sassaman",
    "section": "history",
    "body": "Contribution: Cypherpunk, anonymous remailer developer Len Sassaman was a cypherpunk, privacy advocate, and cryptographer who made significant contributions to anonymity and privacy-preserving technologies. He was a core developer of Mixmaster, the most widely-used anonymous remailer protocol, and worked on various cryptographic privacy tools. Sassaman was embedded in the cypherpunk community "
  },
  {
    "path": "/docs/history/people#martti-malmi",
    "title": "Martti Malmi",
    "section": "history",
    "body": "Contribution: Early contributor (2009-11) - bitcoin.org, first exchange and community tools Martti Malmi (known online as Sirius) was one of Bitcoin's first contributors after Satoshi Nakamoto and Hal Finney. He began collaborating with Satoshi in 2009, helping to run and design bitcoin.org, implement an early, simple exchange, and build the first Bitcoin forum. Malmi wrote much of the early, "
  },
  {
    "path": "/docs/history/people#gavin-andresen",
    "title": "Gavin Andresen",
    "section": "history",
    "body": "Contribution: Lead developer after Satoshi (2010-2014) Gavin Andresen is a software developer who became the lead maintainer of Bitcoin's code after Satoshi Nakamoto's departure. In late 2010, Satoshi emailed Andresen: \"I've moved on to other things,\" and handed him access to the codebase and the project's alert key. Andresen was instrumental in Bitcoin's early development and "
  },
  {
    "path": "/docs/history/people#laszlo-hanyecz",
    "title": "Laszlo Hanyecz",
    "section": "history",
    "body": "Contribution: First documented real-world Bitcoin transaction (May 2010) - \"Bitcoin pizza\" Laszlo Hanyecz is a programmer who, on May 22, 2010, completed the first known commercial transaction using Bitcoin: he paid 10,000 BTC for two pizzas delivered to his home in Florida. The deal was arranged on the Bitcointalk forum, where Hanyecz had offered to pay BTC for pizza delivery. A participant in "
  },
  {
    "path": "/docs/history/people#wladimir-van-der-laan",
    "title": "Wladimir van der Laan",
    "section": "history",
    "body": "Contribution: Bitcoin Core lead maintainer (2014-2021) Wladimir van der Laan is a software developer who served as the lead maintainer of Bitcoin Core from 2014 to 2021. He took over the role from Gavin Andresen during a turbulent period that included the blocksize wars, the intense debate over whether to increase Bitcoin's block size limit. Van der Laan maintained the Bitcoin Core repository, "
  },
  {
    "path": "/docs/history/people#pieter-wuille",
    "title": "Pieter Wuille",
    "section": "history",
    "body": "Contribution: SegWit (BIP 141), Taproot (BIP 340-342), libsecp256k1 Pieter Wuille is a Belgian software engineer and one of the most influential Bitcoin protocol developers. He is the primary author of SegWit (BIP 141), activated in 2017, which separated signature data from transaction data in the block structure, fixing transaction malleability and enabling second-layer protocols. He also "
  },
  {
    "path": "/docs/history/people#gregory-maxwell",
    "title": "Gregory Maxwell",
    "section": "history",
    "body": "Contribution: Bitcoin Core developer, Blockstream co-founder, CoinJoin, Confidential Transactions, Sidechains Gregory Maxwell (Greg) is a Bitcoin Core developer and one of the most influential protocol and privacy researchers in Bitcoin. He co-founded Blockstream in 2014 and has authored or co-authored numerous BIPs and designs, including work on CoinJoin (which improved the blind-signature-based "
  },
  {
    "path": "/docs/history/people#joseph-poon-and-thaddeus-dryja",
    "title": "Joseph Poon and Thaddeus Dryja",
    "section": "history",
    "body": "Contribution: Lightning Network whitepaper (2015) Joseph Poon and Thaddeus Dryja authored \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments\" (2015), which described a second-layer network of payment channels that would allow fast, low-cost transactions without recording every payment on the blockchain. The design built on HTLCs, time locks, and SegWit (which was still under "
  },
  {
    "path": "/docs/history/people#andreas-m-antonopoulos",
    "title": "Andreas M. Antonopoulos",
    "section": "history",
    "body": "Contribution: Author, educator, Bitcoin evangelist Andreas M. Antonopoulos is a Greek-British author, speaker, and educator who has become one of the most influential voices in Bitcoin and blockchain education. He is best known for his book \"Mastering Bitcoin\" (2014), a detailed technical guide that has become the standard reference for Bitcoin developers. His other works include: \"The Internet "
  },
  {
    "path": "/docs/history/people#roger-ver",
    "title": "Roger Ver",
    "section": "history",
    "body": "Contribution: Early investor, \"Bitcoin Jesus,\" Bitcoin Cash advocate Roger Ver is an early Bitcoin investor and promoter who became known as \"Bitcoin Jesus\" for his advocacy and funding of Bitcoin-related projects and businesses. He was an outspoken supporter of increasing Bitcoin's block size and, during the blocksize wars, backed alternative implementations and the hard fork that created "
  },
  {
    "path": "/docs/fundamentals",
    "title": "Bitcoin Fundamentals",
    "section": "fundamentals",
    "body": "What is Bitcoin? Bitcoin is a decentralized digital currency and payment system that operates without a central authority or intermediary. It was created in 2009 by an anonymous person or group using the pseudonym Satoshi Nakamoto, who first described the system in the Bitcoin whitepaper published on October 31, 2008. While this definition captures Bitcoin's technical foundation, Bitcoin is multifaceted. As you go down the Bitcoin rabbit hole, you'll discover that Bitcoin represents something "
  },
  {
    "path": "/docs/fundamentals#core-components",
    "title": "Core Components",
    "section": "fundamentals",
    "body": "Bitcoin consists of several key components that work together to create a decentralized monetary system: Blockchain: The distributed ledger that records all transactions in cryptographically linked "
  },
  {
    "path": "/docs/fundamentals#how-bitcoin-works",
    "title": "How Bitcoin works",
    "section": "fundamentals",
    "body": "At a high level: you hold private keys that control addresses. To send bitcoin you build a transaction that spends UTXOs and creates new outputs. The transaction is broadcast to the network and sits "
  },
  {
    "path": "/docs/fundamentals#technical-innovation",
    "title": "Technical Innovation",
    "section": "fundamentals",
    "body": "Proof-of-Work Secures the network through computational work Prevents double-spending Reaches consensus without central authority Requires significant computational resources UTXO Model Unspent "
  },
  {
    "path": "/docs/fundamentals#the-many-faces-of-bitcoin",
    "title": "The Many Faces of Bitcoin",
    "section": "fundamentals",
    "body": "The New Element Bitcoin represents something unprecedented: Element Zero, consisting only of energy. Proof of Work is the bridge between the physical and digital worlds. Real energy (electricity, "
  },
  {
    "path": "/docs/fundamentals#explore-bitcoin-fundamentals",
    "title": "Explore Bitcoin Fundamentals",
    "section": "fundamentals",
    "body": "Dive deeper into the core concepts that make Bitcoin work: Bitcoin as Timechain - How Bitcoin solves timing in decentralized networks UTXO Model - How Bitcoin tracks ownership through unspent "
  },
  {
    "path": "/docs/fundamentals/problems",
    "title": "Problems Bitcoin Solved",
    "section": "fundamentals",
    "body": "What Problems Did Bitcoin Solve? Bitcoin addresses fundamental challenges in digital currency and distributed systems that had prevented previous attempts at decentralized money. The Core Challenges Before Bitcoin, decentralized digital currency faced seemingly insurmountable problems: No central authority: Traditional systems rely on banks/servers to coordinate Network unreliability: Nodes fail, messages get lost, partitions occur Byzantine failures: Some participants may be malicious or send "
  },
  {
    "path": "/docs/fundamentals/problems#the-core-challenges",
    "title": "The Core Challenges",
    "section": "fundamentals",
    "body": "Before Bitcoin, decentralized digital currency faced seemingly insurmountable problems: No central authority: Traditional systems rely on banks/servers to coordinate Network unreliability: Nodes "
  },
  {
    "path": "/docs/fundamentals/problems#the-double-spending-problem",
    "title": "The Double-Spending Problem",
    "section": "fundamentals",
    "body": "Double-spending occurs when the same digital currency unit is spent more than once. Unlike physical cash, digital information can be perfectly copied; without protection, the same coin could be sent "
  },
  {
    "path": "/docs/fundamentals/problems#the-two-generals-problem",
    "title": "The Two Generals Problem",
    "section": "fundamentals",
    "body": "A classic distributed systems problem that demonstrates the impossibility of achieving perfect agreement over an unreliable communication channel. The Scenario Two armies, led by two generals, are "
  },
  {
    "path": "/docs/fundamentals/problems#other-problems-solved",
    "title": "Other Problems Solved",
    "section": "fundamentals",
    "body": "| Problem | Traditional Issue | Bitcoin's Solution | |---------|------------------|-------------------| | Byzantine Generals | Malicious nodes send conflicting information | Proof-of-work makes "
  },
  {
    "path": "/docs/fundamentals/problems#the-innovation",
    "title": "The Innovation",
    "section": "fundamentals",
    "body": "Bitcoin didn't invent new primitives; it combined existing techniques in a novel way: Cryptography: Digital signatures, hash functions Distributed systems: Peer-to-peer network Economics: Incentive "
  },
  {
    "path": "/docs/fundamentals/problems#the-philosophical-foundation",
    "title": "The Philosophical Foundation",
    "section": "fundamentals",
    "body": "The problems Bitcoin solved were precisely the problems that cypherpunk philosophy had been trying to address for decades. Cypherpunks believed that cryptography could enable individual freedom by "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy",
    "title": "Cypherpunk Philosophy",
    "section": "fundamentals",
    "body": "Cypherpunk Philosophy Bitcoin didn't emerge from a vacuum. It was born from a decades-long movement of cryptographers, privacy advocates, and technologists who believed that cryptography could be a tool for individual freedom and liberation. This movement, known as cypherpunk, provided the philosophical foundation that shaped Bitcoin's core design principles. Cypherpunk is a philosophy and movement that advocates for privacy and freedom through cryptography. The term combines \"cypher\" "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#core-principles",
    "title": "Core Principles",
    "section": "fundamentals",
    "body": "Privacy Through Cryptography The Cypherpunk Manifesto Cypherpunks believe that privacy is essential for an open society, but it cannot be granted by governments or corporations; it must be enforced "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#historical-context",
    "title": "Historical Context",
    "section": "fundamentals",
    "body": "The Cypherpunk Mailing List In 1992, three mathematicians (Eric Hughes, Timothy C. May, and John Gilmore) founded the cypherpunk mailing list. This became the central forum for discussing "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#key-figures",
    "title": "Key Figures",
    "section": "fundamentals",
    "body": "Timothy May Timothy May was a physicist and one of the founders of the cypherpunk movement. He wrote \"The Crypto Anarchist Manifesto\" (1992), which predicted that cryptography would enable new forms "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#how-cypherpunk-philosophy-influenced-bitcoin",
    "title": "How Cypherpunk Philosophy Influenced Bitcoin",
    "section": "fundamentals",
    "body": "Why Satoshi Posted to the Cypherpunk Mailing List On October 31, 2008, Satoshi Nakamoto announced Bitcoin on the cypherpunk mailing list. This was intentional: Bitcoin was designed for people who "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#connection-to-bitcoin-fundamentals",
    "title": "Connection to Bitcoin Fundamentals",
    "section": "fundamentals",
    "body": "Trust Model Bitcoin's trust model directly implements the cypherpunk principle of \"trust code, not people.\" Instead of trusting banks or governments, Bitcoin users trust: Cryptographic proof "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#the-cypherpunk-legacy",
    "title": "The Cypherpunk Legacy",
    "section": "fundamentals",
    "body": "\"Cypherpunks Write Code\" The most famous cypherpunk principle is: \"Cypherpunks write code.\" This means: Action through technology is more powerful than political advocacy Code can enforce rights that "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#modern-relevance",
    "title": "Modern Relevance",
    "section": "fundamentals",
    "body": "Why These Principles Still Matter Cypherpunk principles are more relevant than ever: Government surveillance: Mass surveillance programs continue to expand Financial censorship: Banks can freeze "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#conclusion",
    "title": "Conclusion",
    "section": "fundamentals",
    "body": "Cypherpunk philosophy provided the intellectual and philosophical foundation for Bitcoin. The movement's core principles (privacy through cryptography, trust in code, decentralization, permissionless "
  },
  {
    "path": "/docs/fundamentals/cypherpunk-philosophy#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "People in Bitcoin - Learn about the cypherpunk figures who influenced Bitcoin Trust Model - How Bitcoin implements \"trust code, not people\" Decentralization - How Bitcoin avoids central control "
  },
  {
    "path": "/docs/fundamentals/blockchain",
    "title": "The Blockchain",
    "section": "fundamentals",
    "body": "The Blockchain The blockchain is Bitcoin's foundational data structure: a cryptographically linked chain of blocks that creates an immutable, verifiable record of all transactions. Each block contains a hash of the previous block's header, creating an unbreakable chain where altering any block invalidates all subsequent blocks. This structure enables trustless verification, prevents tampering, and forms the backbone of Bitcoin's security model. A blockchain is a sequence of blocks, where each "
  },
  {
    "path": "/docs/fundamentals/blockchain#block-structure-and-hash-linking",
    "title": "Block Structure and Hash Linking",
    "section": "fundamentals",
    "body": "Each block in Bitcoin contains a header with several fields, including a critical reference to the previous block: [Block Header Structure] ├── Version (4 bytes) ├── Previous Block Hash (32 bytes) - "
  },
  {
    "path": "/docs/fundamentals/blockchain#immutability-through-chain-structure",
    "title": "Immutability Through Chain Structure",
    "section": "fundamentals",
    "body": "The blockchain's immutability comes from the combination of hash linking and proof-of-work: Why Changing History Is Prohibitively Expensive To change a block in the chain, an attacker must: Modify "
  },
  {
    "path": "/docs/fundamentals/blockchain#chain-verification",
    "title": "Chain Verification",
    "section": "fundamentals",
    "body": "Nodes verify the blockchain's integrity by checking: Header Chain Verification Previous hash links: Each block's \"Previous Block Hash\" matches the actual hash of the previous block Proof-of-work "
  },
  {
    "path": "/docs/fundamentals/blockchain#relationship-to-other-bitcoin-concepts",
    "title": "Relationship to Other Bitcoin Concepts",
    "section": "fundamentals",
    "body": "The blockchain structure is fundamental to many other Bitcoin concepts: Consensus The blockchain enables consensus without a central authority: All nodes independently verify the same chain structure "
  },
  {
    "path": "/docs/fundamentals/blockchain#practical-implications",
    "title": "Practical Implications",
    "section": "fundamentals",
    "body": "Understanding the blockchain structure explains several important aspects of Bitcoin: Why Confirmations Matter Each block added after your transaction makes it more secure: Block 1: Your transaction "
  },
  {
    "path": "/docs/fundamentals/blockchain#comparison-to-traditional-systems",
    "title": "Comparison to Traditional Systems",
    "section": "fundamentals",
    "body": "| Aspect | Traditional Database | Bitcoin Blockchain | |--------|---------------------|-------------------| | Modification | Records can be updated or deleted | Append-only: history cannot be changed "
  },
  {
    "path": "/docs/fundamentals/blockchain#the-elegance-of-the-solution",
    "title": "The Elegance of the Solution",
    "section": "fundamentals",
    "body": "The blockchain structure is elegant because it: Solves multiple problems simultaneously: Immutability, verification, consensus, and security Requires no trust: The structure itself provides security "
  },
  {
    "path": "/docs/fundamentals/blockchain#common-misconceptions",
    "title": "Common Misconceptions",
    "section": "fundamentals",
    "body": "\"Blockchain is just a database\" While the blockchain stores data, it's fundamentally different from a traditional database: Immutable: Cannot modify or delete records Decentralized: No central "
  },
  {
    "path": "/docs/fundamentals/blockchain#conclusion",
    "title": "Conclusion",
    "section": "fundamentals",
    "body": "The blockchain is Bitcoin's foundational innovation: a cryptographically linked chain of blocks that creates an immutable, verifiable record. By linking each block to the previous one through "
  },
  {
    "path": "/docs/fundamentals/timechain",
    "title": "Bitcoin as Timechain",
    "section": "fundamentals",
    "body": "Bitcoin as Timechain As Leslie Lamport once said: Special Relativity teaches us, that two different observers can have different notions of what at the same time means. Bitcoin solves one of the most fundamental problems in distributed systems: how to order events in time without a central time source. In a decentralized network where nodes may have different clocks, network delays are unpredictable, and there's no trusted authority, determining the sequence of events is essential yet seemingly "
  },
  {
    "path": "/docs/fundamentals/timechain#why-timing-matters",
    "title": "Why Timing Matters",
    "section": "fundamentals",
    "body": "In any distributed system, especially one handling financial transactions, the order of events is critical: Preventing double-spending: If Alice sends 1 BTC to both Bob and Charlie, which transaction "
  },
  {
    "path": "/docs/fundamentals/timechain#the-problem-no-synchronized-clocks",
    "title": "The Problem: No Synchronized Clocks",
    "section": "fundamentals",
    "body": "In a distributed network without central coordination, nodes face several timing challenges: Clock Drift Each node's local clock may run at slightly different speeds. Over time, clocks drift apart, "
  },
  {
    "path": "/docs/fundamentals/timechain#bitcoins-solution-proof-of-work-as-time",
    "title": "Bitcoin's Solution: Proof-of-Work as Time",
    "section": "fundamentals",
    "body": "Bitcoin solves the timing problem by using proof-of-work to create an objective, verifiable ordering mechanism. Instead of relying on clocks, Bitcoin uses computational work as a proxy for time. "
  },
  {
    "path": "/docs/fundamentals/timechain#the-blockchain-as-timechain",
    "title": "The Blockchain as Timechain",
    "section": "fundamentals",
    "body": "The blockchain is fundamentally a timechain: a cryptographically secured sequence of events ordered by proof-of-work. This temporal structure enables several critical functions: Transaction Ordering "
  },
  {
    "path": "/docs/fundamentals/timechain#why-this-is-essential",
    "title": "Why This Is Essential",
    "section": "fundamentals",
    "body": "The timechain property is fundamental to Bitcoin's operation: | Function | Why Timechain Matters | |----------|----------------------| | Consensus | Nodes agree on transaction order without central "
  },
  {
    "path": "/docs/fundamentals/timechain#comparison-to-traditional-systems",
    "title": "Comparison to Traditional Systems",
    "section": "fundamentals",
    "body": "| Aspect | Traditional Systems | Bitcoin (Timechain) | |--------|-------------------|---------------------| | Time Source | Central time server (NTP, atomic clocks) | Proof-of-work creates ordering | "
  },
  {
    "path": "/docs/fundamentals/timechain#the-elegance-of-the-solution",
    "title": "The Elegance of the Solution",
    "section": "fundamentals",
    "body": "Bitcoin's timechain solution is elegant because it: Uses existing mechanism: Proof-of-work already secures the network; it also provides ordering No additional trust: Doesn't require trusting time "
  },
  {
    "path": "/docs/fundamentals/timechain#practical-implications",
    "title": "Practical Implications",
    "section": "fundamentals",
    "body": "Understanding Bitcoin as a timechain helps explain: Why confirmations matter: Each block adds more work, making the ordering more secure Why block time matters: ~10 minutes balances security (enough "
  },
  {
    "path": "/docs/fundamentals/timechain#conclusion",
    "title": "Conclusion",
    "section": "fundamentals",
    "body": "Bitcoin's timechain is a fundamental innovation that enables trustless ordering of events in a decentralized network. By using proof-of-work to create an objective sequence of blocks, Bitcoin solves "
  },
  {
    "path": "/docs/fundamentals/utxos",
    "title": "UTXO Model",
    "section": "fundamentals",
    "body": "The UTXO Model The UTXO (Unspent Transaction Output) model is one of Bitcoin's most fundamental and elegant design choices. Unlike traditional account-based systems where balances are stored in accounts, Bitcoin tracks ownership through discrete, spendable transaction outputs. Understanding UTXOs is essential to understanding how Bitcoin actually works. A UTXO is a transaction output that hasn't been spent yet. It represents the actual \"coins\" in Bitcoin's accounting model. When you \"have 1 ",
    "keywords": [
      "utxo",
      "utxos",
      "unspent transaction output",
      "unspent transaction outputs"
    ]
  },
  {
    "path": "/docs/fundamentals/utxos#utxo-vs-account-based-systems",
    "title": "UTXO vs Account-Based Systems",
    "section": "fundamentals",
    "body": "Bitcoin's UTXO model differs fundamentally from traditional account-based systems: | Aspect | UTXO Model (Bitcoin) | Account-Based (Traditional) | "
  },
  {
    "path": "/docs/fundamentals/utxos#the-utxo-lifecycle",
    "title": "The UTXO Lifecycle",
    "section": "fundamentals",
    "body": "The UTXO lifecycle follows this flow: [Transaction Output in block] --> [UTXO unspent] --> [Referenced by Transaction Input] --> [Consumed removed from UTXO set] --> [New Outputs Created] "
  },
  {
    "path": "/docs/fundamentals/utxos#understanding-the-relationships",
    "title": "Understanding the Relationships",
    "section": "fundamentals",
    "body": "Addresses → Outputs → UTXOs Addresses are not accounts. They're human-readable encodings of spending conditions that get embedded in transaction outputs. [Address] -- encoded as --> [Output "
  },
  {
    "path": "/docs/fundamentals/utxos#practical-examples",
    "title": "Practical Examples",
    "section": "fundamentals",
    "body": "Simple Transaction Flow Scenario: Alice wants to send 0.1 BTC to Bob. She has a UTXO worth 0.5 BTC. Before: Alice's UTXO: 0.5 BTC (unspent) Transaction: Input: Alice's 0.5 BTC UTXO Output 1: 0.1 BTC "
  },
  {
    "path": "/docs/fundamentals/utxos#the-utxo-set",
    "title": "The UTXO Set",
    "section": "fundamentals",
    "body": "The UTXO Set is the complete database of all unspent transaction outputs at any given point in time. It represents the current state of Bitcoin ownership. What It Is The UTXO set is essentially "
  },
  {
    "path": "/docs/fundamentals/utxos#privacy-implications",
    "title": "Privacy Implications",
    "section": "fundamentals",
    "body": "The UTXO model has important privacy characteristics: Positive Aspects UTXO Independence: Each UTXO is separate; spending one doesn't automatically reveal others No Account Linking: Unlike "
  },
  {
    "path": "/docs/fundamentals/utxos#common-misconceptions",
    "title": "Common Misconceptions",
    "section": "fundamentals",
    "body": "\"I have a balance in my address\" Reality: Addresses don't hold balances. You control UTXOs whose scriptPubKeys match addresses derived from your keys. Your \"balance\" is the sum of UTXOs you can "
  },
  {
    "path": "/docs/fundamentals/utxos#why-this-matters",
    "title": "Why This Matters",
    "section": "fundamentals",
    "body": "Understanding the UTXO model is essential because: Transaction Construction: You must understand UTXOs to build valid transactions Fee Calculation: Transaction size (and thus fees) depends on the "
  },
  {
    "path": "/docs/fundamentals/utxos#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "Transaction Construction - How to build transactions using UTXOs Coin Selection - Algorithms for choosing which UTXOs to spend Address Types - How addresses relate to UTXO scriptPubKeys RPC Commands "
  },
  {
    "path": "/docs/fundamentals/decentralization",
    "title": "Decentralization",
    "section": "fundamentals",
    "body": "Decentralization Decentralization is the distribution of control across many independent participants rather than a single central authority. It's the foundation of Bitcoin's censorship resistance, resilience, and trustlessness. What Decentralization Means No single entity controls Bitcoin. Control is distributed across thousands of nodes, multiple mining pools, diverse developers, and a global user base. This means: No central authority: No government, company, or person controls Bitcoin No "
  },
  {
    "path": "/docs/fundamentals/decentralization#what-decentralization-means",
    "title": "What Decentralization Means",
    "section": "fundamentals",
    "body": "No single entity controls Bitcoin. Control is distributed across thousands of nodes, multiple mining pools, diverse developers, and a global user base. This means: No central authority: No "
  },
  {
    "path": "/docs/fundamentals/decentralization#why-it-matters",
    "title": "Why It Matters",
    "section": "fundamentals",
    "body": "Decentralization enables Bitcoin's core properties: | Property | Centralized System | Decentralized (Bitcoin) | |----------|-------------------|------------------------| | Censorship | Authority can "
  },
  {
    "path": "/docs/fundamentals/decentralization#how-bitcoin-achieves-decentralization",
    "title": "How Bitcoin Achieves Decentralization",
    "section": "fundamentals",
    "body": "Nodes Bitcoin has ~15,000-20,000 reachable full nodes spread across 100+ countries. Each node independently validates every transaction and stores the complete blockchain. No single node is "
  },
  {
    "path": "/docs/fundamentals/decentralization#the-bitcoin-trilemma",
    "title": "The Bitcoin Trilemma",
    "section": "fundamentals",
    "body": "The Bitcoin Trilemma describes the challenge of balancing three critical blockchain properties: Scalability, Security, and Decentralization. Optimizing one typically comes at the cost of another. The "
  },
  {
    "path": "/docs/fundamentals/decentralization#threats-to-decentralization",
    "title": "Threats to Decentralization",
    "section": "fundamentals",
    "body": "| Area | Risk | Mitigation | |------|------|------------| | Mining | Pool consolidation, geographic concentration, ASIC manufacturer influence | Miners can switch pools; competitive market; global "
  },
  {
    "path": "/docs/fundamentals/decentralization#measuring-decentralization",
    "title": "Measuring Decentralization",
    "section": "fundamentals",
    "body": "Quantitative: Node count, hash rate distribution across pools, geographic spread, implementation diversity. Qualitative: Can transactions be censored? Can the network survive targeted attacks? Can "
  },
  {
    "path": "/docs/fundamentals/trust-model",
    "title": "Trust Model",
    "section": "fundamentals",
    "body": "Trust Model Bitcoin's trust model differs fundamentally from traditional finance. Instead of trusting intermediaries (banks, payment processors, governments), Bitcoin uses cryptographic proof and economic incentives to create a trustless system: minimal trust, not zero trust. Traditional vs Bitcoin Trust | Aspect | Traditional System | Bitcoin | |--------|-------------------|---------| | Who to trust | Banks, payment processors, governments | The protocol and cryptography | | Single points of "
  },
  {
    "path": "/docs/fundamentals/trust-model#traditional-vs-bitcoin-trust",
    "title": "Traditional vs Bitcoin Trust",
    "section": "fundamentals",
    "body": "| Aspect | Traditional System | Bitcoin | |--------|-------------------|---------| | Who to trust | Banks, payment processors, governments | The protocol and cryptography | | Single points of failure "
  },
  {
    "path": "/docs/fundamentals/trust-model#what-trustless-really-means",
    "title": "What \"Trustless\" Really Means",
    "section": "fundamentals",
    "body": "You trust mathematics and code rather than people and institutions. This principle comes directly from cypherpunk philosophy, which advocates for \"trust code, not people\": Cryptographic proof: "
  },
  {
    "path": "/docs/fundamentals/trust-model#trust-assumptions",
    "title": "Trust Assumptions",
    "section": "fundamentals",
    "body": "What You Must Trust Protocol correctness: Bitcoin works as designed Cryptography: SHA-256, ECDSA remain secure Network honesty: Majority of hash rate follows the rules Your own security: You protect "
  },
  {
    "path": "/docs/fundamentals/trust-model#trust-minimization-techniques",
    "title": "Trust Minimization Techniques",
    "section": "fundamentals",
    "body": "Run a full node: Verify all transactions yourself instead of trusting others. Use open-source software: Code is publicly auditable with no hidden functionality. Self-custody: Control your own private "
  },
  {
    "path": "/docs/fundamentals/trust-model#trust-vs-convenience-spectrum",
    "title": "Trust vs Convenience Spectrum",
    "section": "fundamentals",
    "body": "| Approach | Trust Level | Trade-off | |----------|-------------|-----------| | Full node + self-custody | Minimal | Maximum security; requires technical knowledge and resources | | Light wallet | "
  },
  {
    "path": "/docs/fundamentals/monetary-properties",
    "title": "Monetary Properties",
    "section": "fundamentals",
    "body": "Monetary Properties Bitcoin exhibits key monetary properties that make it suitable as both a medium of exchange and a store of value. These properties emerge from Bitcoin's technical design and economic model. Core Monetary Properties | Property | Definition | Bitcoin Implementation | |----------|------------|----------------------| | Scarcity | Limited supply that cannot be arbitrarily increased | Fixed 21 million cap, predictable issuance via halving schedule | | Divisibility | Ability to "
  },
  {
    "path": "/docs/fundamentals/monetary-properties#core-monetary-properties",
    "title": "Core Monetary Properties",
    "section": "fundamentals",
    "body": "| Property | Definition | Bitcoin Implementation | |----------|------------|----------------------| | Scarcity | Limited supply that cannot be arbitrarily increased | Fixed 21 million cap, "
  },
  {
    "path": "/docs/fundamentals/monetary-properties#additional-properties",
    "title": "Additional Properties",
    "section": "fundamentals",
    "body": "Verifiability: Digital signatures prove ownership cryptographically. Anyone can verify transactions on the public blockchain, and counterfeiting is mathematically impossible. Programmability: Bitcoin "
  },
  {
    "path": "/docs/fundamentals/monetary-properties#comparison-to-traditional-money",
    "title": "Comparison to Traditional Money",
    "section": "fundamentals",
    "body": "| Property | Fiat Currency | Gold | Bitcoin | |----------|--------------|------|---------| | Scarcity | Can be printed indefinitely | Limited but unknown total | Fixed 21M cap | | Divisibility | "
  },
  {
    "path": "/docs/fundamentals/monetary-properties#economic-functions",
    "title": "Economic Functions",
    "section": "fundamentals",
    "body": "Store of Value: Scarcity and deflationary supply support long-term value preservation. High short-term volatility, but growing institutional adoption as a \"digital gold\" asset. Medium of Exchange: "
  },
  {
    "path": "/docs/fundamentals/denominations",
    "title": "Denominations",
    "section": "fundamentals",
    "body": "Denominations Bitcoin is highly divisible: one bitcoin (BTC) equals 100 million of the smallest on-chain unit, the satoshi (sat). This design supports both large transfers and tiny amounts, and it scales as the nominal value of each unit changes over time. Common units include satoshis for small amounts, bits (µBTC, or one millionth of a BTC) for everyday thinking, and millibits (mBTC) or whole BTC for larger sums. Understanding how these units relate helps when reading fees, block rewards, and ",
    "keywords": [
      "calculator",
      "denomination calculator",
      "convert",
      "sats",
      "satoshis",
      "btc",
      "units",
      "satoshi",
      "denominations"
    ]
  },
  {
    "path": "/docs/fundamentals/denominations#calculator",
    "title": "Calculator",
    "section": "fundamentals",
    "body": ":::denomination-calculator :::"
  },
  {
    "path": "/docs/fundamentals/denominations#conversion-table",
    "title": "Conversion Table",
    "section": "fundamentals",
    "body": "| Denomination | Symbol | Value in BTC | |-------------|--------|--------------| | Satoshi | SAT | 0.00000001 | | Microbit | µBTC (uBTC) | 0.000001 | | Millibit | mBTC | 0.001 | | Centibit | cBTC | "
  },
  {
    "path": "/docs/fundamentals/incentives",
    "title": "Incentive Structure",
    "section": "fundamentals",
    "body": "Incentive Structure Bitcoin's security and functionality emerge from carefully designed economic incentives that align the interests of all network participants toward honest behavior. Unlike traditional systems that rely on legal enforcement or trusted authorities, Bitcoin uses game theory and economic incentives to create a system where honesty is the most profitable strategy. Why Incentives Matter Bitcoin operates in a hostile environment where participants may be anonymous, geographically "
  },
  {
    "path": "/docs/fundamentals/incentives#why-incentives-matter",
    "title": "Why Incentives Matter",
    "section": "fundamentals",
    "body": "Bitcoin operates in a hostile environment where participants may be anonymous, geographically distributed, and potentially malicious. Without a central authority to enforce rules, Bitcoin must rely "
  },
  {
    "path": "/docs/fundamentals/incentives#core-principle-honesty-is-profitable",
    "title": "Core Principle: Honesty is Profitable",
    "section": "fundamentals",
    "body": "Bitcoin's incentive structure follows a simple principle: honest behavior is more profitable than dishonest behavior. This creates a Nash equilibrium where rational actors choose to follow the rules "
  },
  {
    "path": "/docs/fundamentals/incentives#miner-incentives",
    "title": "Miner Incentives",
    "section": "fundamentals",
    "body": "Miners are the primary security providers for the Bitcoin network. Their incentives are carefully designed to make securing the network more profitable than attacking it. Block Rewards The block "
  },
  {
    "path": "/docs/fundamentals/incentives#node-incentives",
    "title": "Node Incentives",
    "section": "fundamentals",
    "body": "Full nodes validate all transactions and blocks, maintaining network integrity. Unlike miners, nodes don't receive direct financial rewards, yet thousands of nodes operate worldwide. Why Run a Node? "
  },
  {
    "path": "/docs/fundamentals/incentives#user-incentives",
    "title": "User Incentives",
    "section": "fundamentals",
    "body": "Users are incentivized to use Bitcoin honestly through the fee market and security model. Fee Market Users compete for block space by offering transaction fees: Higher fees = Faster confirmation "
  },
  {
    "path": "/docs/fundamentals/incentives#developer-incentives",
    "title": "Developer Incentives",
    "section": "fundamentals",
    "body": "Bitcoin's open-source development model creates unique incentives for developers. Open Source Benefits Transparency: Code is auditable by anyone No single point of control: Multiple implementations "
  },
  {
    "path": "/docs/fundamentals/incentives#game-theory-and-nash-equilibrium",
    "title": "Game Theory and Nash Equilibrium",
    "section": "fundamentals",
    "body": "Bitcoin's incentive structure creates a Nash equilibrium: a situation where no participant can improve their outcome by unilaterally changing their strategy. The Mining Game Players: All miners "
  },
  {
    "path": "/docs/fundamentals/incentives#incentive-alignment-across-participants",
    "title": "Incentive Alignment Across Participants",
    "section": "fundamentals",
    "body": "Bitcoin's incentives align all participants toward network security: | Participant | Primary Incentive | How It Secures Network | |-------------|------------------|----------------------| | Miners | "
  },
  {
    "path": "/docs/fundamentals/incentives#long-term-incentive-sustainability",
    "title": "Long-Term Incentive Sustainability",
    "section": "fundamentals",
    "body": "Bitcoin's incentive structure is designed to remain effective long-term: Subsidy Transition Early years: Block subsidies provide primary miner revenue Transition: Transaction fees gradually become "
  },
  {
    "path": "/docs/fundamentals/incentives#comparison-with-traditional-systems",
    "title": "Comparison with Traditional Systems",
    "section": "fundamentals",
    "body": "| Aspect | Traditional Systems | Bitcoin | |--------|-------------------|---------| | Enforcement | Legal, regulatory, institutional | Economic incentives | | Trust | Trust in authorities | Trust in "
  },
  {
    "path": "/docs/fundamentals/incentives#conclusion",
    "title": "Conclusion",
    "section": "fundamentals",
    "body": "Bitcoin's incentive structure is the foundation of its security and functionality. By making honesty more profitable than dishonesty, Bitcoin creates a system where rational self-interest naturally "
  },
  {
    "path": "/docs/fundamentals/incentives#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "Game Theory - Deep dive into game-theoretic principles behind Bitcoin's incentive structure Trust Model - How incentives minimize trust requirements Consensus Mechanism - How incentives enable "
  },
  {
    "path": "/docs/fundamentals/game-theory",
    "title": "Game Theory",
    "section": "fundamentals",
    "body": "Game Theory Game theory is the mathematical study of strategic decision-making. In Bitcoin, game theory explains why the network remains secure even when participants are anonymous, potentially malicious, and have no reason to trust each other. Bitcoin's design creates a system where rational self-interest naturally leads to honest behavior and network security. Why Game Theory Matters for Bitcoin Traditional financial systems rely on legal enforcement, trusted authorities, and institutional "
  },
  {
    "path": "/docs/fundamentals/game-theory#why-game-theory-matters-for-bitcoin",
    "title": "Why Game Theory Matters for Bitcoin",
    "section": "fundamentals",
    "body": "Traditional financial systems rely on legal enforcement, trusted authorities, and institutional oversight. Bitcoin operates in a trustless environment where: Participants may be anonymous No central "
  },
  {
    "path": "/docs/fundamentals/game-theory#game-theory-basics",
    "title": "Game Theory Basics",
    "section": "fundamentals",
    "body": "A game in game theory consists of: Players: Participants who make decisions (miners, nodes, users) Strategies: Choices available to each player (mine honestly vs. attack, validate vs. accept invalid "
  },
  {
    "path": "/docs/fundamentals/game-theory#the-prisoners-dilemma",
    "title": "The Prisoner's Dilemma",
    "section": "fundamentals",
    "body": "The Prisoner's Dilemma is a classic game theory problem where two players must choose between cooperation and defection. The dilemma: each player's dominant strategy (defect) leads to a worse outcome "
  },
  {
    "path": "/docs/fundamentals/game-theory#coordination-without-authority",
    "title": "Coordination Without Authority",
    "section": "fundamentals",
    "body": "Bitcoin achieves coordination among thousands of independent participants without a central authority. This is a coordination game: multiple players benefit from choosing the same strategy. The "
  },
  {
    "path": "/docs/fundamentals/game-theory#games-in-bitcoin",
    "title": "Games in Bitcoin",
    "section": "fundamentals",
    "body": "Bitcoin contains multiple interconnected games, each with different players, strategies, and payoffs: The Mining Game Players: All miners Strategies: Mine honestly vs. attack the network Payoffs: "
  },
  {
    "path": "/docs/fundamentals/game-theory#attack-deterrence",
    "title": "Attack Deterrence",
    "section": "fundamentals",
    "body": "Game theory explains why attacks on Bitcoin are economically irrational. The game-theoretic structure makes attacks unprofitable: Attack Cost > Potential Gain × Probability of Success Why Attacks "
  },
  {
    "path": "/docs/fundamentals/game-theory#game-theory-and-network-security",
    "title": "Game Theory and Network Security",
    "section": "fundamentals",
    "body": "Game theory provides the theoretical foundation for Bitcoin's security: Incentive Alignment: All participants benefit from network security Attack Deterrence: Attacks are economically irrational "
  },
  {
    "path": "/docs/fundamentals/game-theory#conclusion",
    "title": "Conclusion",
    "section": "fundamentals",
    "body": "Game theory explains why Bitcoin works. By structuring incentives so that honest behavior is the most profitable strategy, Bitcoin creates a system where: Rational self-interest leads to network "
  },
  {
    "path": "/docs/fundamentals/game-theory#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "Incentive Structure - Detailed analysis of economic incentives and Nash equilibrium Trust Model - How game theory minimizes trust requirements Consensus Mechanism - How game theory enables "
  },
  {
    "path": "/docs/fundamentals/governance",
    "title": "Governance & Evolution",
    "section": "fundamentals",
    "body": "Governance & Evolution Bitcoin has no central authority. Its evolution happens through a decentralized process of rough consensus, where changes are proposed, discussed, and adopted (or rejected) by the community. How Bitcoin Evolves The Process Proposal: BIP (Bitcoin Improvement Proposal) Discussion: Community review and debate Implementation: Code written and tested Activation: Network-wide adoption Deployment: Soft fork or hard fork Key Principles Rough consensus: No formal voting, but broad "
  },
  {
    "path": "/docs/fundamentals/governance#how-bitcoin-evolves",
    "title": "How Bitcoin Evolves",
    "section": "fundamentals",
    "body": "The Process Proposal: BIP (Bitcoin Improvement Proposal) Discussion: Community review and debate Implementation: Code written and tested Activation: Network-wide adoption Deployment: Soft fork or "
  },
  {
    "path": "/docs/fundamentals/governance#bitcoin-improvement-proposals-bips",
    "title": "Bitcoin Improvement Proposals (BIPs)",
    "section": "fundamentals",
    "body": "BIP Types | Type | Description | Examples | |------|-------------|----------| | Standards Track | Protocol changes | BIP 141 (SegWit), BIP 341 (Taproot) | | Informational | Guidelines, information | "
  },
  {
    "path": "/docs/fundamentals/governance#activation-mechanisms",
    "title": "Activation Mechanisms",
    "section": "fundamentals",
    "body": "Soft Fork Activation BIP 9 (Version Bits): Miners signal in block version Requires 95% threshold Grace period for activation User-Activated Soft Fork (UASF): Nodes enforce rules Community-driven Used "
  },
  {
    "path": "/docs/fundamentals/governance#key-stakeholders",
    "title": "Key Stakeholders",
    "section": "fundamentals",
    "body": "Miners Role: Secure network, process transactions Influence: Can signal for soft forks Limits: Can't force unwanted changes Developers Role: Write code, propose changes Influence: Technical expertise "
  },
  {
    "path": "/docs/fundamentals/governance#historical-examples",
    "title": "Historical Examples",
    "section": "fundamentals",
    "body": "SegWit Activation Process: Proposed in 2015 Years of debate (Blocksize Wars) UASF movement (BIP 148) Activated August 2017 ~80% adoption today Taproot Activation Process: Proposed 2018 Community "
  },
  {
    "path": "/docs/fundamentals/governance#challenges",
    "title": "Challenges",
    "section": "fundamentals",
    "body": "Coordination Problems No central authority: Hard to coordinate changes Diverse interests: Different stakeholders want different things Slow process: Changes take years Controversies Blocksize Wars: "
  },
  {
    "path": "/docs/fundamentals/governance#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "BIPs - Bitcoin Improvement Proposals Forks - Protocol upgrades Controversies - Major debates"
  },
  {
    "path": "/docs/fundamentals/governance#resources",
    "title": "Resources",
    "section": "fundamentals",
    "body": "BIP Repository Bitcoin Dev Mailing List Bitcoin Optech - Technical newsletter"
  },
  {
    "path": "/docs/fundamentals/bitcoin-meme",
    "title": "Bitcoin, the Meme",
    "section": "fundamentals",
    "body": "Bitcoin, the Meme Bitcoin is more than code and cryptography. It's a meme in the original sense: an idea that replicates itself through human minds, spreading from person to person, generation to generation, border to border. As described in Bitcoin Fundamentals, Bitcoin embodies the idea that a fixed set of rules can exist around which entire societies can be built, rules that no government, corporation, or individual can change. Once the concept of sound, digital, decentralized money enters "
  },
  {
    "path": "/docs/fundamentals/bitcoin-meme#the-orange-pill",
    "title": "The Orange Pill",
    "section": "fundamentals",
    "body": "The orange pill refers to the process of someone \"waking up\" to Bitcoin's implications, a reference to The Matrix, where taking the red pill means seeing reality as it truly is. The Journey The "
  },
  {
    "path": "/docs/fundamentals/bitcoin-meme#magic-internet-money-other-memes",
    "title": "Magic Internet Money & Other Memes",
    "section": "fundamentals",
    "body": "Bitcoin culture has produced numerous memes that serve multiple functions: they're satirical, self-deprecating, educational, and defensive. Magic Internet Money Magic Internet Money is a satirical "
  },
  {
    "path": "/docs/fundamentals/bitcoin-meme#related-topics",
    "title": "Related Topics",
    "section": "fundamentals",
    "body": "Cypherpunk Philosophy - The philosophical foundation behind Bitcoin Trust Model - How Bitcoin enables trustless transactions Game Theory - How strategic decision-making secures Bitcoin Bitcoin "
  },
  {
    "path": "/docs/history",
    "title": "Bitcoin History",
    "section": "history",
    "body": "Historical Milestones Bitcoin's history spans from its creation in 2009 to its future supply schedule extending into the 22nd century. 2008 Bitcoin Whitepaper Published Date: October 31, 2008 Author: Satoshi Nakamoto Title: \"Bitcoin: A Peer-to-Peer Electronic Cash System\" Satoshi Nakamoto published the Bitcoin whitepaper, introducing the concept of a decentralized digital currency system. The whitepaper outlined the technical foundation for Bitcoin, including proof-of-work, the blockchain, and "
  },
  {
    "path": "/docs/history#2008",
    "title": "2008",
    "section": "history",
    "body": "Bitcoin Whitepaper Published Date: October 31, 2008 Author: Satoshi Nakamoto Title: \"Bitcoin: A Peer-to-Peer Electronic Cash System\" Satoshi Nakamoto published the Bitcoin whitepaper, introducing the "
  },
  {
    "path": "/docs/history#2009",
    "title": "2009",
    "section": "history",
    "body": "Bitcoin Launch Date: January 3, 2009 Block: 0 (Genesis Block) Block Reward: 50 BTC Creator: Satoshi Nakamoto The Genesis Block was mined by Satoshi Nakamoto, marking the birth of the Bitcoin network. "
  },
  {
    "path": "/docs/history#2010",
    "title": "2010",
    "section": "history",
    "body": "Satoshi's Handover Date: Mid–late 2010 Satoshi Nakamoto gradually handed over Bitcoin development and repository access to Gavin Andresen and others, then stopped appearing in forums and email. The "
  },
  {
    "path": "/docs/history#2011",
    "title": "2011",
    "section": "history",
    "body": "Dollar Parity Date: February 9, 2011 Price: $1/BTC Bitcoin reached parity with the US dollar for the first time. First Major Rally Date: June 8, 2011 Price: $31/BTC Bitcoin's first major price spike, "
  },
  {
    "path": "/docs/history#2012",
    "title": "2012",
    "section": "history",
    "body": "First Halving Date: November 28, 2012 Block: 210,000 New Reward: 25 BTC The first halving reduced the block reward from 50 BTC to 25 BTC. Bitcoin Foundation Date: September 27, 2012 The Bitcoin "
  },
  {
    "path": "/docs/history#2013",
    "title": "2013",
    "section": "history",
    "body": "Billion Dollar Market Cap Date: March 28, 2013 Bitcoin's market capitalization exceeded $1 billion for the first time. First $1,000 Date: November 29, 2013 Price: $1,000/BTC Bitcoin crossed $1,000 "
  },
  {
    "path": "/docs/history#2014",
    "title": "2014",
    "section": "history",
    "body": "Mt. Gox Collapse Date: February 2014 Mt. Gox, then the world's largest Bitcoin exchange, suspended trading and declared bankruptcy after losing approximately 850,000 BTC to theft and operational "
  },
  {
    "path": "/docs/history#2015",
    "title": "2015",
    "section": "history",
    "body": "Scaling Debate and Lightning Whitepaper Date: 2015 The blocksize wars intensified as Bitcoin’s 1 MB block limit began to bite. Proposals to raise the limit (e.g. Bitcoin XT, larger blocks) clashed "
  },
  {
    "path": "/docs/history#2016",
    "title": "2016",
    "section": "history",
    "body": "Second Halving Date: July 9, 2016 Block: 420,000 New Reward: 12.5 BTC"
  },
  {
    "path": "/docs/history#2017",
    "title": "2017",
    "section": "history",
    "body": "Bitcoin Cash Fork Date: August 1, 2017 The contentious hard fork created Bitcoin Cash (BCH), splitting the community over the block size debate. First $20,000 Date: December 17, 2017 Price: "
  },
  {
    "path": "/docs/history#2020",
    "title": "2020",
    "section": "history",
    "body": "Third Halving Date: May 11, 2020 Block: 630,000 New Reward: 6.25 BTC"
  },
  {
    "path": "/docs/history#2021",
    "title": "2021",
    "section": "history",
    "body": "El Salvador Adoption Date: September 7, 2021 El Salvador became the first country to adopt Bitcoin as legal tender."
  },
  {
    "path": "/docs/history#2024",
    "title": "2024",
    "section": "history",
    "body": "Fourth Halving Date: April 20, 2024 Block: 840,000 New Reward: 3.125 BTC Spot Bitcoin ETFs Date: January 10, 2024 The SEC approved the first spot Bitcoin ETFs in the United States, opening Bitcoin "
  },
  {
    "path": "/docs/history#future",
    "title": "Future",
    "section": "history",
    "body": "All Coins Issued Date: ~2140 (estimated) Block: ~6,930,000 Significance: Last new Bitcoin will be created After this date, no new Bitcoin will be created through block rewards. Miners will rely "
  },
  {
    "path": "/docs/history/people",
    "title": "People",
    "section": "history",
    "body": "People in Bitcoin Bitcoin didn't emerge from a vacuum. It was built on decades of cryptographic research and the work of visionary cypherpunks who dreamed of digital cash. This page honors both the pioneers who laid the groundwork and the contributors who brought Bitcoin to life. Pioneers (pre-Bitcoin): David Chaum, Eric Hughes, Timothy C. May, John Gilmore, Adam Back, Nick Szabo, Wei Dai, Ralph Merkle, Stuart Haber and Scott Stornetta Bitcoin builders: Satoshi Nakamoto, Hal Finney, Len "
  },
  {
    "path": "/docs/history/people#david-chaum",
    "title": "David Chaum",
    "section": "history",
    "body": "Contribution: eCash (1982) - The godfather of cryptocurrency David Chaum is widely regarded as the inventor of digital cash. In 1982, he published \"Blind Signatures for Untraceable Payments,\" "
  },
  {
    "path": "/docs/history/people#eric-hughes",
    "title": "Eric Hughes",
    "section": "history",
    "body": "Contribution: \"A Cypherpunk's Manifesto\" (1993) - Privacy through cryptography Eric Hughes is a mathematician and privacy advocate who wrote \"A Cypherpunk's Manifesto\" in 1993, which became one of "
  },
  {
    "path": "/docs/history/people#timothy-c-may",
    "title": "Timothy C. May",
    "section": "history",
    "body": "Contribution: \"The Crypto Anarchist Manifesto,\" cypherpunk mailing list co-founder Timothy C. May was an American physicist and writer who authored \"The Crypto Anarchist Manifesto\" (1988) and "
  },
  {
    "path": "/docs/history/people#john-gilmore",
    "title": "John Gilmore",
    "section": "history",
    "body": "Contribution: Cypherpunk mailing list co-founder (1992) John Gilmore is a computer scientist, entrepreneur, and civil-liberties advocate who co-founded the cypherpunk mailing list with Eric Hughes "
  },
  {
    "path": "/docs/history/people#adam-back",
    "title": "Adam Back",
    "section": "history",
    "body": "Contribution: Hashcash (1997) - Proof-of-Work for spam prevention Adam Back is a British cryptographer who invented Hashcash in 1997, a proof-of-work system designed to limit email spam and "
  },
  {
    "path": "/docs/history/people#nick-szabo",
    "title": "Nick Szabo",
    "section": "history",
    "body": "Contribution: Bit Gold (1998) - Decentralized digital currency concept Nick Szabo is a computer scientist, legal scholar, and cryptographer who designed Bit Gold in 1998, often called the direct "
  },
  {
    "path": "/docs/history/people#wei-dai",
    "title": "Wei Dai",
    "section": "history",
    "body": "Contribution: b-money (1998) - Digital scarcity and distributed consensus Wei Dai is a computer engineer and cryptographer who proposed b-money in 1998, a theoretical system for an anonymous, "
  },
  {
    "path": "/docs/history/people#ralph-merkle",
    "title": "Ralph Merkle",
    "section": "history",
    "body": "Contribution: Merkle trees (1979) - Efficient verification of block contents Ralph Merkle is a computer scientist who invented Merkle trees (also called hash trees) in 1979. In this structure, leaf "
  },
  {
    "path": "/docs/history/people#stuart-haber-and-scott-stornetta",
    "title": "Stuart Haber and Scott Stornetta",
    "section": "history",
    "body": "Contribution: Secure timestamps (1990-91) - \"How to time-stamp a digital document\" Stuart Haber and W. Scott Stornetta are cryptographers who, in a 1991 paper, solved the problem of timestamping "
  },
  {
    "path": "/docs/history/people#satoshi-nakamoto",
    "title": "Satoshi Nakamoto",
    "section": "history",
    "body": "Contribution: Bitcoin (2008-2010) - Creator of Bitcoin Satoshi Nakamoto is the pseudonymous person or group who created Bitcoin. On October 31, 2008, Nakamoto published the Bitcoin whitepaper, "
  },
  {
    "path": "/docs/history/people#hal-finney",
    "title": "Hal Finney",
    "section": "history",
    "body": "Contribution: RPOW, PGP 2.0, first Bitcoin transaction recipient Hal Finney was a cryptographic pioneer and one of Bitcoin's most important early contributors. Before Bitcoin, he developed RPOW "
  },
  {
    "path": "/docs/history/people#len-sassaman",
    "title": "Len Sassaman",
    "section": "history",
    "body": "Contribution: Cypherpunk, anonymous remailer developer Len Sassaman was a cypherpunk, privacy advocate, and cryptographer who made significant contributions to anonymity and privacy-preserving "
  },
  {
    "path": "/docs/history/people#martti-malmi",
    "title": "Martti Malmi",
    "section": "history",
    "body": "Contribution: Early contributor (2009-11) - bitcoin.org, first exchange and community tools Martti Malmi (known online as Sirius) was one of Bitcoin's first contributors after Satoshi Nakamoto and "
  },
  {
    "path": "/docs/history/people#gavin-andresen",
    "title": "Gavin Andresen",
    "section": "history",
    "body": "Contribution: Lead developer after Satoshi (2010-2014) Gavin Andresen is a software developer who became the lead maintainer of Bitcoin's code after Satoshi Nakamoto's departure. In late 2010, "
  },
  {
    "path": "/docs/history/people#laszlo-hanyecz",
    "title": "Laszlo Hanyecz",
    "section": "history",
    "body": "Contribution: First documented real-world Bitcoin transaction (May 2010) - \"Bitcoin pizza\" Laszlo Hanyecz is a programmer who, on May 22, 2010, completed the first known commercial transaction using "
  },
  {
    "path": "/docs/history/people#wladimir-van-der-laan",
    "title": "Wladimir van der Laan",
    "section": "history",
    "body": "Contribution: Bitcoin Core lead maintainer (2014-2021) Wladimir van der Laan is a software developer who served as the lead maintainer of Bitcoin Core from 2014 to 2021. He took over the role from "
  },
  {
    "path": "/docs/history/people#pieter-wuille",
    "title": "Pieter Wuille",
    "section": "history",
    "body": "Contribution: SegWit (BIP 141), Taproot (BIP 340-342), libsecp256k1 Pieter Wuille is a Belgian software engineer and one of the most influential Bitcoin protocol developers. He is the primary author "
  },
  {
    "path": "/docs/history/people#gregory-maxwell",
    "title": "Gregory Maxwell",
    "section": "history",
    "body": "Contribution: Bitcoin Core developer, Blockstream co-founder, CoinJoin, Confidential Transactions, Sidechains Gregory Maxwell (Greg) is a Bitcoin Core developer and one of the most influential "
  },
  {
    "path": "/docs/history/people#joseph-poon-and-thaddeus-dryja",
    "title": "Joseph Poon and Thaddeus Dryja",
    "section": "history",
    "body": "Contribution: Lightning Network whitepaper (2015) Joseph Poon and Thaddeus Dryja authored \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments\" (2015), which described a second-layer "
  },
  {
    "path": "/docs/history/people#andreas-m-antonopoulos",
    "title": "Andreas M. Antonopoulos",
    "section": "history",
    "body": "Contribution: Author, educator, Bitcoin evangelist Andreas M. Antonopoulos is a Greek-British author, speaker, and educator who has become one of the most influential voices in Bitcoin and blockchain "
  },
  {
    "path": "/docs/history/people#roger-ver",
    "title": "Roger Ver",
    "section": "history",
    "body": "Contribution: Early investor, \"Bitcoin Jesus,\" Bitcoin Cash advocate Roger Ver is an early Bitcoin investor and promoter who became known as \"Bitcoin Jesus\" for his advocacy and funding of "
  },
  {
    "path": "/docs/history/people#you",
    "title": "You ?",
    "section": "history",
    "body": "Contribution: The future of Bitcoin - Your story is still being written The pioneers on this page laid the groundwork, but Bitcoin's true potential will be realized by the collective efforts of its "
  },
  {
    "path": "/docs/history/halvings",
    "title": "Halvings",
    "section": "history",
    "body": "Bitcoin Halving Schedule Bitcoin's block reward halves every 210,000 blocks, which occurs approximately every 4 years. This creates a predictable, decreasing inflation rate and ensures the total supply will never exceed 21 million BTC. Supply Formula The total Bitcoin supply follows a geometric series: Total Supply = 210,000 × 50 × (1 + 1/2 + 1/4 + 1/8 + ...) = 210,000 × 50 × 2 = 21,000,000 BTC This geometric series ensures that: Each halving period creates 210,000 blocks Each period creates "
  },
  {
    "path": "/docs/history/halvings#supply-formula",
    "title": "Supply Formula",
    "section": "history",
    "body": "The total Bitcoin supply follows a geometric series: Total Supply = 210,000 × 50 × (1 + 1/2 + 1/4 + 1/8 + ...) = 210,000 × 50 × 2 = 21,000,000 BTC This geometric series ensures that: Each halving "
  },
  {
    "path": "/docs/history/halvings#complete-halving-schedule",
    "title": "Complete Halving Schedule",
    "section": "history",
    "body": "| Event | Date | Block Height | Block Reward (BTC) | Total BTC Created in Period | |-------|------|--------------|-------------------|----------------------------| | Bitcoin Launch | 3 January 2009 | "
  },
  {
    "path": "/docs/history/halvings#key-facts",
    "title": "Key Facts",
    "section": "history",
    "body": "Total Supply: Exactly 21,000,000 BTC Total Halvings: 32 halving events Halving Interval: Every 210,000 blocks (~4 years) Initial Block Reward: 50 BTC per block Current Block Reward: 3.125 BTC (after "
  },
  {
    "path": "/docs/history/halvings#after-all-coins-are-issued",
    "title": "After All Coins Are Issued",
    "section": "history",
    "body": "Once all 21 million Bitcoin have been created (around December 22, 2137): No New Bitcoin: Block rewards will be 0 Miner Income: Miners will rely entirely on transaction fees Network Security: "
  },
  {
    "path": "/docs/history/halvings#related-topics",
    "title": "Related Topics",
    "section": "history",
    "body": "Subsidy Equation - Mathematical formula and implementation details"
  },
  {
    "path": "/docs/history/forks",
    "title": "Forks",
    "section": "history",
    "body": "Forks History Bitcoin has undergone several protocol upgrades through both soft forks and hard forks. This document provides a table of all major forks in Bitcoin's history. Understanding Forks The fundamental difference between soft forks and hard forks comes down to one thing: are the consensus rules being tightened or loosened? | | Soft Fork | Hard Fork | |---|-----------|-----------| | Consensus rules | Tightened (more restrictive) | Loosened (more permissive) | | Old nodes | Accept new "
  },
  {
    "path": "/docs/history/forks#understanding-forks",
    "title": "Understanding Forks",
    "section": "history",
    "body": "The fundamental difference between soft forks and hard forks comes down to one thing: are the consensus rules being tightened or loosened? | | Soft Fork | Hard Fork | |---|-----------|-----------| | "
  },
  {
    "path": "/docs/history/forks#complete-fork-history-table",
    "title": "Complete Fork History Table",
    "section": "history",
    "body": "| Date | Block Height | Type | Name | BIP(s) | Description | Status | |------|--------------|------|------|--------|-------------|--------| | 2009-01-03 | 0 | - | Genesis Block | - | Bitcoin network "
  },
  {
    "path": "/docs/history/forks#activation-mechanisms",
    "title": "Activation Mechanisms",
    "section": "history",
    "body": "Soft Fork Activation Methods BIP 9 (Version Bits) Used for: CSV, SegWit, Taproot Requires: 95% of blocks signal support Grace period: 2016 blocks (~2 weeks) Example: Taproot activated via BIP 9 "
  },
  {
    "path": "/docs/history/forks#fork-statistics",
    "title": "Fork Statistics",
    "section": "history",
    "body": "Soft Fork Adoption | Fork | Activation Date | Current Usage | Adoption Rate | |------|----------------|--------------|---------------| | P2SH | 2012-04-01 | Multisig, complex scripts | ~15-20% of "
  },
  {
    "path": "/docs/history/forks#timeline-visualization",
    "title": "Timeline Visualization",
    "section": "history",
    "body": "2009 ────────────────────────────────────────────────────────────── │ Genesis Block │ 2010 ────────────────────────────────────────────────────────────── │ Value Overflow Fix (Hard Fork) │ 2012 "
  },
  {
    "path": "/docs/history/forks#key-takeaways",
    "title": "Key Takeaways",
    "section": "history",
    "body": "Soft Forks are Preferred: All major protocol upgrades since 2012 have been soft forks Backward Compatibility: Soft forks maintain backward compatibility with old nodes Chain Splits: Hard forks always "
  },
  {
    "path": "/docs/history/forks#potential-future-soft-forks",
    "title": "Potential Future Soft Forks",
    "section": "history",
    "body": "Covenants: Restrict how coins can be spent OP_CTV (CheckTemplateVerify): Transaction templates SIGHASH_ANYPREVOUT: More flexible signature types Ephemeral Anchors: Lightning Network improvements For "
  },
  {
    "path": "/docs/history/forks#references",
    "title": "References",
    "section": "history",
    "body": "Bitcoin BIPs Repository Bitcoin Core Release Notes Bitcoin Wiki - Forks UASF (User-Activated Soft Fork) History"
  },
  {
    "path": "/docs/history/bips",
    "title": "BIPs",
    "section": "history",
    "body": "Bitcoin Improvement Proposals (BIPs) Bitcoin Improvement Proposals are the formal mechanism for proposing changes to Bitcoin. They document design decisions, protocol upgrades, and best practices for the Bitcoin ecosystem. BIPs are modeled after Python Enhancement Proposals (PEPs) and were introduced by Amir Taaki in 2011. BIP Types | Type | Description | Examples | |------|-------------|----------| | Standards Track | Changes to the network protocol, transaction validity, or interoperability | ",
    "keywords": [
      "bip",
      "bips",
      "bitcoin improvement proposal",
      "bitcoin improvement proposals"
    ]
  },
  {
    "path": "/docs/history/bips#bip-types",
    "title": "BIP Types",
    "section": "history",
    "body": "| Type | Description | Examples | |------|-------------|----------| | Standards Track | Changes to the network protocol, transaction validity, or interoperability | BIP 141 (SegWit), BIP 341 "
  },
  {
    "path": "/docs/history/bips#consensus-protocol-bips",
    "title": "Consensus & Protocol BIPs",
    "section": "history",
    "body": "These BIPs define changes to the Bitcoin consensus rules and protocol. BIP 9 - Version Bits with Timeout and Delay Status: Final Activated: 2016 Description: Mechanism for deploying soft forks using "
  },
  {
    "path": "/docs/history/bips#wallet-key-management-bips",
    "title": "Wallet & Key Management BIPs",
    "section": "history",
    "body": "These BIPs define standards for wallets, key derivation, and seed phrases. BIP 32 - Hierarchical Deterministic Wallets Status: Final Year: 2012 Description: Defines HD wallets that generate a tree of "
  },
  {
    "path": "/docs/history/bips#address-format-bips",
    "title": "Address Format BIPs",
    "section": "history",
    "body": "These BIPs define Bitcoin address formats and encoding. BIP 13 - Address Format for pay-to-script-hash Status: Final Year: 2012 Description: Defines P2SH address format. Addresses start with 3 on "
  },
  {
    "path": "/docs/history/bips#transaction-script-bips",
    "title": "Transaction & Script BIPs",
    "section": "history",
    "body": "BIP 125 - Opt-in Full Replace-by-Fee Signaling Status: Proposed Year: 2015 Description: Allows transactions to signal replaceability. Enables fee bumping by replacing unconfirmed transactions. "
  },
  {
    "path": "/docs/history/bips#lightning-network-related-bips",
    "title": "Lightning Network Related BIPs",
    "section": "history",
    "body": "BIP 118 - SIGHASH_ANYPREVOUT for Tapscript Status: Draft Description: New sighash type that allows signatures to apply to any input with the same script. Enables Eltoo payment channels. Impact: Would "
  },
  {
    "path": "/docs/history/bips#informational-bips",
    "title": "Informational BIPs",
    "section": "history",
    "body": "BIP 1 - BIP Purpose and Guidelines Status: Active Year: 2011 Description: Defines what BIPs are and the process for creating them. BIP 2 - BIP Process, Revised Status: Active Year: 2016 Description: "
  },
  {
    "path": "/docs/history/bips#complete-bip-categories-reference",
    "title": "Complete BIP Categories Reference",
    "section": "history",
    "body": "| Category | Key BIPs | Purpose | |----------|----------|---------| | Consensus | 9, 16, 34, 65, 66, 68, 112, 113, 141, 340, 341, 342 | Protocol rules | | Wallet | 32, 39, 44, 49, 84, 86, 174, 370 | "
  },
  {
    "path": "/docs/history/bips#resources",
    "title": "Resources",
    "section": "history",
    "body": "Official BIP Repository - All BIPs on GitHub BIP 2 - BIP Process - How to create a BIP Bitcoin Wiki - BIPs - Community documentation"
  },
  {
    "path": "/docs/history/bips#related-topics",
    "title": "Related Topics",
    "section": "history",
    "body": "Forks - How BIPs become protocol changes Script System - Script-related BIPs in action"
  },
  {
    "path": "/docs/bitcoin",
    "title": "The Bitcoin Protocol",
    "section": "bitcoin",
    "body": "The Bitcoin Protocol How Bitcoin works. The Bitcoin protocol is an elegant system of interlocking mechanisms that together create the world's first truly decentralized digital currency. At its core, it solves the seemingly impossible problem of achieving consensus among untrusted parties without a central authority. Why the Protocol Matters Every line of Bitcoin's protocol was carefully designed to create a system that is: Trustless: No single entity can manipulate the rules Permissionless: "
  },
  {
    "path": "/docs/bitcoin#why-the-protocol-matters",
    "title": "Why the Protocol Matters",
    "section": "bitcoin",
    "body": "Every line of Bitcoin's protocol was carefully designed to create a system that is: Trustless: No single entity can manipulate the rules Permissionless: Anyone can participate without approval "
  },
  {
    "path": "/docs/bitcoin#core-components",
    "title": "Core Components",
    "section": "bitcoin",
    "body": "Cryptography The mathematical foundation of Bitcoin. Elliptic curve cryptography (specifically secp256k1) enables the creation of unforgeable digital signatures, while SHA-256 hash functions provide "
  },
  {
    "path": "/docs/bitcoin#network-participants",
    "title": "Network Participants",
    "section": "bitcoin",
    "body": "Nodes: Full nodes: Store complete blockchain, validate all transactions Light nodes: Store minimal data, rely on full nodes Mining nodes: Create new blocks, secure the network Miners: Verify "
  },
  {
    "path": "/docs/bitcoin#interacting-with-bitcoin",
    "title": "Interacting with Bitcoin",
    "section": "bitcoin",
    "body": "RPC Interface The RPC (Remote Procedure Call) interface is how applications communicate with a Bitcoin node. It provides commands for querying blockchain state, constructing transactions, managing "
  },
  {
    "path": "/docs/bitcoin#the-elegance-of-simplicity",
    "title": "The Elegance of Simplicity",
    "section": "bitcoin",
    "body": "What makes the Bitcoin protocol remarkable is not its complexity, but its simplicity. Each component does one thing well: Hash functions provide one-way data fingerprints Digital signatures prove "
  },
  {
    "path": "/docs/bitcoin#explore-the-protocol",
    "title": "Explore the Protocol",
    "section": "bitcoin",
    "body": "Dive into the technical details: Cryptography - Hash functions, elliptic curves, and digital signatures Consensus - How the network agrees on truth Transaction Lifecycle - Transaction states and "
  },
  {
    "path": "/docs/bitcoin/cryptography",
    "title": "Cryptography",
    "section": "bitcoin",
    "body": "Cryptography in Bitcoin Bitcoin relies on several cryptographic primitives to secure transactions, prove ownership, and maintain the integrity of the blockchain. Understanding these cryptographic foundations is essential for grasping how Bitcoin achieves trustless security. The Power of Cryptography Cryptography enables remarkable capabilities that seem almost magical: Prove knowledge without revealing it: You can prove you know a secret (like a private key) without ever exposing the secret ",
    "keywords": [
      "sha256",
      "sha-256",
      "ripemd-160",
      "ripemd160",
      "ecdsa",
      "schnorr"
    ]
  },
  {
    "path": "/docs/bitcoin/cryptography#the-power-of-cryptography",
    "title": "The Power of Cryptography",
    "section": "bitcoin",
    "body": "Cryptography enables remarkable capabilities that seem almost magical: Prove knowledge without revealing it: You can prove you know a secret (like a private key) without ever exposing the secret "
  },
  {
    "path": "/docs/bitcoin/cryptography#overview",
    "title": "Overview",
    "section": "bitcoin",
    "body": "Bitcoin uses cryptography for three main purposes: Ownership & Authentication: Proving you own bitcoin without revealing your private key Integrity: Ensuring data hasn't been tampered with "
  },
  {
    "path": "/docs/bitcoin/cryptography#hash-functions",
    "title": "Hash Functions",
    "section": "bitcoin",
    "body": "A cryptographic hash function takes any input data and produces a fixed-size output (the \"hash\" or \"digest\"). Hash functions are one-way: easy to compute, but practically impossible to reverse. "
  },
  {
    "path": "/docs/bitcoin/cryptography#merkle-trees",
    "title": "Merkle Trees",
    "section": "bitcoin",
    "body": "A Merkle tree (or hash tree) is a data structure that efficiently summarizes and verifies large datasets. Structure: Merkle Root / \\ Hash AB Hash CD / \\ / \\ Hash A Hash B Hash C Hash D | | | | Tx A "
  },
  {
    "path": "/docs/bitcoin/cryptography#elliptic-curve-cryptography",
    "title": "Elliptic Curve Cryptography",
    "section": "bitcoin",
    "body": "Elliptic Curve Elliptic Curve Cryptography (ECC) is a public-key cryptography system based on the algebraic structure of elliptic curves over finite fields. Why Bitcoin uses ECC: Smaller key sizes "
  },
  {
    "path": "/docs/bitcoin/cryptography#digital-signatures",
    "title": "Digital Signatures",
    "section": "bitcoin",
    "body": "A digital signature proves: Authenticity: Message came from the claimed sender Integrity: Message hasn't been altered Non-repudiation: Sender cannot deny sending Signature types in Bitcoin: ECDSA: "
  },
  {
    "path": "/docs/bitcoin/cryptography#ecdsa",
    "title": "ECDSA",
    "section": "bitcoin",
    "body": "ECDSA (Elliptic Curve Digital Signature Algorithm) was Bitcoin's original signature scheme. Bitcoin used it for all signatures until Taproot introduced Schnorr. Signing Process: Hash the message: z = "
  },
  {
    "path": "/docs/bitcoin/cryptography#schnorr-signatures",
    "title": "Schnorr Signatures",
    "section": "bitcoin",
    "body": "Schnorr signatures (BIP 340) are Bitcoin's signature scheme for Taproot (P2TR) outputs, activated in November 2021 (block 709,632). Pieter Wuille was a key designer of BIP 340. Why Schnorr in "
  },
  {
    "path": "/docs/bitcoin/cryptography#address-encoding",
    "title": "Address Encoding",
    "section": "bitcoin",
    "body": "Base58Check Base58 encoding uses 58 characters (excluding 0, O, I, l to avoid confusion): 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz Base58Check adds a checksum: Add version byte "
  },
  {
    "path": "/docs/bitcoin/cryptography#cryptographic-security-assumptions",
    "title": "Cryptographic Security Assumptions",
    "section": "bitcoin",
    "body": "What Bitcoin Assumes Bitcoin's security relies on these assumptions holding true: | Assumption | If Broken | |------------|-----------| | SHA-256 is collision-resistant | Could create invalid blocks "
  },
  {
    "path": "/docs/bitcoin/cryptography#summary",
    "title": "Summary",
    "section": "bitcoin",
    "body": "| Cryptographic Primitive | Purpose in Bitcoin | |------------------------|-------------------| | SHA-256 | Block hashing, TXIDs, PoW | | SHA-256d (double) | Block headers, Merkle trees | | "
  },
  {
    "path": "/docs/bitcoin/cryptography#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "Interactive Tools - Stack Lab for script, Block Visualizer for blocks, Hash tool for SHA-256 / HASH256 / HASH160 Bitcoin Developer Guide - Transactions - Official documentation on transaction signing "
  },
  {
    "path": "/docs/bitcoin/consensus",
    "title": "Consensus Mechanism",
    "section": "bitcoin",
    "body": "Consensus Mechanism Bitcoin uses a consensus mechanism to achieve agreement among network participants about which transactions are valid and in what order they occurred. This consensus is reached without a central authority through a combination of cryptographic proof and economic incentives. The specific mechanism Bitcoin uses is formally known as Nakamoto Consensus, named after its pseudonymous creator. The Significance of Consensus The Byzantine Generals Problem Before Bitcoin, achieving "
  },
  {
    "path": "/docs/bitcoin/consensus#the-significance-of-consensus",
    "title": "The Significance of Consensus",
    "section": "bitcoin",
    "body": "The Byzantine Generals Problem Before Bitcoin, achieving consensus in a distributed network with potentially hostile actors was an unsolved problem in computer science. The Byzantine Generals Problem "
  },
  {
    "path": "/docs/bitcoin/consensus#what-nodes-agree-on",
    "title": "What Nodes Agree On",
    "section": "bitcoin",
    "body": "Consensus means all honest participants agree on: Which transactions are valid and their ordering The current state of the blockchain (who owns what) Which blocks form the canonical chain Receive "
  },
  {
    "path": "/docs/bitcoin/consensus#how-bitcoin-achieves-consensus",
    "title": "How Bitcoin Achieves Consensus",
    "section": "bitcoin",
    "body": "Proof-of-Work: Digital Gold Mining The concept of proof-of-work predates Bitcoin. In 1997, Adam Back invented Hashcash, a proof-of-work system designed to combat email spam. The sender had to perform "
  },
  {
    "path": "/docs/bitcoin/consensus#consensus-rules",
    "title": "Consensus Rules",
    "section": "bitcoin",
    "body": "Nodes validate three layers: transactions (valid signatures, unspent inputs, no double-spends), blocks (correct structure, valid PoW, all transactions valid), and chains (blocks link correctly, "
  },
  {
    "path": "/docs/bitcoin/consensus#achieving-consensus",
    "title": "Achieving Consensus",
    "section": "bitcoin",
    "body": "The Longest Chain Rule The chain with the most cumulative proof-of-work is considered valid. This simple rule ensures consensus emerges naturally: honest miners extend the longest chain because it's "
  },
  {
    "path": "/docs/bitcoin/consensus#security-through-consensus",
    "title": "Security Through Consensus",
    "section": "bitcoin",
    "body": "51% Attack A 51% attack occurs when an entity controls more than half the network's hash rate, enabling them to create a longer chain than honest miners and potentially reverse transactions. However, "
  },
  {
    "path": "/docs/bitcoin/consensus#consensus-properties",
    "title": "Consensus Properties",
    "section": "bitcoin",
    "body": "| Property | Definition | Bitcoin's Implementation | |----------|------------|-------------------------| | Finality | Transactions cannot be reversed | Probabilistic: 6+ confirmations is economically "
  },
  {
    "path": "/docs/bitcoin/consensus#consensus-challenges",
    "title": "Consensus Challenges",
    "section": "bitcoin",
    "body": "Network Partitions & Temporary Forks | Scenario | Cause | Resolution | |----------|-------|------------| | Network partition | Internet splits network into groups | Longest chain wins when "
  },
  {
    "path": "/docs/bitcoin/consensus#comparison-with-other-mechanisms",
    "title": "Comparison with Other Mechanisms",
    "section": "bitcoin",
    "body": "| Aspect | Proof-of-Work (Bitcoin) | Proof-of-Stake | |--------|------------------------|----------------| | Security basis | Computational work (energy) | Staked capital | | Attack cost | Hardware + "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle",
    "title": "Transaction Lifecycle",
    "section": "bitcoin",
    "body": "Transaction Lifecycle Understanding the complete lifecycle of a Bitcoin transaction helps developers build robust applications and users understand what happens when they send bitcoin. Transaction Structure A Bitcoin transaction consists of: Version: Identifies consensus rules Inputs: References to previous transaction outputs (UTXOs) Outputs: Creates new UTXOs with spending conditions Locktime: Optional time-based spending restriction Witness Data (SegWit): Signature data separated from "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#transaction-structure",
    "title": "Transaction Structure",
    "section": "bitcoin",
    "body": "A Bitcoin transaction consists of: Version: Identifies consensus rules Inputs: References to previous transaction outputs (UTXOs) Outputs: Creates new UTXOs with spending conditions Locktime: "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#transaction-states",
    "title": "Transaction States",
    "section": "bitcoin",
    "body": "A transaction goes through several states: [Created] --> [Signed] --> [Broadcast] --> [Mempool] --> [Pending] --> [Confirmed] --> [Deeply Confirmed] | State | Description | |-------|--------------| | "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Tracking Transaction Status :::code-group use serde_json::json; use reqwest; #[derive(Debug)] enum TxStatus { NotFound, InMempool, Confirmed(u32), // Number of confirmations } async fn "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#reorganizations-reorgs",
    "title": "Reorganizations (Reorgs)",
    "section": "bitcoin",
    "body": "A reorganization occurs when the blockchain splits and a different chain becomes the longest: Original Chain: Block 100 → Block 101 → Block 102 Reorg: Block 100 → Block 101A → Block 102A (longer "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#orphan-transactions",
    "title": "Orphan Transactions",
    "section": "bitcoin",
    "body": "Definition Orphan transactions are transactions that reference outputs that don't exist or are invalid: Orphan Transaction: References UTXO that doesn't exist Or references unconfirmed parent Cannot "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#best-practices-for-developers",
    "title": "Best Practices for Developers",
    "section": "bitcoin",
    "body": "Wait for confirmations: Don't trust 0-conf for high value Handle reorgs: Transactions can be unconfirmed again Monitor status: Track transaction through lifecycle Use RBF: Allow fee bumping for stuck "
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Mempool - Where transactions wait Block Visualizer - See transactions flowing into blocks Transaction Fees - Fee calculation Block Propagation - How blocks spread"
  },
  {
    "path": "/docs/bitcoin/transaction-lifecycle#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "mempool.space - Transaction status tracking"
  },
  {
    "path": "/docs/bitcoin/transaction-structure",
    "title": "Transaction Structure",
    "section": "bitcoin",
    "body": "Transaction Structure A Bitcoin transaction is a serialized structure with a version, a list of inputs, a list of outputs, a locktime, and (for SegWit/Taproot) witness data. This page summarizes the main fields so you can read raw transactions or build them correctly. Input fields Each input references one UTXO and provides data to satisfy its spending conditions. | Field | Description | |-------|-------------| | Previous output (outpoint) | The transaction ID (txid) of the transaction that "
  },
  {
    "path": "/docs/bitcoin/transaction-structure#input-fields",
    "title": "Input fields",
    "section": "bitcoin",
    "body": "Each input references one UTXO and provides data to satisfy its spending conditions. | Field | Description | |-------|-------------| | Previous output (outpoint) | The transaction ID (txid) of the "
  },
  {
    "path": "/docs/bitcoin/transaction-structure#output-fields",
    "title": "Output fields",
    "section": "bitcoin",
    "body": "Each output creates a new UTXO: an amount and a scriptPubKey (locking script) that defines who can spend it. | Field | Description | |-------|-------------| | Value | Amount in satoshis. | | "
  },
  {
    "path": "/docs/bitcoin/transaction-structure#serialization-notes",
    "title": "Serialization notes",
    "section": "bitcoin",
    "body": "Numeric fields (version, locktime, sequence, value) are little-endian. Variable-length data (script length, script content) use compact size encoding. SegWit transactions have a marker and flag in "
  },
  {
    "path": "/docs/bitcoin/transaction-structure#related",
    "title": "Related",
    "section": "bitcoin",
    "body": "Transaction Decoder — decode raw transaction hex in the browser Transaction Lifecycle for states from creation to confirmation Transaction Construction for building transactions in code Script for "
  },
  {
    "path": "/docs/bitcoin/script",
    "title": "Bitcoin Script",
    "section": "bitcoin",
    "body": "Bitcoin Script Bitcoin Script is a programming language that defines how bitcoin can be spent. Every transaction output contains a locking script that sets the spending conditions. To spend that output, you must provide an unlocking script that satisfies those conditions. | Term | Also Called | Purpose | |------|-------------|---------| | Locking Script | scriptPubKey, output script | Defines who can spend and under what conditions | | Unlocking Script | scriptSig, input script, witness | ",
    "keywords": [
      "script",
      "bitcoin script",
      "opcode",
      "op codes",
      "opcodes",
      "locking script",
      "unlocking script"
    ]
  },
  {
    "path": "/docs/bitcoin/script#how-does-it-work",
    "title": "How Does It Work?",
    "section": "bitcoin",
    "body": "When you spend bitcoin, the network executes both scripts together: Unlocking script runs first (pushes signatures, keys, or other data onto the stack) Locking script runs second (verifies the data "
  },
  {
    "path": "/docs/bitcoin/script#when-do-scripts-execute",
    "title": "When Do Scripts Execute?",
    "section": "bitcoin",
    "body": "Scripts execute when spending, not when receiving. The locking script is stored with the output when bitcoin is sent. It only runs when someone later tries to spend that output."
  },
  {
    "path": "/docs/bitcoin/script#script-types",
    "title": "Script Types",
    "section": "bitcoin",
    "body": "Bitcoin Script has evolved over time, introducing new output types (address formats) that improve security, privacy, and efficiency. Each script type represents a different way to lock and unlock "
  },
  {
    "path": "/docs/bitcoin/script#script-execution-examples",
    "title": "Script Execution Examples",
    "section": "bitcoin",
    "body": "Each script type has its own execution flow. The unlocking script runs first, then the locking script. P2PK (Pay-to-Pubkey) The simplest script: locks directly to a public key. | Component | Script | "
  },
  {
    "path": "/docs/bitcoin/script#locking-mechanisms",
    "title": "Locking Mechanisms",
    "section": "bitcoin",
    "body": "Bitcoin Script supports various ways to lock funds with different spending conditions. | Lock Type | Opcode | Use Cases | Script Pattern | |-----------|--------|-----------|----------------| | Time "
  },
  {
    "path": "/docs/bitcoin/op-codes",
    "title": "OP Codes",
    "section": "bitcoin",
    "body": "OP Codes The instruction set for Bitcoin. Bitcoin Script uses a stack-based programming language with various opcodes (operation codes) that perform different functions. This document provides a complete reference of Bitcoin OP codes with explanations and code examples. Try these opcodes in Stack Lab. OP Code Categories | Category | Description | Examples | |----------|-------------|----------| | Stack Operations | Manipulate the stack | OP_DUP, OP_DROP, OP_SWAP | | Arithmetic | Mathematical ",
    "keywords": [
      "opcode",
      "op codes",
      "opcodes"
    ]
  },
  {
    "path": "/docs/bitcoin/op-codes#op-code-categories",
    "title": "OP Code Categories",
    "section": "bitcoin",
    "body": "| Category | Description | Examples | |----------|-------------|----------| | Stack Operations | Manipulate the stack | OP_DUP, OP_DROP, OP_SWAP | | Arithmetic | Mathematical operations | OP_ADD, "
  },
  {
    "path": "/docs/bitcoin/op-codes#script-execution-example",
    "title": "Script Execution Example",
    "section": "bitcoin",
    "body": ":::code-group use std::collections::VecDeque; #[derive(Debug, Clone)] enum StackItem { Bytes(Vec), Int(i64), } struct ScriptInterpreter { stack: VecDeque, } impl ScriptInterpreter { fn new() -> Self "
  },
  {
    "path": "/docs/bitcoin/op-codes#stack-operations",
    "title": "Stack Operations",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | |---------|-----|----------| | OP_DUP | 0x76 | Duplicates top stack item | | OP_DROP | 0x75 | Removes top stack item | | OP_SWAP | 0x7c | Swaps top two items | | OP_OVER "
  },
  {
    "path": "/docs/bitcoin/op-codes#arithmetic-operations",
    "title": "Arithmetic Operations",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | Status | |---------|-----|----------|--------| | OP_ADD | 0x93 | a + b | Active | | OP_SUB | 0x94 | a - b | Active | | OP_1ADD | 0x8b | a + 1 | Active | | OP_1SUB | 0x8c "
  },
  {
    "path": "/docs/bitcoin/op-codes#comparison-operations",
    "title": "Comparison Operations",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | |---------|-----|----------| | OP_EQUAL | 0x87 | Returns 1 if equal, else 0 | | OP_EQUALVERIFY | 0x88 | OP_EQUAL + OP_VERIFY | | OP_LESSTHAN | 0x9f | a b | | "
  },
  {
    "path": "/docs/bitcoin/op-codes#cryptographic-operations",
    "title": "Cryptographic Operations",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | |---------|-----|----------| | OP_RIPEMD160 | 0xa6 | RIPEMD-160 hash | | OP_SHA1 | 0xa7 | SHA-1 hash | | OP_SHA256 | 0xa8 | SHA-256 hash | | OP_HASH160 | 0xa9 | SHA256 + "
  },
  {
    "path": "/docs/bitcoin/op-codes#bitwise-operations-disabled",
    "title": "Bitwise Operations (Disabled)",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | Status | |---------|-----|----------|--------| | OP_AND | 0x84 | Bitwise AND | Disabled | | OP_OR | 0x85 | Bitwise OR | Disabled | | OP_XOR | 0x86 | Bitwise XOR | "
  },
  {
    "path": "/docs/bitcoin/op-codes#control-flow",
    "title": "Control Flow",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | |---------|-----|----------| | OP_IF | 0x63 | Execute if top is non-zero | | OP_NOTIF | 0x64 | Execute if top is zero | | OP_ELSE | 0x67 | Else branch | | OP_ENDIF | 0x68 "
  },
  {
    "path": "/docs/bitcoin/op-codes#time-lock-operations",
    "title": "Time Lock Operations",
    "section": "bitcoin",
    "body": "OP_CHECKLOCKTIMEVERIFY (CLTV) Code: 0xb1 Verifies the transaction's nLockTime is at least the specified value (absolute time lock). OP_CHECKLOCKTIMEVERIFY OP_DROP OP_CHECKSIG Use cases: Payment "
  },
  {
    "path": "/docs/bitcoin/op-codes#push-operations",
    "title": "Push Operations",
    "section": "bitcoin",
    "body": "| OP Code | Hex | Function | |---------|-----|----------| | OP_0 / OP_FALSE | 0x00 | Push empty array (false) | | OP_1NEGATE | 0x4f | Push -1 | | OP_1 / OP_TRUE | 0x51 | Push 1 | | OP_2 - OP_16 | "
  },
  {
    "path": "/docs/bitcoin/op-codes#tapscript-opcodes-bip-342",
    "title": "Tapscript Opcodes (BIP 342)",
    "section": "bitcoin",
    "body": "Taproot introduced new opcodes for Tapscript: OP_CHECKSIGADD Code: 0xba Enables efficient Schnorr signature aggregation for multisig. OP_CHECKSIG OP_CHECKSIGADD OP_CHECKSIGADD OP_NUMEQUAL Benefits "
  },
  {
    "path": "/docs/bitcoin/op-codes#disabled-opcodes",
    "title": "Disabled Opcodes",
    "section": "bitcoin",
    "body": "These opcodes were disabled for security reasons: | OP Code | Hex | Reason | |---------|-----|--------| | OP_CAT | 0x7e | Could create oversized scripts | | OP_SUBSTR | 0x7f | Security concerns | | "
  },
  {
    "path": "/docs/bitcoin/op-codes#common-script-patterns",
    "title": "Common Script Patterns",
    "section": "bitcoin",
    "body": "P2PKH (Pay-to-Pubkey-Hash) Locking Script (scriptPubKey): OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG Unlocking Script (scriptSig): P2SH (Pay-to-Script-Hash) Locking Script: OP_HASH160 OP_EQUAL "
  },
  {
    "path": "/docs/bitcoin/op-codes#script-limits",
    "title": "Script Limits",
    "section": "bitcoin",
    "body": "| Limit | Value | Purpose | |-------|-------|---------| | Max script size | 10,000 bytes | Prevent oversized scripts | | Max stack size | 1,000 items | Prevent stack overflow | | Max item size | 520 "
  },
  {
    "path": "/docs/bitcoin/op-codes#op-code-quick-reference",
    "title": "OP Code Quick Reference",
    "section": "bitcoin",
    "body": "| Hex | Name | Description | Status | |-----|------|-------------|--------| | 0x00 | OP_0 | Push empty array | Active | | 0x4f | OP_1NEGATE | Push -1 | Active | | 0x51-0x60 | OP_1-OP_16 | Push 1-16 | "
  },
  {
    "path": "/docs/bitcoin/op-codes#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Script System: How Bitcoin Script works OP_RETURN Debate: Controversy about data storage Taproot - Schnorr signatures and Tapscript"
  },
  {
    "path": "/docs/bitcoin/op-codes#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "Bitcoin Wiki: Script: Complete script reference BIP 342: Tapscript: Tapscript specification Learn Me a Bitcoin: Script: Visual script explanations"
  },
  {
    "path": "/docs/bitcoin/timelocks",
    "title": "Timelocks",
    "section": "bitcoin",
    "body": "Timelocks Timelocks prevent Bitcoin from being spent until certain time conditions are met. Bitcoin supports two types of timelocks: absolute (CLTV) and relative (CSV). Types of Timelocks Absolute Timelocks (CLTV) CheckLockTimeVerify (CLTV) prevents spending until a specific block height or Unix timestamp: Example: \"Can't spend until block 800,000\" \"Can't spend until January 1, 2025\" Relative Timelocks (CSV) CheckSequenceVerify (CSV) prevents spending until a certain time has passed since the "
  },
  {
    "path": "/docs/bitcoin/timelocks#types-of-timelocks",
    "title": "Types of Timelocks",
    "section": "bitcoin",
    "body": "Absolute Timelocks (CLTV) CheckLockTimeVerify (CLTV) prevents spending until a specific block height or Unix timestamp: Example: \"Can't spend until block 800,000\" \"Can't spend until January 1, 2025\" "
  },
  {
    "path": "/docs/bitcoin/timelocks#use-cases",
    "title": "Use Cases",
    "section": "bitcoin",
    "body": "Escrow Hold funds until a dispute period expires: Escrow Contract: Funds locked with timelock Dispute period: 30 days After 30 days, funds can be released Inheritance Time-delayed access to funds: "
  },
  {
    "path": "/docs/bitcoin/timelocks#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Creating CLTV Timelock :::code-group use bitcoin::{Script, ScriptBuf}; use bitcoin::opcodes::all::*; use bitcoin::locktime::absolute::LockTime; fn create_cltv_script(locktime: LockTime, pubkey_hash: "
  },
  {
    "path": "/docs/bitcoin/timelocks#transaction-level-timelocks",
    "title": "Transaction-Level Timelocks",
    "section": "bitcoin",
    "body": "nLockTime Transaction-level absolute timelock: [Transaction] ├── nLockTime: Block height or timestamp └── nSequence: Must be < 0xFFFFFFFF for nLockTime to work nSequence Transaction-level relative "
  },
  {
    "path": "/docs/bitcoin/timelocks#technical-details",
    "title": "Technical Details",
    "section": "bitcoin",
    "body": "CLTV (BIP 65) Activated: December 2015 (block 388,381) Opcode: OP_CHECKLOCKTIMEVERIFY (0xb1) Checks: Transaction's nLockTime field Values: Block height (< 500,000,000) or Unix timestamp (≥ "
  },
  {
    "path": "/docs/bitcoin/timelocks#lightning-network-usage",
    "title": "Lightning Network Usage",
    "section": "bitcoin",
    "body": "HTLC Timelocks Lightning uses timelocks for HTLCs: [HTLC Structure] ├── Hash lock: Reveal preimage └── Time lock: Refund if not claimed Timelock ensures: Payments don't get stuck forever Refunds are "
  },
  {
    "path": "/docs/bitcoin/timelocks#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Bitcoin Script - Script system overview OP Codes - Script opcodes Lightning Network - Uses timelocks extensively Smart Contracts - Advanced timelock patterns"
  },
  {
    "path": "/docs/bitcoin/timelocks#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "BIP 65: OP_CHECKLOCKTIMEVERIFY BIP 112: OP_CHECKSEQUENCEVERIFY BIP 68: Relative Lock-time"
  },
  {
    "path": "/docs/bitcoin/sighash-types",
    "title": "Sighash Types",
    "section": "bitcoin",
    "body": "Sighash Types When you sign a Bitcoin transaction, the signature does not cover the raw transaction bytes. Instead, the signer first builds a signature hash (sighash): a structured digest of parts of the transaction. The sighash type (a byte appended to the signature or encoded in it) selects which parts are included. This controls what the signer commits to and what can be changed without invalidating the signature. Understanding sighash types is important for transaction construction, smart "
  },
  {
    "path": "/docs/bitcoin/sighash-types#the-sighash-signature-hash",
    "title": "The Sighash (Signature Hash)",
    "section": "bitcoin",
    "body": "For each input, the signer: Builds a sighash from the transaction according to the sighash type. Signs the sighash with the private key. The signature (plus the sighash type byte) is placed in the "
  },
  {
    "path": "/docs/bitcoin/sighash-types#sighash-type-byte",
    "title": "Sighash Type Byte",
    "section": "bitcoin",
    "body": "The sighash type is one byte. Its bits mean: Low 3 bits (mask 0x1f): base type Bit 0x80 (SIGHASH_ANYONECANPAY): if set, only the current input is included in the sighash; other inputs are not "
  },
  {
    "path": "/docs/bitcoin/sighash-types#standard-sighash-types",
    "title": "Standard Sighash Types",
    "section": "bitcoin",
    "body": "SIGHASH_ALL (0x01) Default and most common. The sighash includes: Version, locktime All inputs (or only the current one if ANYONECANPAY is set): outpoint, script (or scriptCode for SegWit), sequence "
  },
  {
    "path": "/docs/bitcoin/sighash-types#sighash-default-0x00-and-taproot",
    "title": "SIGHASH_DEFAULT (0x00) and Taproot",
    "section": "bitcoin",
    "body": "For Taproot (and commonly for SegWit v0), the value 0x00 is used to mean default behavior: it is interpreted as SIGHASH_ALL (commit to all inputs and outputs). The extra byte is omitted in the "
  },
  {
    "path": "/docs/bitcoin/sighash-types#summary-table",
    "title": "Summary Table",
    "section": "bitcoin",
    "body": "| Type | Name | Inputs in sighash | Outputs in sighash | |------|------|-------------------|--------------------| | 0x01 | SIGHASH_ALL | All (or current with 0x80) | All | | 0x02 | SIGHASH_NONE | All "
  },
  {
    "path": "/docs/bitcoin/sighash-types#use-cases",
    "title": "Use Cases",
    "section": "bitcoin",
    "body": "Normal payments: SIGHASH_ALL or SIGHASH_DEFAULT. Full commitment to the transaction. RBF: Same; the replacement is a new transaction with new signatures. Sighash types do not change. CoinJoin: "
  },
  {
    "path": "/docs/bitcoin/sighash-types#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Cryptography - Signing and the structure of the signed message Transaction Lifecycle - States of a transaction Transaction Fees - RBF and fee bumping Covenants - SIGHASH_ANYPREVOUT and covenant "
  },
  {
    "path": "/docs/bitcoin/sighash-types#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "BIP 143: Transaction Signature Verification for Version 0 Witness Program - SegWit sighash BIP 341: Taproot - Taproot and Tapscript sighash Bitcoin Core: Sighash - Implementation"
  },
  {
    "path": "/docs/bitcoin/merkle-trees",
    "title": "Merkle Trees",
    "section": "bitcoin",
    "body": "Merkle Trees Merkle trees are a fundamental data structure in Bitcoin that enable efficient verification of transaction inclusion in blocks. They provide cryptographic proof that specific transactions are part of a block without downloading the entire block. The structure is named after Ralph Merkle, who invented it in 1979; Satoshi cited the concept in the Bitcoin whitepaper. Merkle Tree Structure A Merkle tree (also called a hash tree) is a binary tree where: Leaves: Hash of individual "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#how-it-works",
    "title": "How It Works",
    "section": "bitcoin",
    "body": "Construction Hash each transaction: Create leaf nodes Pair and hash: Combine pairs, hash result Repeat: Continue until single root hash Store root: Root hash goes in block header Hash each "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Building a Merkle Tree :::code-group use sha2::{Sha256, Digest}; fn merkle_root(transactions: &Vec]) -> [u8; 32] { if transactions.is_empty() { return [0; 32]; } let mut hashes: Vec = transactions "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#spv-simplified-payment-verification",
    "title": "SPV (Simplified Payment Verification)",
    "section": "bitcoin",
    "body": "Merkle trees enable SPV clients: SPV Client: Downloads block headers only (~80 bytes each) Requests Merkle proof for specific transaction Verifies proof without full block Confirms transaction "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#block-header",
    "title": "Block Header",
    "section": "bitcoin",
    "body": "Merkle root is stored in block header: [Block Header 80 bytes] ├── Version (4 bytes) ├── Previous Block Hash (32 bytes) ├── Merkle Root (32 bytes) - Merkle tree root ├── Timestamp (4 bytes) ├── "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#benefits",
    "title": "Benefits",
    "section": "bitcoin",
    "body": "Efficiency Compact proofs: Small Merkle paths vs. full blocks Fast verification: Logarithmic complexity Bandwidth savings: SPV clients need minimal data Security Cryptographic integrity: Any change "
  },
  {
    "path": "/docs/bitcoin/merkle-trees#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Block Structure - How blocks are organized SPV - Simplified payment verification Cryptography - Hash functions"
  },
  {
    "path": "/docs/bitcoin/merkle-trees#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "Merkle Tree Wikipedia Bitcoin Merkle Trees"
  },
  {
    "path": "/docs/bitcoin/blocks",
    "title": "Block Propagation",
    "section": "bitcoin",
    "body": "Block Propagation This document explains how blocks propagate through the Bitcoin network, including the gossip protocol, validation process, and orphan block handling. Block Structure Bitcoin Block Structure A Bitcoin block consists of: Block Header (80 bytes): Contains version, previous block hash, merkle root, timestamp, difficulty target, and nonce Transaction Count: Variable-length integer indicating number of transactions Transactions: List of transactions, starting with the coinbase "
  },
  {
    "path": "/docs/bitcoin/blocks#block-structure",
    "title": "Block Structure",
    "section": "bitcoin",
    "body": "Bitcoin Block Structure A Bitcoin block consists of: Block Header (80 bytes): Contains version, previous block hash, merkle root, timestamp, difficulty target, and nonce Transaction Count: "
  },
  {
    "path": "/docs/bitcoin/blocks#block-propagation-flow",
    "title": "Block Propagation Flow",
    "section": "bitcoin",
    "body": "1. Block Discovery and Initial Broadcast When a miner finds a new block: Miner solves proof-of-work puzzle: Finds a valid nonce Creates valid block: Includes transactions from mempool Immediately "
  },
  {
    "path": "/docs/bitcoin/blocks#compact-block-relay-bip-152",
    "title": "Compact Block Relay (BIP 152)",
    "section": "bitcoin",
    "body": "Compact blocks dramatically reduce propagation bandwidth and latency: How It Works Instead of sending full blocks (~1-2 MB), nodes send: Block header (80 bytes) Short transaction IDs (6 bytes each) "
  },
  {
    "path": "/docs/bitcoin/blocks#headers-first-synchronization",
    "title": "Headers-First Synchronization",
    "section": "bitcoin",
    "body": "New nodes use headers-first sync for efficient IBD (Initial Block Download): Download all block headers first (~60 MB total) Validate the header chain (proof-of-work, timestamps) Download full blocks "
  },
  {
    "path": "/docs/bitcoin/blocks#erlay-protocol",
    "title": "Erlay Protocol",
    "section": "bitcoin",
    "body": "Erlay (BIP 330) improves transaction relay efficiency: Set reconciliation: Nodes exchange transaction set differences instead of full announcements 40% bandwidth reduction: For transaction relay "
  },
  {
    "path": "/docs/bitcoin/blocks#monitoring-block-propagation",
    "title": "Monitoring Block Propagation",
    "section": "bitcoin",
    "body": "Subscribe to New Blocks via ZMQ :::code-group use zmq; use std::error::Error; fn subscribe_to_blocks() -> Result> { let context = zmq::Context::new(); let subscriber = context.socket(zmq::SUB)?; // "
  },
  {
    "path": "/docs/bitcoin/blocks#orphan-block-scenarios",
    "title": "Orphan Block Scenarios",
    "section": "bitcoin",
    "body": "Simultaneous Block Discovery Sometimes two miners find blocks at nearly the same time, creating a temporary fork: Block 850,000 (everyone agrees) | +-------------+-------------+ | | | Block A Block B "
  },
  {
    "path": "/docs/bitcoin/blocks#propagation-timing",
    "title": "Propagation Timing",
    "section": "bitcoin",
    "body": "Typical Network Performance | Stage | Time | Description | |-------|------|-------------| | Block found | 0:00 | Miner discovers valid hash | | First hop | ~1s | Direct peers receive block | | Second "
  },
  {
    "path": "/docs/bitcoin/blocks#network-topology",
    "title": "Network Topology",
    "section": "bitcoin",
    "body": "Typical Node Connections A typical Bitcoin node has: 8-10 outbound connections: You connect TO other nodes Up to 125 inbound connections: Other nodes connect TO you Diverse IP ranges: Protection "
  },
  {
    "path": "/docs/bitcoin/blocks#security-considerations",
    "title": "Security Considerations",
    "section": "bitcoin",
    "body": "Why Validation is Critical Every node validates every block because: No central authority to trust Prevents invalid blocks from spreading Ensures consensus rules are followed Protects against "
  },
  {
    "path": "/docs/bitcoin/blocks#key-metrics",
    "title": "Key Metrics",
    "section": "bitcoin",
    "body": "| Metric | Target | Description | |--------|--------|-------------| | Block interval | ~10 min | Time between consecutive blocks | | Propagation delay | <10s | Time from discovery to your node | | "
  },
  {
    "path": "/docs/bitcoin/blocks#summary",
    "title": "Summary",
    "section": "bitcoin",
    "body": "Bitcoin's block propagation mechanism is designed to be: Decentralized: No single point of failure Resilient: Multiple paths for block propagation Secure: Every node validates every block Efficient: "
  },
  {
    "path": "/docs/bitcoin/blocks#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "mempool.space: Real-time block explorer and mempool visualization BIP 152: Compact Block Relay: Compact blocks specification Bitcoin Core P2P documentation: Network protocol details"
  },
  {
    "path": "/docs/bitcoin/coinbase-transaction",
    "title": "Coinbase Transaction",
    "section": "bitcoin",
    "body": "Coinbase Transaction The coinbase transaction is the first transaction in every block. It has no inputs and creates new bitcoin as the block reward (subsidy plus fees). Miners construct it to pay themselves; it is the only transaction type that can create new coins. Structure Inputs: No previous outpoint. Normal inputs reference a (txid, vout); the coinbase input has no such reference. Coinbase data: Arbitrary data, up to 100 bytes. BIP 34 requires that block height be encoded here. Miners "
  },
  {
    "path": "/docs/bitcoin/coinbase-transaction#structure",
    "title": "Structure",
    "section": "bitcoin",
    "body": "Inputs: No previous outpoint. Normal inputs reference a (txid, vout); the coinbase input has no such reference. Coinbase data: Arbitrary data, up to 100 bytes. BIP 34 requires that block height be "
  },
  {
    "path": "/docs/bitcoin/coinbase-transaction#uniqueness",
    "title": "Uniqueness",
    "section": "bitcoin",
    "body": "Each coinbase transaction is unique because the coinbase data (and thus the input) differs per block. That gives miners a large search space: they can change the coinbase when exhausting the nonce in "
  },
  {
    "path": "/docs/bitcoin/coinbase-transaction#maturity",
    "title": "Maturity",
    "section": "bitcoin",
    "body": "Coinbase outputs cannot be spent until 100 blocks have passed. This prevents problems if the block is later orphaned; the network would reject a spend from an output that no longer exists in the best "
  },
  {
    "path": "/docs/bitcoin/coinbase-transaction#related",
    "title": "Related",
    "section": "bitcoin",
    "body": "Block Subsidy for the subsidy formula and halving schedule Block Construction for how miners build blocks and the coinbase Blocks for block propagation and structure"
  },
  {
    "path": "/docs/bitcoin/subsidy",
    "title": "Block Subsidy",
    "section": "bitcoin",
    "body": "Block Subsidy The Bitcoin block subsidy is the amount of new Bitcoin created with each block. It follows a predictable mathematical formula that halves every 210,000 blocks, creating Bitcoin's fixed supply schedule. Block Reward The block reward is what the miner receives for mining a valid block: the block subsidy (new bitcoin created) plus the transaction fees from all transactions included in the block. Over time, the subsidy shrinks (halving every 210,000 blocks) and fees will make up a "
  },
  {
    "path": "/docs/bitcoin/subsidy#block-reward",
    "title": "Block Reward",
    "section": "bitcoin",
    "body": "The block reward is what the miner receives for mining a valid block: the block subsidy (new bitcoin created) plus the transaction fees from all transactions included in the block. Over time, the "
  },
  {
    "path": "/docs/bitcoin/subsidy#the-equation",
    "title": "The Equation",
    "section": "bitcoin",
    "body": "Mathematical Formula Block Subsidy = 50 / (2^halvings) Where: halvings = floor(block_height / 210,000) Bitcoin Core Implementation In Bitcoin Core (validation.cpp), the subsidy is calculated using "
  },
  {
    "path": "/docs/bitcoin/subsidy#halving-schedule",
    "title": "Halving Schedule",
    "section": "bitcoin",
    "body": "| Halving | Block Height | Date | Subsidy | Total Mined | |---------|--------------|------|---------|-------------| | 0 (Genesis) | 0 | Jan 2009 | 50 BTC | 0 | | 1 | 210,000 | Nov 2012 | 25 BTC | "
  },
  {
    "path": "/docs/bitcoin/subsidy#total-supply",
    "title": "Total Supply",
    "section": "bitcoin",
    "body": "The total Bitcoin supply follows a geometric series that converges to exactly 21 million BTC: Total Supply = 210,000 blocks × 50 BTC × (1 + 1/2 + 1/4 + 1/8 + ...) = 210,000 × 50 × 2 = 21,000,000 BTC "
  },
  {
    "path": "/docs/bitcoin/subsidy#utility-functions",
    "title": "Utility Functions",
    "section": "bitcoin",
    "body": "Calculate Total Supply Up to Block :::code-group fn total_supply_up_to_block(block_height: u64) -> f64 { let mut total = 0.0; let mut current = 0u64; while current = 64 { break; } let period_end = "
  },
  {
    "path": "/docs/bitcoin/subsidy#block-reward-components",
    "title": "Block Reward Components",
    "section": "bitcoin",
    "body": "The total block reward consists of two parts: Total Block Reward = Block Subsidy + Transaction Fees | Era | Subsidy | Typical Fees | Fee % | |-----|---------|--------------|-------| | 2009-2012 | 50 "
  },
  {
    "path": "/docs/bitcoin/subsidy#inflation-rate",
    "title": "Inflation Rate",
    "section": "bitcoin",
    "body": "Bitcoin's inflation rate decreases predictably over time: Annual Inflation = (Blocks per Year × Subsidy) / Total Supply × 100% Example (2024): Blocks per year: ~52,560 (365.25 × 24 × 6) Subsidy: "
  },
  {
    "path": "/docs/bitcoin/subsidy#key-properties",
    "title": "Key Properties",
    "section": "bitcoin",
    "body": "Predictability Anyone can calculate the exact supply at any block height No central authority can change the schedule Requires network consensus to modify Scarcity Fixed maximum of 21 million BTC "
  },
  {
    "path": "/docs/bitcoin/subsidy#visual-representation",
    "title": "Visual Representation",
    "section": "bitcoin",
    "body": "Subsidy (BTC) │ 50 │████████ 25 │ ████████ 12.5 │ ████████ 6.25 │ ████████ 3.125 │ ████████ 1.5625│ ████████ │ └────────────────────────────────────────────────→ Blocks 0 210k 420k 630k 840k 1050k"
  },
  {
    "path": "/docs/bitcoin/subsidy#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "Bitcoin Core: validation.cpp: Subsidy calculation in source code Bitcoin Wiki: Controlled Supply: Detailed supply schedule Clark Moody Dashboard: Live supply statistics"
  },
  {
    "path": "/docs/bitcoin/transaction-fees",
    "title": "Transaction Fees",
    "section": "bitcoin",
    "body": "Transaction Fees Transaction fees are payments made to miners for including transactions in blocks. Understanding how fees work is essential for ensuring your transactions confirm in a timely manner. Why Fees Exist Fees serve multiple purposes: Incentivize miners: Reward miners for processing transactions Prevent spam: Make it expensive to flood the network Prioritize transactions: Higher fees = faster confirmation Economic security: Fees will replace block rewards over time Fee Calculation Fee "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#why-fees-exist",
    "title": "Why Fees Exist",
    "section": "bitcoin",
    "body": "Fees serve multiple purposes: Incentivize miners: Reward miners for processing transactions Prevent spam: Make it expensive to flood the network Prioritize transactions: Higher fees = faster "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#fee-calculation",
    "title": "Fee Calculation",
    "section": "bitcoin",
    "body": "Fee Rate Fees are calculated based on fee rate (satoshis per virtual byte): Fee = Transaction Size (vbytes) × Fee Rate (sat/vB) Example: Transaction size: 250 vbytes Fee rate: 10 sat/vB Total fee: "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#fee-estimation",
    "title": "Fee Estimation",
    "section": "bitcoin",
    "body": "Methods Wallets estimate fees using several approaches: Mempool analysis: Look at pending transactions Fee estimation APIs: Services like mempool.space Bitcoin Core RPC: estimatesmartfee command "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Estimating Fees :::code-group use serde_json::json; use reqwest; async fn estimate_fee_rate() -> Result> { let response = reqwest::get( \"https://mempool.space/api/v1/fees/recommended\" ).await?; let "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#fee-bumping",
    "title": "Fee Bumping",
    "section": "bitcoin",
    "body": "When a transaction is stuck in the mempool because the fee rate is too low, you can increase the effective fee using Replace-by-Fee (RBF) or Child Pays for Parent (CPFP). Replace-by-Fee (RBF) and BIP "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#fee-market-dynamics",
    "title": "Fee Market Dynamics",
    "section": "bitcoin",
    "body": "Supply and Demand High Demand (many transactions): Mempool fills up Fees increase Users compete for block space Low Demand (few transactions): Mempool empties Fees decrease Even low fees confirm "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Mempool - Where transactions wait Block Visualizer - See transactions flowing into blocks Block Construction - How miners select transactions SegWit - Lower fees through weight units Transaction "
  },
  {
    "path": "/docs/bitcoin/transaction-fees#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "mempool.space - Fee estimation and mempool visualization Bitcoin Core RPC: estimatesmartfee"
  },
  {
    "path": "/docs/bitcoin/transaction-malleability",
    "title": "Transaction Malleability",
    "section": "bitcoin",
    "body": "Transaction Malleability Transaction malleability was a vulnerability in Bitcoin that allowed anyone to modify a transaction's signature without invalidating it, changing the transaction ID. SegWit fixed this issue in 2017. What Was Transaction Malleability? Transaction malleability allowed modifying transaction signatures in ways that changed the transaction ID but didn't invalidate the transaction: Original Transaction: TXID: abc123... Signature: valid signature] Malleated Transaction: TXID: "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#what-was-transaction-malleability",
    "title": "What Was Transaction Malleability?",
    "section": "bitcoin",
    "body": "Transaction malleability allowed modifying transaction signatures in ways that changed the transaction ID but didn't invalidate the transaction: Original Transaction: TXID: abc123... Signature: "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#how-it-worked",
    "title": "How It Worked",
    "section": "bitcoin",
    "body": "The Problem Before SegWit, signatures were part of the transaction data used to calculate the TXID: TXID = SHA256D(serialized transaction) = SHA256D(version + inputs + outputs + signatures + "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#impact",
    "title": "Impact",
    "section": "bitcoin",
    "body": "Problems Created Payment Channels Impossible: Couldn't build transactions depending on unconfirmed transactions Lightning Network Blocked: Required fixed transaction IDs Transaction Tracking Issues: "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#the-fix-segwit",
    "title": "The Fix: SegWit",
    "section": "bitcoin",
    "body": "SegWit separated witness (signature) data from transaction data: Before: Signature in tx body] --> [TXID includes sig - malleable --> [TXID excludes sig - fixed] Before SegWit: TXID = "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#wtxid",
    "title": "wTXID",
    "section": "bitcoin",
    "body": "The witness transaction ID (wTXID) is the hash of the full transaction including witness data. Unlike the TXID, which hashes only the base transaction (and thus excludes witness), the wTXID changes "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#historical-context",
    "title": "Historical Context",
    "section": "bitcoin",
    "body": "When It Was Discovered 2011: First discussions of malleability 2013: Mt. Gox blamed malleability for issues (later revealed as cover-up) 2014: More serious attention to the problem 2017: SegWit "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#technical-details",
    "title": "Technical Details",
    "section": "bitcoin",
    "body": "Signature Encoding Variations ECDSA signatures have multiple valid encodings: DER Encoding: S-value can be normalized (low or high) Extra bytes can be added/removed All produce valid signatures All "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#current-status",
    "title": "Current Status",
    "section": "bitcoin",
    "body": "SegWit Adoption As of 2024: ~80% of transactions use SegWit SegWit transactions are not malleable Legacy transactions still technically malleable (rarely exploited) Best Practices Use SegWit "
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "SegWit - The fix for malleability Transaction Lifecycle - Transaction states Lightning Network - Requires malleability fix"
  },
  {
    "path": "/docs/bitcoin/transaction-malleability#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "BIP 141: Segregated Witness Transaction Malleability"
  },
  {
    "path": "/docs/bitcoin/segwit",
    "title": "SegWit",
    "section": "bitcoin",
    "body": "Segregated Witness (SegWit) Segregated Witness (SegWit) is a major Bitcoin protocol upgrade activated in August 2017 (block 481,824). It separates signature (witness) data from transaction data, fixing transaction malleability and effectively increasing block capacity. SegWit was designed primarily by Pieter Wuille (BIP 141). SegWit separates the \"witness\" (signature data) from the transaction body, storing it in a separate structure. This fundamental change enables: Malleability fix: ",
    "keywords": [
      "segwit",
      "seg wit",
      "segregated witness"
    ]
  },
  {
    "path": "/docs/bitcoin/segwit#the-problem-segwit-solved",
    "title": "The Problem SegWit Solved",
    "section": "bitcoin",
    "body": "Transaction Malleability Before SegWit, anyone could modify a transaction's signature without invalidating it, changing the transaction ID: Original Transaction: TXID: abc123... Modified (malleated) "
  },
  {
    "path": "/docs/bitcoin/segwit#how-segwit-works",
    "title": "How SegWit Works",
    "section": "bitcoin",
    "body": "Transaction Structure SegWit transactions have two parts: [Transaction] ├── Base Transaction │ ├── Version │ ├── Inputs without signatures │ ├── Outputs │ └── Locktime └── Witness Data └── Witness "
  },
  {
    "path": "/docs/bitcoin/segwit#address-types",
    "title": "Address Types",
    "section": "bitcoin",
    "body": "P2WPKH (Pay-to-Witness-Pubkey-Hash) Native SegWit addresses starting with bc1q: Format: bc1q + 32 characters Example: bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 P2WSH (Pay-to-Witness-Script-Hash) "
  },
  {
    "path": "/docs/bitcoin/segwit#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Creating a SegWit Transaction :::code-group use bitcoin::{Address, Network, Script, Transaction, TxIn, TxOut, Witness}; use bitcoin::hashes::Hash; use bitcoin::secp256k1::{Secp256k1, SecretKey}; fn "
  },
  {
    "path": "/docs/bitcoin/segwit#transaction-id-vs-witness-transaction-id",
    "title": "Transaction ID vs. Witness Transaction ID",
    "section": "bitcoin",
    "body": "Before SegWit TXID = SHA256D(serialized transaction) Problem: Signature changes → TXID changes (malleability) After SegWit TXID = SHA256D(serialized transaction WITHOUT witness) wtxid = "
  },
  {
    "path": "/docs/bitcoin/segwit#benefits",
    "title": "Benefits",
    "section": "bitcoin",
    "body": "1. Malleability Fix Transactions can now safely reference unconfirmed transactions: Before SegWit: Parent TX: abc123... (unconfirmed) Child TX: references abc123... → Parent gets malleated → "
  },
  {
    "path": "/docs/bitcoin/segwit#adoption",
    "title": "Adoption",
    "section": "bitcoin",
    "body": "Current Usage As of 2024: ~80% of transactions use SegWit Most wallets support SegWit addresses Lightning Network requires SegWit Migration Path P2SH-P2WPKH (wrapped): Backward compatible, starts "
  },
  {
    "path": "/docs/bitcoin/segwit#technical-details",
    "title": "Technical Details",
    "section": "bitcoin",
    "body": "Witness Version SegWit uses witness version 0: [Witness Program] ├── Version (1 byte): 0x00 └── Program (20 or 32 bytes) ├── 20 bytes: P2WPKH └── 32 bytes: P2WSH Script Execution SegWit changes "
  },
  {
    "path": "/docs/bitcoin/segwit#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Taproot - Next major upgrade after SegWit Address Types - Understanding SegWit addresses Transaction Fees - How SegWit affects fees Lightning Network - Requires SegWit to function"
  },
  {
    "path": "/docs/bitcoin/segwit#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "BIP 141: Segregated Witness BIP 143: Transaction Signature Verification BIP 144: Segregated Witness (Peer Services)"
  },
  {
    "path": "/docs/bitcoin/witness",
    "title": "Witness",
    "section": "bitcoin",
    "body": "Witness The witness is the part of a Bitcoin transaction that contains unlocking data (signatures, public keys, and other data) that proves authorization to spend inputs. SegWit (2017) moved witness data out of the base transaction into a separate structure, so it is no longer part of the data hashed for the TXID. That fixed transaction malleability and enabled the witness discount for fee calculation. Where witness lives In a SegWit or Taproot transaction, each input can have witness data. The "
  },
  {
    "path": "/docs/bitcoin/witness#where-witness-lives",
    "title": "Where witness lives",
    "section": "bitcoin",
    "body": "In a SegWit or Taproot transaction, each input can have witness data. The witness is serialized after the base transaction (version, inputs without witness, outputs, locktime). For each input, the "
  },
  {
    "path": "/docs/bitcoin/witness#why-it-matters",
    "title": "Why it matters",
    "section": "bitcoin",
    "body": "Malleability fix: The TXID hashes only the base transaction, so changing the witness does not change the TXID. That makes it safe to build transactions that depend on unconfirmed outputs (e.g. "
  },
  {
    "path": "/docs/bitcoin/witness#related",
    "title": "Related",
    "section": "bitcoin",
    "body": "SegWit for the upgrade and structure Taproot for Taproot witness and script paths Transaction Malleability for why witness was separated Transaction Structure for input and output field layout"
  },
  {
    "path": "/docs/bitcoin/taproot",
    "title": "Taproot",
    "section": "bitcoin",
    "body": "Taproot Taproot is a major Bitcoin protocol upgrade activated in November 2021 (block 709,632). It combines Schnorr signatures with MAST (Merkle Abstract Syntax Trees) to provide better privacy, efficiency, and flexibility for Bitcoin transactions. Pieter Wuille was a key designer (BIPs 340, 341, 342). Taproot introduces a new output type (P2TR) that enables: Schnorr signatures: More efficient than ECDSA, enables signature aggregation MAST: Hides unused script conditions in a Merkle tree Better ",
    "keywords": [
      "taproot",
      "tap root",
      "schnorr",
      "mast",
      "musig"
    ]
  },
  {
    "path": "/docs/bitcoin/taproot#key-components",
    "title": "Key Components",
    "section": "bitcoin",
    "body": "1. Schnorr Signatures (BIP 340) Taproot uses Schnorr for all P2TR signatures: 64-byte fixed size, signature aggregation (MuSig / MuSig2), and batch verification. See Schnorr Signatures for the full "
  },
  {
    "path": "/docs/bitcoin/taproot#how-taproot-works",
    "title": "How Taproot Works",
    "section": "bitcoin",
    "body": "Key Path vs. Script Path Taproot outputs can be spent in two ways: Key Path (Simple Spend) Output: P2TR address Spend: Single Schnorr signature Result: Looks identical to any other Taproot spend "
  },
  {
    "path": "/docs/bitcoin/taproot#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Creating a Taproot Address :::code-group use bitcoin::{Address, Network, PublicKey, XOnlyPublicKey}; use bitcoin::secp256k1::{Secp256k1, SecretKey, KeyPair}; use bitcoin::taproot::{TaprootBuilder, "
  },
  {
    "path": "/docs/bitcoin/taproot#privacy-benefits",
    "title": "Privacy Benefits",
    "section": "bitcoin",
    "body": "Before Taproot Multisig Transaction: Reveals all public keys Reveals all signatures Obvious it's a multisig Linkable to other multisig transactions After Taproot Multisig Transaction (key path): "
  },
  {
    "path": "/docs/bitcoin/taproot#efficiency-benefits",
    "title": "Efficiency Benefits",
    "section": "bitcoin",
    "body": "Signature Size ECDSA (SegWit): Signature: 71-72 bytes Public key: 33 bytes Total: ~104-105 bytes Schnorr (Taproot): Signature: 64 bytes Public key: 32 bytes (x-only) Total: 96 bytes Savings: ~8-9 "
  },
  {
    "path": "/docs/bitcoin/taproot#musig-multi-signature-aggregation",
    "title": "MuSig (Multi-Signature Aggregation)",
    "section": "bitcoin",
    "body": "Taproot enables MuSig, where multiple signatures are combined into one. The underlying Schnorr scheme makes this aggregation possible. Traditional Multisig: Key 1 signature: 71 bytes Key 2 signature: "
  },
  {
    "path": "/docs/bitcoin/taproot#adoption",
    "title": "Adoption",
    "section": "bitcoin",
    "body": "Current Usage As of 2024: ~5-10% of transactions use Taproot Growing adoption in modern wallets Required for advanced smart contracts Migration Use P2TR addresses for new outputs Support Taproot in "
  },
  {
    "path": "/docs/bitcoin/taproot#technical-details",
    "title": "Technical Details",
    "section": "bitcoin",
    "body": "Bech32m Encoding Taproot uses Bech32m (modified Bech32) instead of Bech32: Bech32: Used for SegWit (P2WPKH, P2WSH) Bech32m: Used for Taproot (P2TR) Difference: Constant in checksum calculation "
  },
  {
    "path": "/docs/bitcoin/taproot#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "SegWit - Previous major upgrade Schnorr Signatures - Signature scheme MAST - Merkle Abstract Syntax Trees Address Types - Understanding P2TR addresses"
  },
  {
    "path": "/docs/bitcoin/taproot#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "BIP 340: Schnorr Signatures BIP 341: Taproot BIP 342: Validation of Taproot Scripts"
  },
  {
    "path": "/docs/bitcoin/p2p-protocol",
    "title": "P2P Network Protocol",
    "section": "bitcoin",
    "body": "P2P Network Protocol Bitcoin uses a peer-to-peer (P2P) network protocol for nodes to communicate, share blocks, and propagate transactions. Understanding the P2P protocol is essential for running nodes and understanding network behavior. Design context Bitcoin's P2P design was inspired by the same P2P ideas and era (early 2000s), including BitTorrent's success; decentralization, no single point of failure, and censorship resistance. Bitcoin does not use BitTorrent's protocol; it has its own "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#design-context",
    "title": "Design context",
    "section": "bitcoin",
    "body": "Bitcoin's P2P design was inspired by the same P2P ideas and era (early 2000s), including BitTorrent's success; decentralization, no single point of failure, and censorship resistance. Bitcoin does "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#network-architecture",
    "title": "Network Architecture",
    "section": "bitcoin",
    "body": "Node Types Full Nodes: Download and validate entire blockchain Relay blocks and transactions Maintain network consensus Light Nodes (SPV): Download block headers only Request specific transactions "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#protocol-messages",
    "title": "Protocol Messages",
    "section": "bitcoin",
    "body": "Handshake Nodes establish connections through a handshake: Version Message: Announce capabilities Verack Message: Acknowledge version Connection established sequenceDiagram participant A as Node A "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#code-examples",
    "title": "Code Examples",
    "section": "bitcoin",
    "body": "Establishing Connection :::code-group use std::net::TcpStream; use bitcoin::network::message::{NetworkMessage, RawNetworkMessage}; use bitcoin::network::constants::Magic; fn connect_to_peer(address: "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#message-flow",
    "title": "Message Flow",
    "section": "bitcoin",
    "body": "Block Propagation Miner finds block Sends 'inv' message to peers Peers request block with 'getdata' Miner sends 'block' message Peers validate and forward Transaction Propagation User creates "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#peer-discovery",
    "title": "Peer Discovery",
    "section": "bitcoin",
    "body": "Methods DNS Seeds: Hardcoded DNS servers Hardcoded Seeds: Bootstrap IP addresses Peer Exchange: Peers share addresses Manual Connection: User-specified peers Address Management Known Addresses: ├── "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#network-security",
    "title": "Network Security",
    "section": "bitcoin",
    "body": "Eclipse Attacks Prevented by: Connecting to diverse IP ranges Using multiple outbound connections Verifying block data independently Sybil Attacks Mitigated by: Requiring proof-of-work for blocks "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#tor-and-bitcoin",
    "title": "Tor and Bitcoin",
    "section": "bitcoin",
    "body": "Tor is an anonymity network that routes traffic through volunteer relays so that observers cannot see who is talking to whom. Satoshi cited Tor (with Gnutella) as an example of a resilient pure P2P "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#compact-blocks-bip-152",
    "title": "Compact Blocks (BIP 152)",
    "section": "bitcoin",
    "body": "Optimization for faster block propagation: Standard Block: Full block: ~1-2 MB Slow propagation Compact Block: Header + short IDs: ~20 KB Receiver reconstructs from mempool Much faster"
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#p2p-v2-encrypted-transport-bip-324",
    "title": "P2P v2 / Encrypted Transport (BIP 324)",
    "section": "bitcoin",
    "body": "BIP 324 defines a v2 P2P transport that encrypts and authenticated the peer-to-peer link. Messages (e.g., version, verack, inv, block, tx) are encrypted so that a passive on-path observer cannot read "
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#related-topics",
    "title": "Related Topics",
    "section": "bitcoin",
    "body": "Block Propagation - How blocks spread Mempool - Transaction pool Node Types - Different node configurations"
  },
  {
    "path": "/docs/bitcoin/p2p-protocol#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "Bitcoin Protocol Documentation BIP 152: Compact Block Relay BIP 324: Version 2 P2P Encrypted Transport"
  },
  {
    "path": "/docs/bitcoin/data-encoding",
    "title": "Data Encoding",
    "section": "bitcoin",
    "body": "Data Encoding Bitcoin serializes transactions and blocks as byte sequences. When you read or write raw data (e.g. parsing a transaction, building a block header), you need to know how numbers and variable-length fields are encoded. Bytes and hexadecimal Raw transaction and block data are sequences of bytes (8-bit values, 0–255). They are often shown in hexadecimal (base-16): each byte is two hex digits (0–9, A–F). For example, the 32-byte TXID is 64 hex characters. Little-endian Multi-byte "
  },
  {
    "path": "/docs/bitcoin/data-encoding#bytes-and-hexadecimal",
    "title": "Bytes and hexadecimal",
    "section": "bitcoin",
    "body": "Raw transaction and block data are sequences of bytes (8-bit values, 0–255). They are often shown in hexadecimal (base-16): each byte is two hex digits (0–9, A–F). For example, the 32-byte TXID is 64 "
  },
  {
    "path": "/docs/bitcoin/data-encoding#little-endian",
    "title": "Little-endian",
    "section": "bitcoin",
    "body": "Multi-byte integers in Bitcoin (version, locktime, nonce, value, etc.) are stored in little-endian order: the least significant byte first. For example, the 4-byte value 0x00000001 is stored as bytes "
  },
  {
    "path": "/docs/bitcoin/data-encoding#compact-size-varint",
    "title": "Compact size (VarInt)",
    "section": "bitcoin",
    "body": "Variable-length fields (script length, number of inputs/outputs, witness stack size) use compact size encoding (also called VarInt). The first byte determines how many bytes follow: 0–252: The value "
  },
  {
    "path": "/docs/bitcoin/data-encoding#block-and-transaction-layout",
    "title": "Block and transaction layout",
    "section": "bitcoin",
    "body": "Block header: 80 bytes, all fixed: version (4), previous block hash (32), merkle root (32), timestamp (4), difficulty target (nBits, 4), nonce (4). All multi-byte integers little-endian. Transaction: "
  },
  {
    "path": "/docs/bitcoin/data-encoding#related",
    "title": "Related",
    "section": "bitcoin",
    "body": "Transaction Decoder — decode raw transaction hex in the browser Transaction Structure for input and output fields Script for script format Blocks for block format"
  },
  {
    "path": "/docs/bitcoin/rpc",
    "title": "RPC Commands",
    "section": "bitcoin",
    "body": "RPC Commands Reference This document provides a guide for interacting with your Bitcoin node using both curl and bitcoin-cli commands via RPC. Try it live! Test these commands directly in the Bitcoin CLI Terminal. Connected to mainnet, no setup required. | Command | Purpose | |---------|---------| | getblockchaininfo | Chain tip, verification progress, network name | | getblock | Block data by hash or verbosity | | getblockhash | Block hash by height | | getrawtransaction | Transaction hex or ",
    "keywords": [
      "rpc",
      "remote procedure call",
      "json-rpc",
      "bitcoin core rpc"
    ]
  },
  {
    "path": "/docs/bitcoin/rpc#rpc-configuration",
    "title": "RPC Configuration",
    "section": "bitcoin",
    "body": "bitcoin.conf Setup Add these settings to your bitcoin.conf file: RPC Server Settings server=1 rpcuser=your_username rpcpassword=your_secure_password rpcport=8332 Restrict RPC to localhost "
  },
  {
    "path": "/docs/bitcoin/rpc#basic-rpc-structure",
    "title": "Basic RPC Structure",
    "section": "bitcoin",
    "body": "Set up alias for easier use alias btc='bitcoin-cli -rpcuser=$BITCOIN_RPC_USER -rpcpassword=$BITCOIN_RPC_PASSWORD -rpcport=$BITCOIN_RPC_PORT' Then use simple commands btc [parameters]"
  },
  {
    "path": "/docs/bitcoin/rpc#programmatic-rpc-access",
    "title": "Programmatic RPC Access",
    "section": "bitcoin",
    "body": "For building applications, you can interact with Bitcoin Core RPC programmatically: :::code-group use reqwest::blocking::Client; use serde::{Deserialize, Serialize}; use serde_json::{json, Value}; "
  },
  {
    "path": "/docs/bitcoin/rpc#essential-node-information-commands",
    "title": "Essential Node Information Commands",
    "section": "bitcoin",
    "body": "1. Blockchain Information btc getblockchaininfo Key fields to monitor: blocks: Current block height headers: Number of headers downloaded verificationprogress: Sync progress (0.0 to 1.0) "
  },
  {
    "path": "/docs/bitcoin/rpc#wallet-commands",
    "title": "Wallet Commands",
    "section": "bitcoin",
    "body": "6. Wallet Information List wallets btc listwallets Get wallet info btc getwalletinfo Get balance btc getbalance 7. Wallet Management List all loaded wallets btc listwallets Get info about specific "
  },
  {
    "path": "/docs/bitcoin/rpc#advanced-diagnostic-commands",
    "title": "Advanced Diagnostic Commands",
    "section": "bitcoin",
    "body": "8. Index Information Check if transaction index is available btc getindexinfo Calculate indexing progress percentage btc getindexinfo | jq '.txindex.best_block_height / 880000 * 100' Check if "
  },
  {
    "path": "/docs/bitcoin/rpc#11-zmq-notifications",
    "title": "11. ZMQ Notifications",
    "section": "bitcoin",
    "body": "ZeroMQ provides real-time notifications for blockchain events, enabling instant detection of new blocks and transactions without polling. Configuration Add to your bitcoin.conf: ZMQ Notifications "
  },
  {
    "path": "/docs/bitcoin/rpc#troubleshooting",
    "title": "Troubleshooting",
    "section": "bitcoin",
    "body": "Connection Issues Test RPC connection btc getblockchaininfo | jq '.chain' Check network status btc getnetworkinfo | jq '{connections, connections_in, connections_out}' Verify wallet is accessible btc "
  },
  {
    "path": "/docs/bitcoin/rpc#json-output-formatting",
    "title": "JSON Output Formatting",
    "section": "bitcoin",
    "body": "To make the output more readable, pipe through jq: Install jq if not available macOS: brew install jq Ubuntu: apt install jq btc getblockchaininfo | jq '{blocks, verificationprogress}'"
  },
  {
    "path": "/docs/bitcoin/rpc#resources",
    "title": "Resources",
    "section": "bitcoin",
    "body": "mempool.space: Real-time Bitcoin mempool and block explorer Clark Moody's Bitcoin Dashboard: Bitcoin metrics and analytics Bitcoin Core GitHub: Bitcoin Core source code repository Bitcoin Core RPC "
  },
  {
    "path": "/docs/mining",
    "title": "Mining",
    "section": "mining",
    "body": "Bitcoin Mining Bitcoin mining is the process by which new Bitcoin transactions are verified and added to the blockchain. Miners compete to solve cryptographic puzzles using computational power, and the first miner to solve the puzzle gets to add the next block to the blockchain and receive a reward. Why \"Mining\"? The term \"mining\" is borrowed from gold mining. Just as gold miners expend resources (labor, equipment, energy) to extract gold from the earth, Bitcoin miners expend computational "
  },
  {
    "path": "/docs/mining#why-mining",
    "title": "Why \"Mining\"?",
    "section": "mining",
    "body": "The term \"mining\" is borrowed from gold mining. Just as gold miners expend resources (labor, equipment, energy) to extract gold from the earth, Bitcoin miners expend computational resources "
  },
  {
    "path": "/docs/mining#what-mining-does",
    "title": "What Mining Does",
    "section": "mining",
    "body": "Mining serves two critical functions: Transaction Processing: Validating and confirming transactions Currency Issuance: Creating new bitcoin according to the predetermined supply schedule"
  },
  {
    "path": "/docs/mining#how-mining-works",
    "title": "How Mining Works",
    "section": "mining",
    "body": "Block Creation Process Transaction Collection: Miners collect pending transactions from the mempool Block Construction: Miners assemble transactions into a candidate block Proof-of-Work: Miners "
  },
  {
    "path": "/docs/mining#key-concepts",
    "title": "Key Concepts",
    "section": "mining",
    "body": "| Concept | Description | |---------|-------------| | Proof-of-Work | Cryptographic puzzle that miners solve to validate blocks | | Block Reward | Currently 3.125 BTC per block (after 2024 halving) | "
  },
  {
    "path": "/docs/mining#why-mining-matters",
    "title": "Why Mining Matters",
    "section": "mining",
    "body": "Network Security Mining provides Bitcoin's security through proof-of-work. To attack the network, an adversary would need to control more than 50% of the global hash rate: an astronomically expensive "
  },
  {
    "path": "/docs/mining#mining-today",
    "title": "Mining Today",
    "section": "mining",
    "body": "Current Statistics (2024) Network Hash Rate: ~700 EH/s (exahashes per second) Block Reward: 3.125 BTC Average Block Time: ~10 minutes Difficulty: Adjusts every ~2 weeks Daily Blocks: ~144 Who Mines? "
  },
  {
    "path": "/docs/mining#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Proof-of-Work Mechanism - How the mining algorithm works Difficulty Adjustment - How difficulty adjusts to maintain block times Mining Economics - Block rewards, fees, and profitability Block "
  },
  {
    "path": "/docs/mining/proof-of-work",
    "title": "Proof-of-Work",
    "section": "mining",
    "body": "Proof-of-Work Mechanism Bitcoin uses a proof-of-work consensus mechanism where miners compete to solve a cryptographic puzzle. This process secures the network and validates transactions. How It Works Block Construction: Miners collect transactions from the mempool and create a candidate block Nonce Search: Miners repeatedly hash the block header with different nonce values Difficulty Target: The hash must be below a certain target (set by network difficulty) Success: When a miner finds a valid "
  },
  {
    "path": "/docs/mining/proof-of-work#how-it-works",
    "title": "How It Works",
    "section": "mining",
    "body": "Block Construction: Miners collect transactions from the mempool and create a candidate block Nonce Search: Miners repeatedly hash the block header with different nonce values Difficulty Target: The "
  },
  {
    "path": "/docs/mining/proof-of-work#mining-difficulty",
    "title": "Mining Difficulty",
    "section": "mining",
    "body": "Adjustment: Every 2016 blocks (~2 weeks), the difficulty adjusts based on network hash rate Target: Maintains ~10 minute average block time Current Network Hash Rate: ~700 EH/s (exahashes per second) "
  },
  {
    "path": "/docs/mining/proof-of-work#technical-details",
    "title": "Technical Details",
    "section": "mining",
    "body": "Block Headers Size: 80 bytes of block metadata Components: Version, previous block hash, merkle root, timestamp, difficulty target, nonce Hash Function: SHA256D (double SHA-256) Nonce Space Range: 0 "
  },
  {
    "path": "/docs/mining/proof-of-work#hash-function-sha256d",
    "title": "Hash Function: SHA256D",
    "section": "mining",
    "body": "Bitcoin uses a double SHA-256 hash function: hash = SHA256(SHA256(block_header)) This means: First SHA-256 hash of the block header Second SHA-256 hash of the first hash result Result must be below "
  },
  {
    "path": "/docs/mining/proof-of-work#mining-process-flow",
    "title": "Mining Process Flow",
    "section": "mining",
    "body": "Collect Transactions ↓ Build Block Header ↓ Hash Block Header ↓ Check if Hash < Target ├─ Yes → Broadcast Block → Receive Reward └─ No → Increment Nonce → Repeat from Step 3"
  },
  {
    "path": "/docs/mining/proof-of-work#educational-value",
    "title": "Educational Value",
    "section": "mining",
    "body": "What You'll Learn Block Construction: How Bitcoin blocks are built Mining Algorithms: SHA256D hash function Network Protocol: RPC communication with Bitcoin node Difficulty Adjustment: How network "
  },
  {
    "path": "/docs/mining/proof-of-work#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Bitcoin Mining - Mining architecture and concepts Mining Economics - Rewards and profitability Difficulty Adjustment - How difficulty adjusts over time Block Construction - How blocks are assembled"
  },
  {
    "path": "/docs/mining/difficulty",
    "title": "Difficulty Adjustment",
    "section": "mining",
    "body": "Difficulty Adjustment Bitcoin's difficulty adjustment is a critical mechanism that maintains the network's target block time of approximately 10 minutes. Every 2016 blocks (~2 weeks), the network automatically adjusts the mining difficulty based on the actual time it took to mine the previous 2016 blocks. How Difficulty Adjustment Works Adjustment Formula The difficulty adjusts every 2016 blocks (approximately every 2 weeks) using the formula: New Difficulty = Old Difficulty × (Target Time / "
  },
  {
    "path": "/docs/mining/difficulty#how-difficulty-adjustment-works",
    "title": "How Difficulty Adjustment Works",
    "section": "mining",
    "body": "Adjustment Formula The difficulty adjusts every 2016 blocks (approximately every 2 weeks) using the formula: New Difficulty = Old Difficulty × (Target Time / Actual Time) Where: Target Time: 2016 "
  },
  {
    "path": "/docs/mining/difficulty#why-difficulty-adjustment-exists",
    "title": "Why Difficulty Adjustment Exists",
    "section": "mining",
    "body": "Maintaining Block Time Target: ~10 minutes per block Purpose: Predictable block creation rate Benefit: Consistent transaction confirmation times Network Security Hash Rate Changes: Network hash rate "
  },
  {
    "path": "/docs/mining/difficulty#historical-difficulty-adjustments",
    "title": "Historical Difficulty Adjustments",
    "section": "mining",
    "body": "Early Bitcoin (2009-2012) Difficulty: Very low (could mine with CPU) Adjustments: Frequent large increases as hash rate grew Network: Small, growing hash rate ASIC Era (2013-Present) Difficulty: "
  },
  {
    "path": "/docs/mining/difficulty#difficulty-metrics",
    "title": "Difficulty Metrics",
    "section": "mining",
    "body": "Current Network Stats Block Time: Maintained at ~10 minutes average Hash Rate: ~700 EH/s (exahashes per second) Difficulty: Adjusts every 2016 blocks Adjustment Frequency: Approximately every 2 weeks "
  },
  {
    "path": "/docs/mining/difficulty#impact-on-miners",
    "title": "Impact on Miners",
    "section": "mining",
    "body": "Hash Rate Changes When network hash rate increases: Difficulty increases in next adjustment Same hardware produces fewer valid hashes Mining becomes harder for all miners When network hash rate "
  },
  {
    "path": "/docs/mining/difficulty#technical-details",
    "title": "Technical Details",
    "section": "mining",
    "body": "Block Header Fields The difficulty is encoded in the block header's nBits field: Compact representation: 32-bit value Target calculation: Converts nBits to full 256-bit difficulty target Validation: "
  },
  {
    "path": "/docs/mining/difficulty#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Proof-of-Work Mechanism - How the mining algorithm works Mining Economics - How difficulty affects profitability Bitcoin Mining - General mining concepts"
  },
  {
    "path": "/docs/mining/mempool",
    "title": "Mempool",
    "section": "mining",
    "body": "The Mempool The mempool (memory pool) is Bitcoin's waiting room for unconfirmed transactions. When you broadcast a transaction, it doesn't immediately go into a block. It first enters the mempool, where it waits for a miner to include it in the next block. Every full node maintains its own mempool. There is no single, global mempool; each node has its own view of pending transactions, though they generally converge through transaction propagation across the network. How the Mempool Works ",
    "keywords": [
      "mempool",
      "memory pool",
      "transaction pool"
    ]
  },
  {
    "path": "/docs/mining/mempool#how-the-mempool-works",
    "title": "How the Mempool Works",
    "section": "mining",
    "body": "Transaction Lifecycle Broadcast: User signs and broadcasts a transaction Validation: Nodes verify the transaction is valid (correct signatures, sufficient funds, proper format) Mempool Entry: Valid "
  },
  {
    "path": "/docs/mining/mempool#querying-the-mempool",
    "title": "Querying the Mempool",
    "section": "mining",
    "body": "You can query mempool information using Bitcoin Core's RPC interface: :::code-group use bitcoincore_rpc::{Auth, Client, RpcApi}; use serde_json::Value; /// Query mempool information using Bitcoin "
  },
  {
    "path": "/docs/mining/mempool#fee-market-dynamics",
    "title": "Fee Market Dynamics",
    "section": "mining",
    "body": "The mempool creates a fee market where users bid for block space. How Fees Work Transactions pay fees measured in satoshis per virtual byte (sat/vB) Miners prioritize higher-fee transactions (more "
  },
  {
    "path": "/docs/mining/mempool#replace-by-fee-rbf",
    "title": "Replace-by-Fee (RBF)",
    "section": "mining",
    "body": "RBF allows replacing an unconfirmed transaction with a new version paying a higher fee. How RBF Works Original transaction signals RBF capability (sequence number < 0xfffffffe) User broadcasts "
  },
  {
    "path": "/docs/mining/mempool#child-pays-for-parent-cpfp",
    "title": "Child Pays for Parent (CPFP)",
    "section": "mining",
    "body": "An alternative to RBF for fee bumping. How CPFP Works Parent transaction is stuck with low fee Create a child transaction spending the parent's output Child pays a high enough fee to cover both "
  },
  {
    "path": "/docs/mining/mempool#mempool-visualization",
    "title": "Mempool Visualization",
    "section": "mining",
    "body": "The mempool can be visualized as a queue sorted by fee rate: Block Space Available: ~1 MB (4 MWU) Fee Rate (sat/vB) │ 100+│ ████ ← Confirmed in next block │ ████ 50 │ ████████ ← Confirmed in 1-3 "
  },
  {
    "path": "/docs/mining/mempool#mempool-sniping-and-games",
    "title": "Mempool Sniping and Games",
    "section": "mining",
    "body": "Transaction Pinning An attack where someone prevents a transaction from being replaced: Attacker creates a low-fee child transaction Child is large, making CPFP expensive Original transaction is "
  },
  {
    "path": "/docs/mining/mempool#mempool-tools-and-resources",
    "title": "Mempool Tools and Resources",
    "section": "mining",
    "body": "Query the mempool yourself! Try getmempoolinfo and getrawmempool in the Bitcoin CLI Terminal. Explore visually! See transactions flowing into blocks with our interactive Block Visualizer. Mempool "
  },
  {
    "path": "/docs/mining/mempool#implications-for-users",
    "title": "Implications for Users",
    "section": "mining",
    "body": "Sending Transactions Check mempool first: See current fee rates before sending Use appropriate fees: Overpaying wastes money; underpaying causes delays Enable RBF: Always signal RBF for flexibility "
  },
  {
    "path": "/docs/mining/mempool#technical-details",
    "title": "Technical Details",
    "section": "mining",
    "body": "Mempool Data Structures Bitcoin Core maintains several structures: mapTx: Main transaction storage, indexed multiple ways Ancestor/Descendant tracking: For CPFP calculations Fee rate buckets: For "
  },
  {
    "path": "/docs/mining/mempool#summary",
    "title": "Summary",
    "section": "mining",
    "body": "The mempool is the heartbeat of Bitcoin's transaction processing: Waiting room: Where transactions queue for confirmation Fee market: Creates price discovery for block space Strategic space: RBF and "
  },
  {
    "path": "/docs/mining/mempool#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Mining Economics - How miners profit from fees Block Construction - How miners select transactions Proof-of-Work - The mining process"
  },
  {
    "path": "/docs/mining/mempool#resources",
    "title": "Resources",
    "section": "mining",
    "body": "mempool.space - Real-time mempool visualization Bitcoin Core mempool documentation - Technical details"
  },
  {
    "path": "/docs/mining/block-construction",
    "title": "Block Construction",
    "section": "mining",
    "body": "Block Construction Block construction is the process by which miners assemble a new block from pending transactions. This is where the mempool meets the blockchain. Miners must decide which transactions to include, how to order them, and how to structure the block for maximum profit while following consensus rules. Anatomy of a Block A Bitcoin block consists of two main parts: Block Header (80 bytes) Block Header 80 bytes] ├── Version (4 bytes) ├── Previous Block Hash (32 bytes) ├── Merkle Root "
  },
  {
    "path": "/docs/mining/block-construction#anatomy-of-a-block",
    "title": "Anatomy of a Block",
    "section": "mining",
    "body": "A Bitcoin block consists of two main parts: Block Header (80 bytes) [Block Header 80 bytes] ├── Version (4 bytes) ├── Previous Block Hash (32 bytes) ├── Merkle Root (32 bytes) ├── Timestamp (4 bytes) "
  },
  {
    "path": "/docs/mining/block-construction#the-coinbase-transaction",
    "title": "The Coinbase Transaction",
    "section": "mining",
    "body": "The coinbase transaction is special: it's the only transaction that creates new bitcoin. Structure Inputs: No previous output (creates coins from nothing) Coinbase data: Arbitrary data (up to 100 "
  },
  {
    "path": "/docs/mining/block-construction#candidate-block",
    "title": "Candidate Block",
    "section": "mining",
    "body": "A candidate block is the block a miner is currently hashing. It is built from a block template: the miner fills in the header (version, previous block hash, merkle root, timestamp, difficulty target, "
  },
  {
    "path": "/docs/mining/block-construction#transaction-selection",
    "title": "Transaction Selection",
    "section": "mining",
    "body": "Miners want to maximize revenue, which means selecting transactions that pay the highest fees per unit of block space. The Knapsack Problem Block construction is a variant of the knapsack "
  },
  {
    "path": "/docs/mining/block-construction#block-weight-and-segwit",
    "title": "Block Weight and SegWit",
    "section": "mining",
    "body": "Since SegWit (2017), blocks use weight instead of raw size: Block Weight = (Base Size × 4) + Witness Size Maximum Block Weight = 4,000,000 weight units (4 MWU) Practical Capacity Non-SegWit "
  },
  {
    "path": "/docs/mining/block-construction#constructing-the-merkle-root",
    "title": "Constructing the Merkle Root",
    "section": "mining",
    "body": "All transactions in a block are hashed into a Merkle tree: Merkle Root / \\ Hash AB Hash CD / \\ / \\ Hash A Hash B Hash C Hash D | | | | Tx A Tx B Tx C Tx D Why Merkle Trees? Efficient verification: "
  },
  {
    "path": "/docs/mining/block-construction#the-block-template",
    "title": "The Block Template",
    "section": "mining",
    "body": "When a miner requests work, they receive a block template: { \"version\": 536870912, \"previousblockhash\": \"00000000000000000002a7c...\", \"transactions\": [ { \"txid\": \"abc123...\", \"fee\": 25000, \"weight\": "
  },
  {
    "path": "/docs/mining/block-construction#empty-blocks",
    "title": "Empty Blocks",
    "section": "mining",
    "body": "Sometimes miners produce empty blocks (only coinbase transaction): Why Empty Blocks? Speed: Immediately after finding a block, miners start on the next Validation lag: New block's transactions aren't "
  },
  {
    "path": "/docs/mining/block-construction#extra-nonce",
    "title": "Extra Nonce",
    "section": "mining",
    "body": "The 4-byte nonce in the header provides only 2³² possibilities, which is not enough for modern ASICs. Expanding the Search Space Miners use additional variables: Extra nonce in coinbase: Arbitrary "
  },
  {
    "path": "/docs/mining/block-construction#block-propagation-incentives",
    "title": "Block Propagation Incentives",
    "section": "mining",
    "body": "Miners want their blocks to propagate quickly: Compact Blocks (BIP 152) Instead of sending full blocks: Send block header + short transaction IDs Receiver reconstructs from mempool Request only "
  },
  {
    "path": "/docs/mining/block-construction#practical-example",
    "title": "Practical Example",
    "section": "mining",
    "body": "Building a block step by step: Start with empty block Weight used: 0 / 4,000,000 Fees collected: 0 Create coinbase transaction Block reward: 3.125 BTC Reserve space for coinbase: ~200 weight units "
  },
  {
    "path": "/docs/mining/block-construction#summary",
    "title": "Summary",
    "section": "mining",
    "body": "Block construction is where mining meets economics: Coinbase creates new bitcoin plus collects all fees Transaction selection optimizes for fee revenue Merkle trees provide efficient verification "
  },
  {
    "path": "/docs/mining/block-construction#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Mempool - Where transactions wait Block Visualizer - See transactions flowing into blocks Proof-of-Work - Finding valid blocks Mining Economics - Revenue and costs Mining Pools - Collaborative mining"
  },
  {
    "path": "/docs/mining/block-construction#resources",
    "title": "Resources",
    "section": "mining",
    "body": "BIP 152: Compact Blocks Bitcoin Core getblocktemplate"
  },
  {
    "path": "/docs/mining/economics",
    "title": "Economics",
    "section": "mining",
    "body": "Mining Economics Understanding the economics of Bitcoin mining is essential for anyone considering participating in the network. This page covers the revenue sources, cost factors, and profitability calculations that determine whether mining is financially viable. Block Rewards The primary revenue source for miners is the block reward, which consists of two components: | Component | Description | Current Value | |-----------|-------------|---------------| | Block Subsidy | New bitcoin created "
  },
  {
    "path": "/docs/mining/economics#block-rewards",
    "title": "Block Rewards",
    "section": "mining",
    "body": "The primary revenue source for miners is the block reward, which consists of two components: | Component | Description | Current Value | |-----------|-------------|---------------| | Block Subsidy | "
  },
  {
    "path": "/docs/mining/economics#cost-analysis",
    "title": "Cost Analysis",
    "section": "mining",
    "body": "Electricity Costs Electricity is typically the largest ongoing cost for miners: Power Consumption: Varies by hardware (modern ASICs: 3,000-3,500W) Cost Calculation: Power (kW) × Hours × Electricity "
  },
  {
    "path": "/docs/mining/economics#profitability-calculation",
    "title": "Profitability Calculation",
    "section": "mining",
    "body": "Mining profitability depends on several factors. Here's how to calculate expected returns: :::code-group /// Mining profitability calculator /// /// Calculates daily profit based on hardware specs "
  },
  {
    "path": "/docs/mining/economics#mining-profitability-factors",
    "title": "Mining Profitability Factors",
    "section": "mining",
    "body": "Network Hash Rate Current: ~700 EH/s (exahashes per second) Trend: Generally increasing over time Impact: Higher network hash rate means smaller share of rewards Difficulty Adjustment Frequency: "
  },
  {
    "path": "/docs/mining/economics#pool-mining-economics",
    "title": "Pool Mining Economics",
    "section": "mining",
    "body": "How Pool Mining Works Miners contribute hash power to pool Pool finds blocks collectively Rewards distributed based on contribution More consistent payouts than solo mining Pool Fees Typical Fee: "
  },
  {
    "path": "/docs/mining/economics#individual-vs-pool-mining",
    "title": "Individual vs Pool Mining",
    "section": "mining",
    "body": "Solo Mining Probability: Extremely low for individual miners Time to Block: Could take years or never happen Reward: Full block reward when successful Best For: Very large operations only Pool Mining "
  },
  {
    "path": "/docs/mining/economics#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Bitcoin Mining - Mining architecture and concepts Proof-of-Work Mechanism - How mining works Difficulty Adjustment - How difficulty affects profitability Mining Pools - Pool operations and payout "
  },
  {
    "path": "/docs/mining/pools",
    "title": "Mining Pools",
    "section": "mining",
    "body": "Mining Pools A mining pool is a collective of miners who combine their computational resources to increase their chances of finding blocks. When the pool finds a block, the reward is distributed among participants based on their contributed work. Solo mining is like playing the lottery: you might wait years for a payout. Pool mining provides regular, predictable income at the cost of sharing rewards. Why Mining Pools Exist The Variance Problem Consider a solo miner with 0.001% of total network "
  },
  {
    "path": "/docs/mining/pools#why-mining-pools-exist",
    "title": "Why Mining Pools Exist",
    "section": "mining",
    "body": "The Variance Problem Consider a solo miner with 0.001% of total network hashrate: Expected time to find a block: ~1,000,000 blocks ÷ 0.00001 = 100,000,000 minutes ≈ 190 years Block reward: 3.125 BTC "
  },
  {
    "path": "/docs/mining/pools#how-mining-pools-work",
    "title": "How Mining Pools Work",
    "section": "mining",
    "body": "Basic Flow Miner connects to pool Pool sends work (block template) Miner searches for valid shares Miner submits shares to pool Pool validates shares and credits miner When pool finds a block, "
  },
  {
    "path": "/docs/mining/pools#payout-schemes",
    "title": "Payout Schemes",
    "section": "mining",
    "body": "Different pools use different methods to distribute rewards. Pay Per Share (PPS) How it works: Pool pays fixed amount per share, regardless of whether blocks are found Miner risk: None; guaranteed "
  },
  {
    "path": "/docs/mining/pools#pool-protocols",
    "title": "Pool Protocols",
    "section": "mining",
    "body": "Stratum (v1) The dominant mining protocol since 2012: Pool → Miner: Here's the block template Miner → Pool: Here's a valid share Pool → Miner: Share accepted, new work Characteristics: Simple and "
  },
  {
    "path": "/docs/mining/pools#centralization-concerns",
    "title": "Centralization Concerns",
    "section": "mining",
    "body": "Pool centralization means that a small number of pool operators control a large share of network hashrate. Although miners own the hardware, the pool decides what gets mined: the block template. That "
  },
  {
    "path": "/docs/mining/pools#choosing-a-pool",
    "title": "Choosing a Pool",
    "section": "mining",
    "body": "Factors to consider: Payout Method PPS/FPPS: Stable income, higher fees PPLNS: Variable income, lower fees, rewards loyalty Fees Range from 0% to 4% Consider fee vs payout method trade-off Minimum "
  },
  {
    "path": "/docs/mining/pools#pool-economics",
    "title": "Pool Economics",
    "section": "mining",
    "body": "Pool Revenue Block reward: 3.125 BTC Average transaction fees: 0.25 BTC ─────────────────────────────────── Total per block: 3.375 BTC Pool finds 10 blocks/day: Daily revenue: 33.75 BTC Pool Costs "
  },
  {
    "path": "/docs/mining/pools#setting-up-pool-mining",
    "title": "Setting Up Pool Mining",
    "section": "mining",
    "body": "This section covers connecting to a pool (e.g. Stratum), configuring payouts, and monitoring your contribution. Requirements Mining hardware: ASICs for Bitcoin (or CPU/GPU for testing) Pool account: "
  },
  {
    "path": "/docs/mining/pools#summary",
    "title": "Summary",
    "section": "mining",
    "body": "Mining pools solve the variance problem: Combine resources: Small miners can participate Regular payouts: Predictable income Shared risk: Pool absorbs variance (PPS) or shares it (PPLNS) Trade-offs: "
  },
  {
    "path": "/docs/mining/pools#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Mining Economics - Profitability calculations Block Construction - How blocks are built Proof-of-Work - The mining algorithm Hardware Evolution - Mining equipment history"
  },
  {
    "path": "/docs/mining/pools#resources",
    "title": "Resources",
    "section": "mining",
    "body": "Stratum V2 - Next-generation mining protocol Ocean - Non-custodial pool with DATUM (miner-built templates) Braidpool - Decentralized pool project Mining Pool Stats - Pool hashrate distribution"
  },
  {
    "path": "/docs/mining/hardware",
    "title": "Hardware Evolution",
    "section": "mining",
    "body": "Mining Hardware Evolution Bitcoin mining hardware has undergone a remarkable evolution, from hobbyists running CPUs on laptops to industrial-scale operations with purpose-built silicon. This progression represents one of the fastest hardware development cycles in computing history, driven by the economic incentives of proof-of-work mining. The Four Eras of Mining Hardware Era 1: CPU Mining (2009-2010) The Beginning When Satoshi launched Bitcoin, mining was done on ordinary computer CPUs: "
  },
  {
    "path": "/docs/mining/hardware#the-four-eras-of-mining-hardware",
    "title": "The Four Eras of Mining Hardware",
    "section": "mining",
    "body": "Era 1: CPU Mining (2009-2010) The Beginning When Satoshi launched Bitcoin, mining was done on ordinary computer CPUs: Hardware: Intel/AMD desktop processors Hashrate: 1-20 MH/s Power: 50-150W "
  },
  {
    "path": "/docs/mining/hardware#asic-evolution",
    "title": "ASIC Evolution",
    "section": "mining",
    "body": "Generation Timeline | Era | Example | Hashrate | Efficiency | Year | |-----|---------|----------|------------|------| | Gen 1 | Avalon 1 | 66 GH/s | 9,000 J/TH | 2013 | | Gen 2 | Antminer S1 | 180 "
  },
  {
    "path": "/docs/mining/hardware#efficiency-metrics",
    "title": "Efficiency Metrics",
    "section": "mining",
    "body": "Joules per Terahash (J/TH) The key efficiency metric: J/TH = Watts ÷ (Terahashes per second) Example: 3000W machine doing 100 TH/s Efficiency = 3000 ÷ 100 = 30 J/TH Lower is better. Modern machines: "
  },
  {
    "path": "/docs/mining/hardware#industrial-mining-operations",
    "title": "Industrial Mining Operations",
    "section": "mining",
    "body": "Scale Modern mining farms: Hashrate: 1-50 EH/s (exahashes per second) Power: 50-500 MW Machines: 10,000-100,000+ ASICs Investment: $100M-$1B+ Infrastructure Requirements Power Cheap electricity is "
  },
  {
    "path": "/docs/mining/hardware#home-mining",
    "title": "Home Mining",
    "section": "mining",
    "body": "Is It Viable? For most people in most places: marginally, or no. Challenges: Electricity costs ($0.10-0.30/kWh residential) Noise (70-80 dB, like a vacuum cleaner) Heat (3kW space heater per machine) "
  },
  {
    "path": "/docs/mining/hardware#the-asic-trap",
    "title": "The ASIC Trap",
    "section": "mining",
    "body": "No Escape Once ASICs exist, there's no going back: ASICs are 10,000x more efficient than GPUs GPU miners can't compete ASIC investment creates lock-in Algorithm changes would destroy investment ASIC "
  },
  {
    "path": "/docs/mining/hardware#future-trends",
    "title": "Future Trends",
    "section": "mining",
    "body": "Efficiency Limits Physical limits are approaching: 3nm/2nm processes: Near atomic scale Thermodynamic limits: Minimum energy per computation Diminishing returns: Each generation improves less "
  },
  {
    "path": "/docs/mining/hardware#summary",
    "title": "Summary",
    "section": "mining",
    "body": "The evolution of mining hardware: | Era | Technology | Efficiency Gain | Timeline | |-----|------------|-----------------|----------| | 1 | CPU | Baseline | 2009-2010 | | 2 | GPU | 10-50x | 2010-2013 "
  },
  {
    "path": "/docs/mining/hardware#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Proof-of-Work - What the hardware computes Mining Economics - Profitability analysis Mining Pools - How miners collaborate Difficulty Adjustment - How network responds to hashrate"
  },
  {
    "path": "/docs/mining/hardware#resources",
    "title": "Resources",
    "section": "mining",
    "body": "ASIC Miner Value - Profitability calculator Hashrate Index - Mining market data Cambridge Bitcoin Electricity Consumption Index - Network energy use"
  },
  {
    "path": "/docs/mining/attacks",
    "title": "Mining Attacks",
    "section": "mining",
    "body": "Mining Attacks Bitcoin's proof-of-work security model is designed to make attacks economically irrational. However, understanding potential attacks is crucial for appreciating Bitcoin's security properties and the incentives that protect the network. This section covers theoretical attacks on Bitcoin mining, their costs, and why they generally don't happen. The 51% Attack The most discussed attack on Bitcoin: what if someone controls more than half the network's hashrate? What It Enables With "
  },
  {
    "path": "/docs/mining/attacks#the-51-attack",
    "title": "The 51% Attack",
    "section": "mining",
    "body": "The most discussed attack on Bitcoin: what if someone controls more than half the network's hashrate? What It Enables With >50% hashrate, an attacker can: Double-spend: Reverse their own transactions "
  },
  {
    "path": "/docs/mining/attacks#selfish-mining",
    "title": "Selfish Mining",
    "section": "mining",
    "body": "A subtle attack where miners can gain unfair advantage with less than 50% hashrate. How It Works Normal mining: Find a block → immediately broadcast it Selfish mining: Find a block → keep it secret "
  },
  {
    "path": "/docs/mining/attacks#block-withholding-attack",
    "title": "Block Withholding Attack",
    "section": "mining",
    "body": "An attack by pool miners against their own pool. How It Works Miner joins a pool Submits partial shares (proving work) When finding a valid block, doesn't submit it Pool pays miner for shares but "
  },
  {
    "path": "/docs/mining/attacks#fee-sniping",
    "title": "Fee Sniping",
    "section": "mining",
    "body": "Miners stealing high-fee transactions from other miners' blocks. How It Works Block N contains a transaction with 10 BTC in fees (unusually high) Attacker sees Block N, thinks: \"If I mine an "
  },
  {
    "path": "/docs/mining/attacks#transaction-pinning",
    "title": "Transaction Pinning",
    "section": "mining",
    "body": "An attack relevant to Layer 2 protocols like Lightning. How It Works Attacker creates a low-fee transaction spending the same output Transaction is large, making CPFP expensive Victim's transaction "
  },
  {
    "path": "/docs/mining/attacks#time-warp-attack",
    "title": "Time-Warp Attack",
    "section": "mining",
    "body": "Exploiting timestamp manipulation over difficulty adjustment periods. How It Works Difficulty adjusts every 2016 blocks based on timestamps. Normal: 2016 blocks in 2 weeks → difficulty unchanged "
  },
  {
    "path": "/docs/mining/attacks#eclipse-attack",
    "title": "Eclipse Attack",
    "section": "mining",
    "body": "Isolating a node from the real network. How It Works Attacker surrounds victim with malicious nodes Victim only connects to attacker's nodes Attacker feeds victim a fake chain Victim accepts invalid "
  },
  {
    "path": "/docs/mining/attacks#finney-attack",
    "title": "Finney Attack",
    "section": "mining",
    "body": "Named after Hal Finney, this is a race between broadcasting blocks and transactions. How It Works Attacker mines block containing tx spending to themselves Keep block secret Spend same coins at "
  },
  {
    "path": "/docs/mining/attacks#goldfinger-attack",
    "title": "Goldfinger Attack",
    "section": "mining",
    "body": "Attack Bitcoin not for profit, but for destruction. Motivation Nation-state wanting to kill Bitcoin Competitor (central bank?) wanting to discredit crypto Ideological opposition Method Acquire "
  },
  {
    "path": "/docs/mining/attacks#summary",
    "title": "Summary",
    "section": "mining",
    "body": "Bitcoin's mining attacks show why the security model works: | Attack | Requirement | Profitability | Likelihood | |--------|-------------|---------------|------------| | 51% Attack | >50% hashrate | "
  },
  {
    "path": "/docs/mining/attacks#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "Proof-of-Work - The security mechanism Mining Economics - Why honest mining pays Difficulty Adjustment - How network responds Consensus Mechanism - How Bitcoin achieves agreement"
  },
  {
    "path": "/docs/mining/attacks#resources",
    "title": "Resources",
    "section": "mining",
    "body": "Selfish Mining Paper - Original academic analysis Bitcoin Security Model - Complete overview"
  },
  {
    "path": "/docs/mining/network-attacks",
    "title": "Network Attacks & Security",
    "section": "mining",
    "body": "Network Attacks & Security Bitcoin's P2P network faces various attack vectors. Understanding these attacks helps node operators secure their nodes and developers build resilient applications. Attack Types Eclipse Attacks Eclipse attacks isolate a node by controlling all its connections: Attack: Attacker controls many IP addresses Attacker connects to victim from all addresses Victim's connections are all to attacker Attacker controls what victim sees Victim sees fake blockchain state "
  },
  {
    "path": "/docs/mining/network-attacks#attack-types",
    "title": "Attack Types",
    "section": "mining",
    "body": "Eclipse Attacks Eclipse attacks isolate a node by controlling all its connections: Attack: Attacker controls many IP addresses Attacker connects to victim from all addresses Victim's connections are "
  },
  {
    "path": "/docs/mining/network-attacks#code-examples",
    "title": "Code Examples",
    "section": "mining",
    "body": "Detecting Eclipse Attack :::code-group use std::collections::HashSet; use std::net::IpAddr; fn detect_eclipse_attack(connected_ips: Vec) -> bool { // Check IP diversity let unique_ips: HashSet = "
  },
  {
    "path": "/docs/mining/network-attacks#partition-attacks",
    "title": "Partition Attacks",
    "section": "mining",
    "body": "Network Partition A network partition splits the network: Partition: Network A: Nodes 1-100 Network B: Nodes 101-200 Result: Two separate blockchains Eventually one wins (longest chain) Transactions "
  },
  {
    "path": "/docs/mining/network-attacks#denial-of-service-dos",
    "title": "Denial of Service (DoS)",
    "section": "mining",
    "body": "Transaction Flooding Attackers flood network with transactions: Attack: Create many low-fee transactions Fill mempool Legitimate transactions delayed Network congestion Mitigation: Fee-based "
  },
  {
    "path": "/docs/mining/network-attacks#best-practices",
    "title": "Best Practices",
    "section": "mining",
    "body": "For Node Operators Diverse connections: Connect to different IP ranges Monitor connections: Watch for suspicious patterns Use firewall: Limit exposure Keep software updated: Security patches For "
  },
  {
    "path": "/docs/mining/network-attacks#related-topics",
    "title": "Related Topics",
    "section": "mining",
    "body": "P2P Network Protocol - Network communication Mining Attacks - Mining-specific attacks Node Types - Node configurations"
  },
  {
    "path": "/docs/mining/network-attacks#resources",
    "title": "Resources",
    "section": "mining",
    "body": "Bitcoin Network Security"
  },
  {
    "path": "/docs/wallets",
    "title": "Wallet Development",
    "section": "wallets",
    "body": "Bitcoin Wallets Overview A Bitcoin wallet is a software application or device that allows users to store, send, and receive Bitcoin. Despite the name, a wallet doesn't actually \"store\" Bitcoin. Bitcoin exists only on the blockchain. Instead, a wallet stores the private keys needed to access and control Bitcoin addresses. Key Concepts Private Key: Secret cryptographic key that proves ownership of Bitcoin Public Key: Derived from private key, used to generate addresses Address: Public identifier "
  },
  {
    "path": "/docs/wallets#overview",
    "title": "Overview",
    "section": "wallets",
    "body": "A Bitcoin wallet is a software application or device that allows users to store, send, and receive Bitcoin. Despite the name, a wallet doesn't actually \"store\" Bitcoin. Bitcoin exists only on the "
  },
  {
    "path": "/docs/wallets#types-of-wallets",
    "title": "Types of Wallets",
    "section": "wallets",
    "body": "By Storage Location Hot Wallets Online: Connected to the internet Examples: Mobile apps, web wallets, exchange wallets Pros: Easy to use, quick access Cons: More vulnerable to hacking Cold Wallets "
  },
  {
    "path": "/docs/wallets#how-wallets-work",
    "title": "How Wallets Work",
    "section": "wallets",
    "body": "Key Generation Random Generation: Private key is randomly generated (256 bits) Public Key Derivation: Public key derived using elliptic curve cryptography Address Creation: Address generated from "
  },
  {
    "path": "/docs/wallets#creating-a-wallet",
    "title": "Creating a Wallet",
    "section": "wallets",
    "body": "Software Wallet (Bitcoin Core) Install Bitcoin Core Download from bitcoin.org Start Bitcoin Core (will create wallet.dat) bitcoind -daemon Create new wallet bitcoin-cli createwallet \"mywallet\" Get "
  },
  {
    "path": "/docs/wallets#wallet-security-best-practices",
    "title": "Wallet Security Best Practices",
    "section": "wallets",
    "body": "Private Key Management Never share: Never share your private keys or seed phrase Secure storage: Store seed phrases offline, physically secure Multiple backups: Create multiple backups in different "
  },
  {
    "path": "/docs/wallets#wallet-features",
    "title": "Wallet Features",
    "section": "wallets",
    "body": "Basic Features Send Bitcoin: Create and broadcast transactions Receive Bitcoin: Generate addresses for receiving View Balance: Check UTXO balance Transaction History: View past transactions Advanced "
  },
  {
    "path": "/docs/wallets#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "HD Wallets - Hierarchical deterministic wallet architecture Address Types - Understanding different Bitcoin address formats Coin Selection - How wallets choose UTXOs to spend Multisig - "
  },
  {
    "path": "/docs/wallets/hd-wallets",
    "title": "HD Wallets",
    "section": "wallets",
    "body": "HD Wallets Hierarchical Deterministic (HD) wallets generate all keys from a single master seed, enabling organized key management and simple backups. This is the foundation of modern Bitcoin wallet architecture. Overview HD wallets, defined in BIP32, allow a wallet to derive an unlimited number of key pairs from a single master seed. Combined with BIP39 (mnemonic phrases) and BIP44 (account structure), this creates a powerful and standardized wallet system. Key Benefits: Single backup (seed ",
    "keywords": [
      "hd wallet",
      "hierarchical deterministic wallet",
      "hd wallets",
      "bip32",
      "bip 32"
    ]
  },
  {
    "path": "/docs/wallets/hd-wallets#overview",
    "title": "Overview",
    "section": "wallets",
    "body": "HD wallets, defined in BIP32, allow a wallet to derive an unlimited number of key pairs from a single master seed. Combined with BIP39 (mnemonic phrases) and BIP44 (account structure), this creates a "
  },
  {
    "path": "/docs/wallets/hd-wallets#bip39-mnemonic-seed-phrases",
    "title": "BIP39: Mnemonic Seed Phrases",
    "section": "wallets",
    "body": "BIP39 defines how to generate human-readable seed phrases from random entropy. Mnemonic Generation Process Generate random entropy (128-256 bits) Calculate checksum (first bits of SHA256 hash) Append "
  },
  {
    "path": "/docs/wallets/hd-wallets#bip32-key-derivation",
    "title": "BIP32: Key Derivation",
    "section": "wallets",
    "body": "BIP32 defines how to derive child keys from parent keys using a hierarchical structure. Extended Keys Extended keys contain additional metadata for derivation: Extended Private Key (xprv): Can derive "
  },
  {
    "path": "/docs/wallets/hd-wallets#bip44-multi-account-hierarchy",
    "title": "BIP44: Multi-Account Hierarchy",
    "section": "wallets",
    "body": "BIP44 defines a standard account structure for HD wallets. Path Structure m / purpose' / coin_type' / account' / change / address_index | Level | Hardened | Description | "
  },
  {
    "path": "/docs/wallets/hd-wallets#watch-only-wallets",
    "title": "Watch-Only Wallets",
    "section": "wallets",
    "body": "Extended public keys (xpubs) enable watch-only wallets that can: Generate receiving addresses Monitor incoming transactions Calculate balances Without being able to spend funds (no private keys). "
  },
  {
    "path": "/docs/wallets/hd-wallets#security-best-practices",
    "title": "Security Best Practices",
    "section": "wallets",
    "body": "Seed Phrase Storage Physical backup: Write on paper or metal, store securely Never digital: Don't store on computers, phones, or cloud Multiple copies: Keep backups in separate locations Test "
  },
  {
    "path": "/docs/wallets/hd-wallets#gap-limit",
    "title": "Gap Limit",
    "section": "wallets",
    "body": "The gap limit determines how many unused addresses to scan before stopping. Default is typically 20. Important for wallet recovery: If you used addresses beyond the gap limit without using "
  },
  {
    "path": "/docs/wallets/hd-wallets#summary",
    "title": "Summary",
    "section": "wallets",
    "body": "HD wallets provide: Single backup: One seed phrase backs up all keys Organized structure: Hierarchical account and address management Watch-only capability: Monitor without spending ability "
  },
  {
    "path": "/docs/wallets/hd-wallets#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Wallets - Introduction to Bitcoin wallets Address Types - Understanding different Bitcoin address formats Key Management - Secure key generation and storage Cryptography - Elliptic curve "
  },
  {
    "path": "/docs/wallets/address-types",
    "title": "Address Types",
    "section": "wallets",
    "body": "Address Types Bitcoin has evolved through several address formats, each offering different features, security properties, and transaction costs. Understanding these types is essential for wallet development. Decode and inspect any address in the Address Decoder tool. Overview | Type | Prefix | Example Start | Introduced | |------|--------|---------------|------------| | P2PKH | 1 | 1BvBMSEYstW... | 2009 (Genesis) | | P2SH | 3 | 3J98t1WpEZ7... | 2012 (BIP16) | | P2WPKH | bc1q | bc1qw508d6q... | ",
    "keywords": [
      "p2pkh",
      "p2sh",
      "p2wpkh",
      "p2wsh",
      "p2tr",
      "address type",
      "address types"
    ]
  },
  {
    "path": "/docs/wallets/address-types#overview",
    "title": "Overview",
    "section": "wallets",
    "body": "| Type | Prefix | Example Start | Introduced | |------|--------|---------------|------------| | P2PKH | 1 | 1BvBMSEYstW... | 2009 (Genesis) | | P2SH | 3 | 3J98t1WpEZ7... | 2012 (BIP16) | | P2WPKH | "
  },
  {
    "path": "/docs/wallets/address-types#p2pkh-pay-to-public-key-hash",
    "title": "P2PKH (Pay-to-Public-Key-Hash)",
    "section": "wallets",
    "body": "The original Bitcoin address format, also known as \"legacy\" addresses. Structure scriptPubKey: OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG scriptSig: Address Generation :::code-group use bitcoin::{ "
  },
  {
    "path": "/docs/wallets/address-types#p2sh-pay-to-script-hash",
    "title": "P2SH (Pay-to-Script-Hash)",
    "section": "wallets",
    "body": "Introduced in BIP16, P2SH allows complex scripts to be represented by a simple hash. Structure scriptPubKey: OP_HASH160 OP_EQUAL scriptSig: Common Uses Multisig addresses (before SegWit) Nested "
  },
  {
    "path": "/docs/wallets/address-types#p2wpkh-native-segwit",
    "title": "P2WPKH (Native SegWit)",
    "section": "wallets",
    "body": "Introduced with SegWit in BIP141, P2WPKH provides significant fee savings. Structure scriptPubKey: OP_0 witness: Address Generation :::code-group use bitcoin::{ secp256k1::{Secp256k1, "
  },
  {
    "path": "/docs/wallets/address-types#p2wsh-pay-to-witness-script-hash",
    "title": "P2WSH (Pay-to-Witness-Script-Hash)",
    "section": "wallets",
    "body": "P2WSH is the SegWit version of P2SH, used for complex scripts like multisig. Structure scriptPubKey: OP_0 witness: Characteristics Size: 62 characters (bc1q + 59 chars) Input size: Variable (depends "
  },
  {
    "path": "/docs/wallets/address-types#p2tr-pay-to-taproot",
    "title": "P2TR (Pay-to-Taproot)",
    "section": "wallets",
    "body": "Introduced in BIP341, Taproot provides the best combination of privacy, efficiency, and flexibility. Structure Key path spend: scriptPubKey: OP_1 witness: Script path spend: witness: Address "
  },
  {
    "path": "/docs/wallets/address-types#comparison",
    "title": "Comparison",
    "section": "wallets",
    "body": "Transaction Size and Fees | Type | Input (vB) | Output (vB) | Relative Cost | |------|------------|-------------|---------------| | P2PKH | 148 | 34 | 100% (baseline) | | P2SH-P2WPKH | 91 | 32 | 62% "
  },
  {
    "path": "/docs/wallets/address-types#best-practices",
    "title": "Best Practices",
    "section": "wallets",
    "body": "For New Wallets Default to P2WPKH for single-sig (best balance of compatibility and fees) Use P2TR when Taproot support is widespread Avoid P2PKH for new addresses (higher fees) For Compatibility "
  },
  {
    "path": "/docs/wallets/address-types#summary",
    "title": "Summary",
    "section": "wallets",
    "body": "Bitcoin address types have evolved to provide: P2PKH: Original format, highest fees P2SH: Script flexibility, moderate fees P2WPKH: Native SegWit, lower fees P2TR: Taproot, lowest fees and best "
  },
  {
    "path": "/docs/wallets/address-types#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Wallets - Introduction to Bitcoin wallets HD Wallets - Hierarchical deterministic key derivation Coin Selection - How address types affect transaction fees Address Generation - Developer "
  },
  {
    "path": "/docs/wallets/transactions",
    "title": "Transaction Creation",
    "section": "wallets",
    "body": "Transaction Creation Creating Bitcoin transactions programmatically involves selecting inputs, creating outputs, calculating fees, signing, and broadcasting. This guide covers the complete process. Transaction Structure Basic Components Transaction: Version: 4 bytes Input Count: VarInt Inputs: Array of inputs Output Count: VarInt Outputs: Array of outputs Locktime: 4 bytes Witness: (if SegWit) Input Structure Input: Previous TXID: 32 bytes Previous Output Index: 4 bytes Script Length: VarInt "
  },
  {
    "path": "/docs/wallets/transactions#transaction-structure",
    "title": "Transaction Structure",
    "section": "wallets",
    "body": "Basic Components Transaction: Version: 4 bytes Input Count: VarInt Inputs: Array of inputs Output Count: VarInt Outputs: Array of outputs Locktime: 4 bytes Witness: (if SegWit) Input Structure Input: "
  },
  {
    "path": "/docs/wallets/transactions#step-by-step-process",
    "title": "Step-by-Step Process",
    "section": "wallets",
    "body": "Step 1: Select UTXOs Choose which UTXOs to spend: List available UTXOs bitcoin-cli listunspent Select UTXOs (coin selection algorithm) Total value >= payment + fee Step 2: Create Raw Transaction "
  },
  {
    "path": "/docs/wallets/transactions#fee-calculation",
    "title": "Fee Calculation",
    "section": "wallets",
    "body": "Estimating Transaction Size Base Transaction: Version: 4 bytes Input count: 1-9 bytes Output count: 1-9 bytes Locktime: 4 bytes Per Input: Previous output: 36 bytes Script length: 1-9 bytes Script: "
  },
  {
    "path": "/docs/wallets/transactions#change-outputs",
    "title": "Change Outputs",
    "section": "wallets",
    "body": "When to Create Change Create change output if: Input value > Payment + Fee + Dust Threshold Change amount > Dust threshold (546 sats) Change Output Creation Include change output bitcoin-cli "
  },
  {
    "path": "/docs/wallets/transactions#signing-process",
    "title": "Signing Process",
    "section": "wallets",
    "body": "Single Signature P2PKH: Script: P2WPKH: Witness: Multisig Signing Process: Create transaction Sign with first key Sign with second key (using partially signed tx) Continue until M signatures "
  },
  {
    "path": "/docs/wallets/transactions#transaction-validation",
    "title": "Transaction Validation",
    "section": "wallets",
    "body": "Before Broadcasting Check Inputs: Verify UTXOs are still unspent Verify Balance: Ensure sufficient funds Validate Fee: Check fee meets minimum Check Size: Ensure transaction is valid size Verify "
  },
  {
    "path": "/docs/wallets/transactions#best-practices",
    "title": "Best Practices",
    "section": "wallets",
    "body": "For Developers Fee Estimation: Accurate fee estimation is critical UTXO Management: Efficient coin selection Error Handling: Handle all error cases Validation: Validate before broadcasting Testing: "
  },
  {
    "path": "/docs/wallets/transactions#common-issues",
    "title": "Common Issues",
    "section": "wallets",
    "body": "Transaction Stuck Problem: Transaction not confirming Solutions: Wait for confirmation Use Replace-by-Fee (RBF) if enabled Increase fee (if possible) Wait for mempool to clear Insufficient Fee "
  },
  {
    "path": "/docs/wallets/transactions#advanced-topics",
    "title": "Advanced Topics",
    "section": "wallets",
    "body": "Replace-by-Fee (RBF) Enable RBF: Set sequence to enable RBF Sequence \": }]' Sign PSBT: bitcoin-cli walletprocesspsbt Finalize PSBT: bitcoin-cli finalizepsbt"
  },
  {
    "path": "/docs/wallets/transactions#summary",
    "title": "Summary",
    "section": "wallets",
    "body": "Transaction creation involves: UTXO Selection: Choose inputs to spend Output Creation: Create payment and change outputs Fee Calculation: Calculate appropriate fees Signing: Sign with private keys "
  },
  {
    "path": "/docs/wallets/transactions#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Wallets - Introduction to Bitcoin wallets Coin Selection - How wallets choose UTXOs to spend Multisig - Multi-signature transaction signing PSBT - Partially Signed Bitcoin Transactions "
  },
  {
    "path": "/docs/wallets/coin-selection",
    "title": "Coin Selection",
    "section": "wallets",
    "body": "Coin Selection Coin selection is the process of choosing which UTXOs (Unspent Transaction Outputs) to spend when creating a Bitcoin transaction. This is a critical wallet function that affects transaction fees, privacy, and efficiency. For a deeper understanding of the UTXO model, see the UTXO Model documentation. The Challenge Given: A set of available UTXOs A payment amount to send A target fee rate Select UTXOs such that: Total input value > total output value Fee rate >= required minimum "
  },
  {
    "path": "/docs/wallets/coin-selection#the-challenge",
    "title": "The Challenge",
    "section": "wallets",
    "body": "Given: A set of available UTXOs A payment amount to send A target fee rate Select UTXOs such that: Total input value > total output value Fee rate >= required minimum fee rate Transaction is valid "
  },
  {
    "path": "/docs/wallets/coin-selection#transaction-requirements",
    "title": "Transaction Requirements",
    "section": "wallets",
    "body": "Basic Structure Transaction: Inputs: Selected UTXOs Outputs: Payment output (destination + amount) Change output (optional, back to wallet) Fee: Inputs - Outputs Fee Rate Calculation Fee Rate = "
  },
  {
    "path": "/docs/wallets/coin-selection#utxo-characteristics",
    "title": "UTXO Characteristics",
    "section": "wallets",
    "body": "Different Script Types UTXOs can have different script types, affecting transaction size: | Type | Address Prefix | Input Size | |------|---------------|------------| | P2PKH (Legacy) | 1... | ~148 "
  },
  {
    "path": "/docs/wallets/coin-selection#coin-selection-strategies",
    "title": "Coin Selection Strategies",
    "section": "wallets",
    "body": "1. Largest First (Greedy) Algorithm: Sort UTXOs by value (largest first) Select UTXOs until sum >= payment + estimated fee Create change output if needed :::code-group fn select_largest_first( coins: "
  },
  {
    "path": "/docs/wallets/coin-selection#fee-calculation",
    "title": "Fee Calculation",
    "section": "wallets",
    "body": "Estimating Transaction Size Base Size: Transaction header: 10 bytes Input count: 1-9 bytes (varint) Output count: 1-9 bytes (varint) Input Size: Previous output: 36 bytes Script length: 1-9 bytes "
  },
  {
    "path": "/docs/wallets/coin-selection#change-output-creation",
    "title": "Change Output Creation",
    "section": "wallets",
    "body": "When to Create Change Create change output if: Selected UTXOs > Payment + Fee + Dust Threshold Change amount > dust threshold (typically 546 sats) Dust Threshold Dust outputs are uneconomical to "
  },
  {
    "path": "/docs/wallets/coin-selection#implementation-considerations",
    "title": "Implementation Considerations",
    "section": "wallets",
    "body": "Iterative Approach Estimate fee: Based on initial UTXO selection Select UTXOs: Using chosen strategy Calculate actual fee: Based on actual transaction size Adjust if needed: If fee doesn't meet "
  },
  {
    "path": "/docs/wallets/coin-selection#best-practices",
    "title": "Best Practices",
    "section": "wallets",
    "body": "For Wallet Developers Use SegWit: Prefer SegWit UTXOs (smaller size) Minimize inputs: Fewer inputs = smaller transaction Optimize change: Avoid dust change outputs Privacy: Consider privacy "
  },
  {
    "path": "/docs/wallets/coin-selection#common-issues",
    "title": "Common Issues",
    "section": "wallets",
    "body": "Insufficient Funds Problem: Selected UTXOs don't cover payment + fee Solution: Select more UTXOs Reduce payment amount Wait for more funds Fee Too Low Problem: Calculated fee rate below target "
  },
  {
    "path": "/docs/wallets/coin-selection#summary",
    "title": "Summary",
    "section": "wallets",
    "body": "Coin selection is a critical wallet function: Multiple strategies: Different approaches for different goals Fee optimization: Balance between fees and efficiency Privacy considerations: UTXO "
  },
  {
    "path": "/docs/wallets/coin-selection#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Wallets - Introduction to Bitcoin wallets Transaction Creation - How to create and sign transactions Address Types - Understanding different Bitcoin address formats Mempool - How unconfirmed "
  },
  {
    "path": "/docs/wallets/privacy",
    "title": "Privacy Techniques",
    "section": "wallets",
    "body": "Privacy Techniques Bitcoin transactions are pseudonymous, not anonymous. Various techniques can improve privacy by breaking the linkability between transactions and making blockchain analysis more difficult. Privacy Challenges Blockchain Analysis All transactions are public: Public Information: Transaction amounts Input/output addresses Transaction graph Timing patterns Common-Input-Ownership Heuristic Analysts assume all inputs to a transaction belong to the same entity: Transaction: Input 1: "
  },
  {
    "path": "/docs/wallets/privacy#privacy-challenges",
    "title": "Privacy Challenges",
    "section": "wallets",
    "body": "Blockchain Analysis All transactions are public: Public Information: Transaction amounts Input/output addresses Transaction graph Timing patterns Common-Input-Ownership Heuristic Analysts assume all "
  },
  {
    "path": "/docs/wallets/privacy#privacy-techniques",
    "title": "Privacy Techniques",
    "section": "wallets",
    "body": "1. CoinJoin CoinJoin combines multiple transactions into one: Standard Transaction: Alice → Bob: 1 BTC CoinJoin Transaction: Alice + Charlie + Dave → Bob + Eve + Frank: Mixed amounts Benefits: Breaks "
  },
  {
    "path": "/docs/wallets/privacy#code-examples",
    "title": "Code Examples",
    "section": "wallets",
    "body": "CoinJoin Implementation :::code-group use bitcoin::{Transaction, TxIn, TxOut}; struct CoinJoinParticipant { inputs: Vec, outputs: Vec, } fn create_coinjoin(participants: Vec) -> Transaction { let mut "
  },
  {
    "path": "/docs/wallets/privacy#advanced-privacy",
    "title": "Advanced Privacy",
    "section": "wallets",
    "body": "Silent Payments (BIP 352) Silent Payments enable reusable addresses without address reuse: Traditional: Recipient shares address Address reused → Privacy loss Silent Payments: Recipient shares static "
  },
  {
    "path": "/docs/wallets/privacy#best-practices",
    "title": "Best Practices",
    "section": "wallets",
    "body": "For Users Use HD wallets: Automatic address generation Avoid address reuse: Generate new addresses Consider CoinJoin: For high privacy needs Use Taproot: Better privacy by default Be careful with "
  },
  {
    "path": "/docs/wallets/privacy#limitations",
    "title": "Limitations",
    "section": "wallets",
    "body": "What Privacy Techniques Can't Do IP address: Network layer still reveals IP Timing analysis: Patterns can reveal links Amount analysis: Large amounts are distinctive Perfect anonymity: Not achievable "
  },
  {
    "path": "/docs/wallets/privacy#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Address Types - Understanding addresses Coin Selection - Privacy-aware selection Taproot - Better privacy Lightning Network - Off-chain privacy"
  },
  {
    "path": "/docs/wallets/privacy#resources",
    "title": "Resources",
    "section": "wallets",
    "body": "BIP 352: Silent Payments Wasabi Wallet - CoinJoin implementation JoinMarket - CoinJoin marketplace"
  },
  {
    "path": "/docs/wallets/multisig",
    "title": "Multisig",
    "section": "wallets",
    "body": "Multisig Multi-signature (multisig) wallets require multiple signatures to spend funds. This provides enhanced security, shared custody, and flexible access control. A multisig wallet requires M-of-N signatures: M: Minimum number of signatures required N: Total number of possible signers Example: 2-of-3 means 2 signatures from 3 possible keys Common configurations: 2-of-2 (two parties must both sign, e.g. partnership), 2-of-3 (two of three parties must sign, e.g. backup key), 3-of-5 (three of "
  },
  {
    "path": "/docs/wallets/multisig#multisig-script-patterns",
    "title": "Multisig Script Patterns",
    "section": "wallets",
    "body": "Legacy Multisig (P2SH) Script Pattern: OP_M ... OP_N OP_CHECKMULTISIG Example (2-of-3): OP_2 OP_3 OP_CHECKMULTISIG Spending Script: OP_0 Note: OP_0 is a bug workaround (dummy value before signatures) "
  },
  {
    "path": "/docs/wallets/multisig#creating-multisig-wallets",
    "title": "Creating Multisig Wallets",
    "section": "wallets",
    "body": "Using Bitcoin Core Step 1: Generate keys (each party does this) bitcoin-cli getnewaddress Step 2: Create 2-of-3 multisig address bitcoin-cli createmultisig 2 \\ '\"\", \"\", \"\"]' Step 3: Fund the multisig "
  },
  {
    "path": "/docs/wallets/multisig#spending-from-multisig",
    "title": "Spending from Multisig",
    "section": "wallets",
    "body": "Step 1: Create Transaction Create raw transaction bitcoin-cli createrawtransaction \\ '[{\"txid\":\"...\", \"vout\":0}]' \\ '{\"\": }' Step 2: Sign with First Key Sign with key 1 bitcoin-cli "
  },
  {
    "path": "/docs/wallets/multisig#key-management",
    "title": "Key Management",
    "section": "wallets",
    "body": "Key Storage Best Practices: Distributed: Each party stores their own key Secure: Use hardware wallets or secure storage Backup: Backup keys securely Recovery: Plan for key loss Key Security Options: "
  },
  {
    "path": "/docs/wallets/multisig#use-cases",
    "title": "Use Cases",
    "section": "wallets",
    "body": "1. Shared Custody Example: Business partnership 2-of-2: Both partners must agree Use case: Business funds Benefit: No single point of failure 2. Backup Security Example: Personal wallet with backup "
  },
  {
    "path": "/docs/wallets/multisig#security-considerations",
    "title": "Security Considerations",
    "section": "wallets",
    "body": "Advantages No Single Point of Failure: Multiple keys required Distributed Trust: No single party controls funds Backup Options: Can lose some keys Flexible Access: Different M-of-N configurations "
  },
  {
    "path": "/docs/wallets/multisig#implementation-details",
    "title": "Implementation Details",
    "section": "wallets",
    "body": "Script Execution Multisig Script: OP_2 OP_3 OP_CHECKMULTISIG Execution: Push M (2) Push pubkeys (3) Push N (3) OP_CHECKMULTISIG: Pops N, then N pubkeys Pops M, then M signatures Verifies M signatures "
  },
  {
    "path": "/docs/wallets/multisig#common-issues",
    "title": "Common Issues",
    "section": "wallets",
    "body": "Insufficient Signatures Problem: Not enough signatures to spend Solution: Collect required number of signatures Ensure all signers are available Use backup keys if needed Key Loss Problem: Too many "
  },
  {
    "path": "/docs/wallets/multisig#summary",
    "title": "Summary",
    "section": "wallets",
    "body": "Multisig wallets provide: Enhanced Security: Multiple keys required Shared Custody: Distributed control Backup Options: Can lose some keys Flexible Access: Various M-of-N configurations Corporate "
  },
  {
    "path": "/docs/wallets/multisig#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Wallets - Introduction to Bitcoin wallets Transaction Creation - How to create and sign transactions PSBT - Partially Signed Bitcoin Transactions for multisig coordination Bitcoin Script - "
  },
  {
    "path": "/docs/wallets/smart-contracts",
    "title": "Smart Contracts & Advanced Scripting",
    "section": "wallets",
    "body": "Smart Contracts & Advanced Scripting Bitcoin Script enables smart contracts through conditional spending. While intentionally limited (no loops, no complex state), Bitcoin's scripting system supports powerful contract patterns. Bitcoin smart contracts are spending conditions encoded in Script: Smart Contract = Locking Script + Unlocking Script Locking Script: Defines conditions Unlocking Script: Proves conditions are met See this in action in Stack Lab. Unlike Ethereum, Bitcoin contracts are: "
  },
  {
    "path": "/docs/wallets/smart-contracts#common-contract-patterns",
    "title": "Common Contract Patterns",
    "section": "wallets",
    "body": "1. Multisig Multiple signatures required: 2-of-3 Multisig: Requires 2 of 3 keys to sign More secure than single key Common for shared custody 2. Timelocks Time-based conditions: Escrow Contract: "
  },
  {
    "path": "/docs/wallets/smart-contracts#code-examples",
    "title": "Code Examples",
    "section": "wallets",
    "body": "Creating a Multisig Contract :::code-group use bitcoin::{Script, ScriptBuf}; use bitcoin::opcodes::all::*; fn create_multisig_script( pubkeys: &[u8; 33]; 3], threshold: u8, ) -> ScriptBuf { let mut "
  },
  {
    "path": "/docs/wallets/smart-contracts#advanced-patterns",
    "title": "Advanced Patterns",
    "section": "wallets",
    "body": "Vault Contracts Time-delayed recovery: Vault Structure: Hot key: Can spend immediately (small amount) Cold key: Can spend after delay (large amount) Recovery key: Can spend after longer delay Use "
  },
  {
    "path": "/docs/wallets/smart-contracts#taproot-contracts",
    "title": "Taproot Contracts",
    "section": "wallets",
    "body": "Taproot enables better contracts: Benefits: Privacy: Complex contracts look like simple payments Efficiency: Smaller transaction sizes Flexibility: MAST hides unused conditions"
  },
  {
    "path": "/docs/wallets/smart-contracts#miniscript",
    "title": "Miniscript",
    "section": "wallets",
    "body": "Miniscript is a structured language for expressing spending policies that compiles to Bitcoin Script. You describe what must hold (e.g., 2-of-3 keys, or \"key A and after block N\") and tools produce "
  },
  {
    "path": "/docs/wallets/smart-contracts#covenants-proposed",
    "title": "Covenants (Proposed)",
    "section": "wallets",
    "body": "Covenants are a proposed type of contract that would restrict how outputs can be spent in future transactions, for example, \"this UTXO may only be spent to addresses of type X\" or \"funds must pass "
  },
  {
    "path": "/docs/wallets/smart-contracts#limitations",
    "title": "Limitations",
    "section": "wallets",
    "body": "What Bitcoin Can't Do Complex state: No persistent contract state Loops: No iterative operations External data: No oracles (without DLCs) Turing-complete: Intentionally limited Why Limitations Exist "
  },
  {
    "path": "/docs/wallets/smart-contracts#best-practices",
    "title": "Best Practices",
    "section": "wallets",
    "body": "For Developers Use established patterns: Don't reinvent the wheel Test thoroughly: Script bugs are costly Consider Taproot: Better privacy and efficiency Document contracts: Explain conditions "
  },
  {
    "path": "/docs/wallets/smart-contracts#related-topics",
    "title": "Related Topics",
    "section": "wallets",
    "body": "Bitcoin Script - Script system OP Codes - Available operations Miniscript - Policy-to-script compiler Covenants - Proposed output-spend constraints Timelocks - Time-based conditions Multisig - "
  },
  {
    "path": "/docs/wallets/smart-contracts#resources",
    "title": "Resources",
    "section": "wallets",
    "body": "Bitcoin Script Patterns Miniscript - Policy to script compiler"
  },
  {
    "path": "/docs/lightning",
    "title": "Lightning Network",
    "section": "lightning",
    "body": "The Lightning Network The Lightning Network is a second-layer payment protocol built on top of Bitcoin. It enables instant, low-cost payments by creating a network of bidirectional payment channels between nodes. History The Lightning Network was proposed in 2015 by Joseph Poon and Thaddeus Dryja in their whitepaper \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments.\" The concept addresses Bitcoin's scalability limitations by moving most transactions off-chain while maintaining ",
    "keywords": [
      "lightning network",
      "ln",
      "lightning"
    ]
  },
  {
    "path": "/docs/lightning#history",
    "title": "History",
    "section": "lightning",
    "body": "The Lightning Network was proposed in 2015 by Joseph Poon and Thaddeus Dryja in their whitepaper \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments.\" The concept addresses Bitcoin's "
  },
  {
    "path": "/docs/lightning#key-concepts",
    "title": "Key Concepts",
    "section": "lightning",
    "body": "Payment Channels: Two-party channels that allow unlimited off-chain transactions Off-Chain Transactions: Payments settle instantly without blockchain confirmation HTLCs: Hash Time-Locked Contracts "
  },
  {
    "path": "/docs/lightning#how-it-works",
    "title": "How It Works",
    "section": "lightning",
    "body": "Open Channel: Two parties lock Bitcoin in a 2-of-2 multisig address Update Balance: Parties exchange signed commitment transactions to update the channel balance Route Payments: Payments can route "
  },
  {
    "path": "/docs/lightning#scalability",
    "title": "Scalability",
    "section": "lightning",
    "body": "The Lightning Network can theoretically handle millions of transactions per second because: Most transactions never touch the blockchain Channels can be reused for unlimited payments Network capacity "
  },
  {
    "path": "/docs/lightning#trade-offs",
    "title": "Trade-offs",
    "section": "lightning",
    "body": "| Aspect | On-Chain Bitcoin | Lightning Network | |--------|------------------|-------------------| | Speed | 10-60 minutes | Milliseconds | | Fees | Variable (1-100+ sats/vB) | Near zero | | "
  },
  {
    "path": "/docs/lightning#getting-started-with-lightning",
    "title": "Getting Started with Lightning",
    "section": "lightning",
    "body": "This section covers practical setup and operations for running a Lightning node. Prerequisites Bitcoin Node: Fully synced Bitcoin Core node Lightning Implementation: LND, CLN (Core Lightning), "
  },
  {
    "path": "/docs/lightning#opening-channels",
    "title": "Opening Channels",
    "section": "lightning",
    "body": "Connect to a Peer lncli connect @: Open a Channel Open a channel with 100,000 satoshis capacity lncli openchannel --node_key= --local_amt=100000 The channel opening process: Create funding "
  },
  {
    "path": "/docs/lightning#creating-and-paying-invoices",
    "title": "Creating and Paying Invoices",
    "section": "lightning",
    "body": "Create an Invoice Create invoice for 1000 satoshis lncli addinvoice --amt=1000 --memo=\"Coffee payment\" This returns a BOLT11 invoice string starting with lnbc (mainnet), lntb (testnet), or lntbs "
  },
  {
    "path": "/docs/lightning#node-operations",
    "title": "Node Operations",
    "section": "lightning",
    "body": "Get Node Info lncli getinfo Check Balances On-chain balance lncli walletbalance Channel balance lncli channelbalance List Connected Peers lncli listpeers"
  },
  {
    "path": "/docs/lightning#troubleshooting",
    "title": "Troubleshooting",
    "section": "lightning",
    "body": "Channel Not Opening Verify Bitcoin node is synced and ZMQ is configured Check you have sufficient on-chain balance Ensure peer is reachable and accepting channels Payment Failing No route found: "
  },
  {
    "path": "/docs/lightning#best-practices",
    "title": "Best Practices",
    "section": "lightning",
    "body": "Security Back up your channel state and wallet seed Use strong RPC credentials Keep Lightning software updated Consider running a watchtower Channel Management Open channels to well-connected nodes "
  },
  {
    "path": "/docs/lightning#next-steps",
    "title": "Next Steps",
    "section": "lightning",
    "body": "Learn about Payment Channels Routing Fees, HTLCs, and Multi-Part Payments Explore Onion Routing for privacy Invoices (BOLT11) and Offers (BOLT12) for payment requests and recurring payments"
  },
  {
    "path": "/docs/lightning#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT Specifications - Protocol specifications LND Documentation Core Lightning Documentation Lightning Network Whitepaper"
  },
  {
    "path": "/docs/lightning/channels",
    "title": "Channels",
    "section": "lightning",
    "body": "Lightning Payment Channels Payment channels are the fundamental building block of the Lightning Network. They enable off-chain transactions between two parties with on-chain settlement. A payment channel is a 2-of-2 multisig address that locks Bitcoin between two parties. The parties can update the channel balance off-chain without broadcasting to the Bitcoin network. Key properties: 2-of-2 Multisig: Both parties must sign to spend Off-Chain Updates: Balance changes happen instantly without ",
    "keywords": [
      "lightning channel",
      "payment channel",
      "channel"
    ]
  },
  {
    "path": "/docs/lightning/channels#channel-lifecycle",
    "title": "Channel Lifecycle",
    "section": "lightning",
    "body": "1. Channel Opening Funding Transaction: Creates 2-of-2 multisig output Locks Bitcoin from one or both parties Broadcast to Bitcoin network Wait for confirmation (typically 3-6 blocks) [Alice and Bob "
  },
  {
    "path": "/docs/lightning/channels#commitment-transactions",
    "title": "Commitment Transactions",
    "section": "lightning",
    "body": "Each commitment transaction represents the current channel state: [Commitment Transaction] ├── Input: Funding tx output 2-of-2 multisig ├── Alice balance to_local or to_remote ├── Bob balance "
  },
  {
    "path": "/docs/lightning/channels#channel-balance-queries",
    "title": "Channel Balance Queries",
    "section": "lightning",
    "body": ":::code-group use ldk_node::Node; /// Query channel balances using LDK fn get_channel_balances(node: &Node) -> (u64, u64) { let channels = node.list_channels(); let mut local_balance_msat: u64 = 0; "
  },
  {
    "path": "/docs/lightning/channels#channel-capacity-and-liquidity",
    "title": "Channel Capacity and Liquidity",
    "section": "lightning",
    "body": "Total Capacity Channel capacity equals the funding amount: Alice funds: 100,000 sats Bob funds: 0 sats (single-funded) Total capacity: 100,000 sats Liquidity Direction For routing payments, liquidity "
  },
  {
    "path": "/docs/lightning/channels#channel-splicing",
    "title": "Channel Splicing",
    "section": "lightning",
    "body": "Splicing (as specified in the Lightning BOLT process) allows you to add or remove on-chain capacity to or from an existing channel without closing it. That way you can top up or withdraw liquidity in "
  },
  {
    "path": "/docs/lightning/channels#channel-types",
    "title": "Channel Types",
    "section": "lightning",
    "body": "Public Channels Announced to the network gossip Appear in the public channel graph Can route payments for others Required for earning routing fees Private (Unannounced) Channels Not broadcast to the "
  },
  {
    "path": "/docs/lightning/channels#channel-security",
    "title": "Channel Security",
    "section": "lightning",
    "body": "Revocation Keys Each commitment state has an associated revocation key. If a party broadcasts an old state, the counterparty can: Detect the old commitment on-chain Use the revocation secret to "
  },
  {
    "path": "/docs/lightning/channels#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "Unbalanced Channels Problem: All funds on one side prevents bidirectional payments. Solutions: Circular rebalancing (pay yourself through the network) Submarine swaps (on-chain ↔ off-chain) Open "
  },
  {
    "path": "/docs/lightning/channels#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Payment channels enable: Instant transactions: No block confirmation needed Minimal fees: Fraction of on-chain costs Privacy: Off-chain activity not visible on blockchain Scalability: Unlimited "
  },
  {
    "path": "/docs/lightning/channels#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Routing Fees, HTLCs, and Multi-Part Payments - How payments route through channels Watchtowers - Third-party channel monitoring Anchor Outputs - Modern channel format for fee bumping and splicing"
  },
  {
    "path": "/docs/lightning/routing/htlc",
    "title": "HTLCs",
    "section": "lightning",
    "body": "Hash Time-Locked Contracts (HTLCs) HTLCs are the mechanism that enables payments to route through the Lightning Network. They ensure that payments can only be claimed with the correct preimage, and expire after a certain time if unclaimed. An HTLC is a conditional payment that requires: Hash Lock: Knowledge of a secret (preimage) that hashes to a known value Time Lock: Expires after a certain block height (CLTV) HTLC Conditions: If preimage is revealed before expiry → Payment goes to recipient ",
    "keywords": [
      "htlc",
      "hash time locked contract",
      "hash-time-locked-contract"
    ]
  },
  {
    "path": "/docs/lightning/routing/htlc#how-htlcs-work-in-lightning",
    "title": "How HTLCs Work in Lightning",
    "section": "lightning",
    "body": "Payment Flow Recipient generates preimage: Random 32-byte secret, shares SHA256 hash Sender creates HTLC chain: Locks funds with hash and decreasing expiries HTLCs propagate: Each hop creates an HTLC "
  },
  {
    "path": "/docs/lightning/routing/htlc#htlc-script-structure",
    "title": "HTLC Script Structure",
    "section": "lightning",
    "body": "HTLCs in commitment transactions use this script pattern: Offered HTLC (you're offering payment) OP_DUP OP_HASH160 OP_EQUAL OP_IF OP_CHECKSIG # Revocation path OP_ELSE OP_SWAP OP_SIZE 32 OP_EQUAL "
  },
  {
    "path": "/docs/lightning/routing/htlc#htlc-verification",
    "title": "HTLC Verification",
    "section": "lightning",
    "body": ":::code-group use sha2::{Sha256, Digest}; /// Represents an HTLC struct Htlc { payment_hash: [u8; 32], amount_msat: u64, cltv_expiry: u32, } impl Htlc { /// Verify a preimage against this HTLC's "
  },
  {
    "path": "/docs/lightning/routing/htlc#htlc-states",
    "title": "HTLC States",
    "section": "lightning",
    "body": "An HTLC in a channel transitions through these states: | State | Description | Outcome | |-------|-------------|---------| | Offered | Sent to peer, awaiting response | → Accepted or Failed | | "
  },
  {
    "path": "/docs/lightning/routing/htlc#htlc-security-properties",
    "title": "HTLC Security Properties",
    "section": "lightning",
    "body": "Atomicity Either the entire payment succeeds or fails completely: All HTLCs in the route share the same payment hash Revealing the preimage settles all HTLCs Timeout returns all funds to senders Hash "
  },
  {
    "path": "/docs/lightning/routing/htlc#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "HTLC Timeout Problem: HTLC expires before payment completes. Causes: Route too long (accumulated CLTV deltas) Slow intermediate nodes Network congestion Solutions: Increase max_cltv_expiry setting "
  },
  {
    "path": "/docs/lightning/routing/htlc#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "HTLCs are the atomic building blocks of Lightning payments: Hash locks ensure only the recipient can claim funds Time locks enable safe routing through untrusted intermediaries Decreasing expiries "
  },
  {
    "path": "/docs/lightning/routing/htlc#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Routing Fees - How routing fees work Multi-Part Payments - Splitting payments across routes Onion Routing - Privacy in payment routing"
  },
  {
    "path": "/docs/lightning/routing",
    "title": "Routing Fees",
    "section": "lightning",
    "body": "Lightning Routing Fees Lightning routing fees are how nodes earn income for forwarding payments. Understanding fee calculation is essential for both routing nodes and payment senders. Fee Structure Lightning fees consist of two components: Base Fee: Fixed fee per HTLC (in millisatoshis) Proportional Fee: Percentage of payment amount (in parts per million) Fee Formula Total Fee = Base Fee + (Payment Amount × Proportional Fee / 1,000,000) :::code-group /// Calculate the fee for forwarding an "
  },
  {
    "path": "/docs/lightning/routing#fee-structure",
    "title": "Fee Structure",
    "section": "lightning",
    "body": "Lightning fees consist of two components: Base Fee: Fixed fee per HTLC (in millisatoshis) Proportional Fee: Percentage of payment amount (in parts per million) Fee Formula Total Fee = Base Fee + "
  },
  {
    "path": "/docs/lightning/routing#routing-policy",
    "title": "Routing Policy",
    "section": "lightning",
    "body": "Each node advertises a routing policy that specifies: fee_base_msat: Base fee in millisatoshis fee_proportional_millionths: Proportional fee in parts per million cltv_delta: Required expiry delta (in "
  },
  {
    "path": "/docs/lightning/routing#fee-calculation-along-a-route",
    "title": "Fee Calculation Along a Route",
    "section": "lightning",
    "body": "When calculating fees for a multi-hop route, fees accumulate: Example Route Alice → Bob → Carol → Dave Payment: 100,000 sats Bob's Policy: Base: 1000 msat Proportional: 10 ppm Carol's Policy: Base: "
  },
  {
    "path": "/docs/lightning/routing#htlc-amount-calculation",
    "title": "HTLC Amount Calculation",
    "section": "lightning",
    "body": "For each hop, the HTLC amount includes: Original payment amount All fees accumulated up to that point Backward Calculation Starting from the final amount, work backwards: Final Amount (to Dave): "
  },
  {
    "path": "/docs/lightning/routing#integer-division",
    "title": "Integer Division",
    "section": "lightning",
    "body": "Important: Lightning uses integer division for fee calculation (as per BOLT 7). This means: Round down (floor) any fractional results No rounding up Can lead to small discrepancies Example Payment: "
  },
  {
    "path": "/docs/lightning/routing#fee-economics",
    "title": "Fee Economics",
    "section": "lightning",
    "body": "For Routing Nodes Revenue Sources: Base fees from each forwarded payment Proportional fees based on payment size Costs: Channel liquidity (locked capital) Risk of failed payments Operational costs "
  },
  {
    "path": "/docs/lightning/routing#fee-limits",
    "title": "Fee Limits",
    "section": "lightning",
    "body": "Maximum Fees There's no hard limit on fees, but: Very high fees reduce payment success Market forces keep fees reasonable Nodes compete for routing business Minimum Fees Some nodes set minimum fees "
  },
  {
    "path": "/docs/lightning/routing#fee-discovery",
    "title": "Fee Discovery",
    "section": "lightning",
    "body": "How Senders Find Fees Network Graph: Query network for channel policies Route Calculation: Calculate fees for potential routes Fee Comparison: Compare routes by total fee Route Selection: Choose "
  },
  {
    "path": "/docs/lightning/routing#best-practices",
    "title": "Best Practices",
    "section": "lightning",
    "body": "For Routing Nodes Competitive Pricing: Set fees that attract routing Monitor Market: Adjust fees based on network conditions Balance Channels: Maintain liquidity for routing Transparent Policies: "
  },
  {
    "path": "/docs/lightning/routing#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "Fees Too High Problem: Route has very high fees Solutions: Try different routes Use direct channels Split payment (MPP) Wait for better routing conditions Fees Not Calculated Correctly Problem: Fee "
  },
  {
    "path": "/docs/lightning/routing#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Lightning routing fees: Two components: Base fee + proportional fee Accumulate: Fees add up along the route Integer division: Use floor division for calculations Economic incentive: Rewards nodes for "
  },
  {
    "path": "/docs/lightning/routing#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "HTLCs - Hash Time-Locked Contracts that carry payments along the route Multi-Part Payments - Splitting payments across multiple routes Channels - How channels and liquidity affect routing Onion "
  },
  {
    "path": "/docs/lightning/routing/mpp",
    "title": "Multi-Part Payments",
    "section": "lightning",
    "body": "Multi-Part Payments (MPP) Multi-Part Payments allow splitting a single payment across multiple routes. This enables larger payments and improves success rates by utilizing multiple channels. Instead of sending one large payment through a single route, MPP splits the payment into multiple smaller parts that can take different routes. Example Single Payment (fails): Alice → Bob → Carol → Dave Amount: 500,000 sats Problem: Carol's channel only has 200,000 sats capacity MPP Payment (succeeds): "
  },
  {
    "path": "/docs/lightning/routing/mpp#why-use-mpp",
    "title": "Why Use MPP?",
    "section": "lightning",
    "body": "Benefits Larger Payments: Can send amounts larger than any single channel Higher Success Rate: Multiple routes increase chance of success Better Liquidity Utilization: Use multiple channels "
  },
  {
    "path": "/docs/lightning/routing/mpp#how-mpp-works",
    "title": "How MPP Works",
    "section": "lightning",
    "body": "Payment Splitting Determine Split: Divide payment into multiple parts Find Routes: Find routes for each part Send Simultaneously: Send all parts at once Wait for All: Wait for all parts to complete "
  },
  {
    "path": "/docs/lightning/routing/mpp#tlv-encoding-for-mpp",
    "title": "TLV Encoding for MPP",
    "section": "lightning",
    "body": "MPP payments include special TLV (Type-Length-Value) fields in the final hop of each route. Payment Data TLV Type: 8 Length: 40 bytes Value (40 bytes): 32 bytes: payment_secret (payment_address) 8 "
  },
  {
    "path": "/docs/lightning/routing/mpp#mpp-implementation",
    "title": "MPP Implementation",
    "section": "lightning",
    "body": "Step 1: Simple Route For single-path payments, no MPP TLV is needed: Route: Alice → Bob → Carol → Dave Amount: 100,000 sats TLV: NULL (no MPP field) Step 2: Multi-Path Payment For multi-path "
  },
  {
    "path": "/docs/lightning/routing/mpp#payment-secret",
    "title": "Payment Secret",
    "section": "lightning",
    "body": "The payment secret (also called payment_address) is: 32 bytes: Random value generated by recipient Same for all parts: All MPP parts use the same secret Verification: Recipient verifies all parts use "
  },
  {
    "path": "/docs/lightning/routing/mpp#total-amount",
    "title": "Total Amount",
    "section": "lightning",
    "body": "The total_msat field specifies: Total payment: Sum of all MPP parts Verification: Recipient verifies sum matches invoice Same for all parts: All parts include the same total 8 bytes: uint64 in "
  },
  {
    "path": "/docs/lightning/routing/mpp#example-3-path-mpp",
    "title": "Example: 3-Path MPP",
    "section": "lightning",
    "body": "Invoice Details Invoice Amount: 120,000 sats Payment Secret: b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066 Route Calculation Path 0: Alice → Bob → Carol → Dave Amount per path: "
  },
  {
    "path": "/docs/lightning/routing/mpp#verification",
    "title": "Verification",
    "section": "lightning",
    "body": "Recipient Verification The recipient verifies: All parts received: All MPP parts arrived Same secret: All parts use same payment_secret Correct total: Sum of parts equals total_msat Valid preimage: "
  },
  {
    "path": "/docs/lightning/routing/mpp#best-practices",
    "title": "Best Practices",
    "section": "lightning",
    "body": "For Senders Equal Splitting: Start with equal splits Route Quality: Use best available routes Monitor Progress: Track all parts Handle Failures: Retry failed parts if needed For Recipients Wait for "
  },
  {
    "path": "/docs/lightning/routing/mpp#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "Partial Payment Received Problem: Only some MPP parts succeed Solution: Wait for timeout Request remaining parts Or cancel and retry TLV Encoding Errors Problem: TLV not encoded correctly Solution: "
  },
  {
    "path": "/docs/lightning/routing/mpp#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Multi-Part Payments enable: Larger payments: Split across multiple routes Better success rates: Multiple paths increase reliability Liquidity utilization: Use multiple channels TLV encoding: Payment "
  },
  {
    "path": "/docs/lightning/invoices",
    "title": "Invoices (BOLT11)",
    "section": "lightning",
    "body": "Lightning Invoices (BOLT11) Lightning invoices are payment requests encoded in the BOLT11 format. They contain all the information a payer needs to send a payment, including the payment hash, amount, destination, and expiry. Invoice Structure A BOLT11 invoice consists of three parts: Human-Readable Part (HRP): Network prefix and amount Data Part: Encoded payment details Signature: Proves invoice authenticity Example Invoice: ",
    "keywords": [
      "invoice",
      "bolt11",
      "bolt 11",
      "lightning invoice"
    ]
  },
  {
    "path": "/docs/lightning/invoices#invoice-structure",
    "title": "Invoice Structure",
    "section": "lightning",
    "body": "A BOLT11 invoice consists of three parts: Human-Readable Part (HRP): Network prefix and amount Data Part: Encoded payment details Signature: Proves invoice authenticity Example Invoice: "
  },
  {
    "path": "/docs/lightning/invoices#human-readable-part",
    "title": "Human-Readable Part",
    "section": "lightning",
    "body": "Network Prefixes | Prefix | Network | |--------|---------| | lnbc | Bitcoin mainnet | | lntb | Bitcoin testnet | | lntbs | Bitcoin signet | | lnbcrt | Bitcoin regtest | Amount Encoding | Suffix | "
  },
  {
    "path": "/docs/lightning/invoices#data-part-fields",
    "title": "Data Part Fields",
    "section": "lightning",
    "body": "The data section uses tagged fields in TLV (Type-Length-Value) format: | Tag | Field | Description | |-----|-------|-------------| | p | Payment Hash | 52 chars, SHA256 of preimage | | s | Payment "
  },
  {
    "path": "/docs/lightning/invoices#parsing-invoices",
    "title": "Parsing Invoices",
    "section": "lightning",
    "body": ":::code-group use bech32::{self, FromBase32}; use sha2::{Sha256, Digest}; /// Parsed BOLT11 invoice fields #[derive(Debug)] struct ParsedInvoice { network: String, amount_msat: Option, payment_hash: "
  },
  {
    "path": "/docs/lightning/invoices#creating-invoices",
    "title": "Creating Invoices",
    "section": "lightning",
    "body": "Using lncli: Create invoice for 10,000 sats with description lncli addinvoice --amt=10000 --memo=\"Payment for coffee\" Create invoice with specific expiry (1 hour) lncli addinvoice --amt=50000 "
  },
  {
    "path": "/docs/lightning/invoices#invoice-expiry",
    "title": "Invoice Expiry",
    "section": "lightning",
    "body": "Invoices have a default expiry of 1 hour (3600 seconds). After expiry: Invoice should not be paid Payment hash may be reused by recipient Sender's wallet should reject expired invoices Common expiry "
  },
  {
    "path": "/docs/lightning/invoices#route-hints",
    "title": "Route Hints",
    "section": "lightning",
    "body": "Private channels require route hints to be payable: [Route Hint Structure] ├── Node ID 33 bytes ├── Short Channel ID 8 bytes ├── Fee Base 4 bytes ├── Fee Proportional 4 bytes └── CLTV Expiry Delta 2 "
  },
  {
    "path": "/docs/lightning/invoices#payment-secret-s-field",
    "title": "Payment Secret (s field)",
    "section": "lightning",
    "body": "The payment secret (added in BOLT11 amendment): 32 bytes of random data Prevents payment probing attacks Required for Multi-Part Payments (MPP) Proves payer has the actual invoice"
  },
  {
    "path": "/docs/lightning/invoices#feature-bits",
    "title": "Feature Bits",
    "section": "lightning",
    "body": "The 9 field encodes supported features: | Bit | Feature | |-----|---------| | 8/9 | TLV onion payload | | 14/15 | Payment secret required | | 16/17 | Basic MPP | | 24/25 | Keysend |"
  },
  {
    "path": "/docs/lightning/invoices#bolt12-and-offers",
    "title": "BOLT12 and Offers",
    "section": "lightning",
    "body": "BOLT12 extends the Lightning payment model with offers and invoice requests. Unlike BOLT11, where the payee creates an invoice when they want to be paid, BOLT12 offers are static, reusable "
  },
  {
    "path": "/docs/lightning/invoices#common-patterns",
    "title": "Common Patterns",
    "section": "lightning",
    "body": "Reusable Invoices Standard BOLT11 invoices should only be paid once. For reusable or dynamic payments: Use Keysend (no invoice needed) Use LNURL-pay (dynamic invoice generation) Use Offers (BOLT12) "
  },
  {
    "path": "/docs/lightning/invoices#validation-checklist",
    "title": "Validation Checklist",
    "section": "lightning",
    "body": "When receiving an invoice, verify: Network matches your node (mainnet/testnet) Not expired (current time < timestamp + expiry) Amount is acceptable (if specified) Features are supported by your node "
  },
  {
    "path": "/docs/lightning/invoices#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "BOLT11 invoices provide: Standardized format for payment requests Amount encoding from pico-BTC to whole BTC Expiry handling to prevent stale payments Route hints for private channel payments Payment "
  },
  {
    "path": "/docs/lightning/invoices#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Offers (BOLT12) - Offers, invoice requests, and reusable payment flows Multi-Part Payments - Splitting large payments Channels - Where payments flow HTLCs - Payment mechanism"
  },
  {
    "path": "/docs/lightning/invoices#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT 11 Specification Lightning Invoice Decoder - Online tool"
  },
  {
    "path": "/docs/lightning/bolt12-offers",
    "title": "Offers (BOLT12)",
    "section": "lightning",
    "body": "Lightning Offers (BOLT12) BOLT12 is a Lightning protocol extension that introduces offers (and related structures such as invoice requests and refunds) as a more flexible alternative to BOLT11 invoices. Offers allow payers to request an invoice from a payee without the payee having to be online first, support reusable payment identifiers, and enable use cases like recurring payments and better keysend-style flows. BOLT11 vs BOLT12 | Aspect | BOLT11 (Invoices) | BOLT12 (Offers) | ",
    "keywords": [
      "bolt12",
      "bolt 12",
      "offers",
      "lightning offers"
    ]
  },
  {
    "path": "/docs/lightning/bolt12-offers#bolt11-vs-bolt12",
    "title": "BOLT11 vs BOLT12",
    "section": "lightning",
    "body": "| Aspect | BOLT11 (Invoices) | BOLT12 (Offers) | |--------|-------------------|------------------| | Creation | Payee creates invoice when they want to be paid | Payee creates offer (can be static, "
  },
  {
    "path": "/docs/lightning/bolt12-offers#offers",
    "title": "Offers",
    "section": "lightning",
    "body": "An offer is a signed, self-describing payment request that: Identifies the payee (node public key) May fix an amount or allow any amount Can specify metadata (description, chain, etc.) Can require "
  },
  {
    "path": "/docs/lightning/bolt12-offers#invoice-requests",
    "title": "Invoice Requests",
    "section": "lightning",
    "body": "To pay via an offer, the payer sends an invoice request to the payee. The invoice request: References the offer (or its contents) Can specify or refine the amount (if the offer allows any amount) Can "
  },
  {
    "path": "/docs/lightning/bolt12-offers#keysend-and-spontaneous-payments",
    "title": "Keysend and Spontaneous Payments",
    "section": "lightning",
    "body": "Keysend (BOLT11-era) allows sending to a node public key without a pre-made invoice: the payer chooses the payment hash (and preimage) and the recipient must accept it. BOLT12 offers and invoice "
  },
  {
    "path": "/docs/lightning/bolt12-offers#recurring-and-subscription-payments",
    "title": "Recurring and Subscription Payments",
    "section": "lightning",
    "body": "Because offers can be reusable, a payee can publish one offer that generates a new invoice for each payment. Examples: Subscriptions: Same offer each period; payer sends an invoice request with the "
  },
  {
    "path": "/docs/lightning/bolt12-offers#refunds",
    "title": "Refunds",
    "section": "lightning",
    "body": "BOLT12 defines refund flow: the payee can issue a refund (a kind of offer or invoice that pays from the payee to the payer). This is useful when the payee needs to return funds (e.g., cancelled "
  },
  {
    "path": "/docs/lightning/bolt12-offers#blinded-paths-and-privacy",
    "title": "Blinded Paths and Privacy",
    "section": "lightning",
    "body": "To request an invoice from an offer, the payer must reach the payee. BOLT12 can use blinded paths (onion-routed, blinded identifiers) so that the payer does not need to know the payee’s direct node "
  },
  {
    "path": "/docs/lightning/bolt12-offers#current-support",
    "title": "Current Support",
    "section": "lightning",
    "body": "Core Lightning (CLN): Full BOLT12 support (offers, invoice requests, refunds). LDK: Offer and invoice-request support for use in wallets and services. LND: BOLT12 support is in progress or partial; "
  },
  {
    "path": "/docs/lightning/bolt12-offers#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Invoices (BOLT11) - Classic Lightning invoices Lightning Channels - Channel mechanics Routing & HTLCs - How payments are routed Onion Routing - Privacy and blinded paths"
  },
  {
    "path": "/docs/lightning/bolt12-offers#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT 12: Offer Encoding Core Lightning BOLT12 LDK: Offers"
  },
  {
    "path": "/docs/lightning/onion",
    "title": "Onion Routing",
    "section": "lightning",
    "body": "Lightning Onion Routing Lightning Network uses Sphinx onion routing to provide privacy and security for payments. Each hop in a route only knows the previous and next hop, not the full route or payment details. Onion routing encrypts data in layers, like an onion. Each hop peels off one layer, revealing only the information needed for that hop to forward the payment. Key properties: Privacy: Each hop only knows immediate neighbors Integrity: HMACs prevent tampering Source Hiding: Sender ",
    "keywords": [
      "onion routing",
      "onion",
      "sphinx"
    ]
  },
  {
    "path": "/docs/lightning/onion#sphinx-protocol",
    "title": "Sphinx Protocol",
    "section": "lightning",
    "body": "Lightning uses the Sphinx protocol (adapted from Tor's design) for payment routing. It provides: Compact fixed-size packets (1300 bytes) Per-hop payload encryption Replay attack protection Forward "
  },
  {
    "path": "/docs/lightning/onion#onion-packet-components",
    "title": "Onion Packet Components",
    "section": "lightning",
    "body": "| Field | Size | Description | |-------|------|-------------| | Version | 1 byte | Protocol version (currently 0) | | Public Key | 33 bytes | Ephemeral public key for ECDH | | Payload | 1300 bytes | "
  },
  {
    "path": "/docs/lightning/onion#shared-secret-derivation",
    "title": "Shared Secret Derivation",
    "section": "lightning",
    "body": ":::code-group use secp256k1::{PublicKey, SecretKey, Secp256k1}; use sha2::{Sha256, Digest}; /// Derive shared secret using ECDH fn derive_shared_secret( ephemeral_secret: &SecretKey, hop_pubkey: "
  },
  {
    "path": "/docs/lightning/onion#encryption-process",
    "title": "Encryption Process",
    "section": "lightning",
    "body": "Layer Construction (Sender) For a 3-hop route (Alice → Bob → Carol → Dave): Generate ephemeral keypair Compute shared secrets with all hops using ECDH Build payloads for each hop Encrypt from "
  },
  {
    "path": "/docs/lightning/onion#privacy-guarantees",
    "title": "Privacy Guarantees",
    "section": "lightning",
    "body": "Information Visibility | Information | Sender | Intermediate | Final Hop | |-------------|--------|--------------|-----------| | Full route | Yes | No | No | | Sender identity | Yes | No | No | | "
  },
  {
    "path": "/docs/lightning/onion#fixed-packet-size",
    "title": "Fixed Packet Size",
    "section": "lightning",
    "body": "All onion packets are exactly 1366 bytes regardless of route length: Prevents traffic analysis based on packet size Unused space filled with random padding Maximum 20 hops supported"
  },
  {
    "path": "/docs/lightning/onion#security-properties",
    "title": "Security Properties",
    "section": "lightning",
    "body": "Integrity HMAC-SHA256 at each layer Tampering detected immediately Modified packets rejected Forward Secrecy Ephemeral keys used per-payment Past payments cannot be decrypted if keys compromised "
  },
  {
    "path": "/docs/lightning/onion#common-failure-modes",
    "title": "Common Failure Modes",
    "section": "lightning",
    "body": "HMAC Mismatch Payment fails with BADONION error. Causes: Packet corruption Incorrect key derivation Implementation bug Invalid Onion Version If version byte is not 0, packet is rejected. Packet Too "
  },
  {
    "path": "/docs/lightning/onion#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Onion routing provides Lightning's privacy layer: Source privacy: Sender hidden from all hops Path privacy: Full route never revealed Amount privacy: Intermediaries don't know total payment Fixed "
  },
  {
    "path": "/docs/lightning/onion#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Routing & HTLCs - Payment routing mechanics Trampoline Routing - Delegated pathfinding Invoices (BOLT11) - Payment request format"
  },
  {
    "path": "/docs/lightning/onion#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT 4: Onion Routing Protocol Sphinx Paper - Original protocol"
  },
  {
    "path": "/docs/lightning/watchtowers",
    "title": "Watchtowers",
    "section": "lightning",
    "body": "Watchtowers Watchtowers are third-party services that monitor the Bitcoin blockchain for channel breaches on your behalf. They provide security for Lightning nodes that cannot be online 24/7. Why Watchtowers? Lightning channels rely on both parties being able to detect and respond to cheating attempts. If your counterparty broadcasts an old commitment transaction, you must respond with a penalty transaction before the timelock expires. The Problem: If your node is offline when a breach occurs, "
  },
  {
    "path": "/docs/lightning/watchtowers#why-watchtowers",
    "title": "Why Watchtowers?",
    "section": "lightning",
    "body": "Lightning channels rely on both parties being able to detect and respond to cheating attempts. If your counterparty broadcasts an old commitment transaction, you must respond with a penalty "
  },
  {
    "path": "/docs/lightning/watchtowers#how-watchtowers-work",
    "title": "How Watchtowers Work",
    "section": "lightning",
    "body": "Registration Your node generates encrypted breach hints for each channel state You send these hints to a watchtower The watchtower stores them without knowing your channel details Monitoring "
  },
  {
    "path": "/docs/lightning/watchtowers#breach-hint-structure",
    "title": "Breach Hint Structure",
    "section": "lightning",
    "body": "Breach hints allow watchtowers to detect breaches without knowing channel details: [Breach Hint] ├── Locator (16 bytes): SHA256(breach_txid)[0:16] ├── Encrypted Blob: AES-encrypted penalty tx └── "
  },
  {
    "path": "/docs/lightning/watchtowers#privacy-considerations",
    "title": "Privacy Considerations",
    "section": "lightning",
    "body": "Well-designed watchtower protocols preserve privacy: | Information | Known to Watchtower | |-------------|---------------------| | Channel partners | No (encrypted) | | Channel capacity | No "
  },
  {
    "path": "/docs/lightning/watchtowers#watchtower-implementations",
    "title": "Watchtower Implementations",
    "section": "lightning",
    "body": "LND Watchtower (wtclient/wtserver) LND includes built-in watchtower support: Enable watchtower client in lnd.conf [wtclient] wtclient.active=true Connect to a watchtower lncli wtclient add @: List "
  },
  {
    "path": "/docs/lightning/watchtowers#watchtower-economics",
    "title": "Watchtower Economics",
    "section": "lightning",
    "body": "Costs For tower operators: Storage: ~200-500 bytes per channel state Bandwidth: Monitoring blockchain and receiving hints Computation: Checking transactions against hints For users: Bandwidth: "
  },
  {
    "path": "/docs/lightning/watchtowers#backup-strategies",
    "title": "Backup Strategies",
    "section": "lightning",
    "body": "Watchtowers complement but don't replace proper backups: What Watchtowers Protect Against Counterparty broadcasting old state while you're offline Short-term node downtime Network connectivity issues "
  },
  {
    "path": "/docs/lightning/watchtowers#watchtower-selection",
    "title": "Watchtower Selection",
    "section": "lightning",
    "body": "When choosing watchtowers, consider: Reliability Uptime track record Geographic distribution Infrastructure quality Privacy Protocol used (encrypted blobs?) Data retention policy Logging practices "
  },
  {
    "path": "/docs/lightning/watchtowers#protocol-variants",
    "title": "Protocol Variants",
    "section": "lightning",
    "body": "BOLT Draft (Original) The original watchtower proposal (never finalized as BOLT): Simple locator-based matching Single tower per channel Basic encrypted blobs TEOS Protocol Enhanced protocol with: "
  },
  {
    "path": "/docs/lightning/watchtowers#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "Tower Unreachable Problem: Cannot connect to watchtower. Solutions: Check network connectivity Verify tower address/port Try alternative towers Run your own tower Hint Upload Failures Problem: Failed "
  },
  {
    "path": "/docs/lightning/watchtowers#setup-example-lnd",
    "title": "Setup Example (LND)",
    "section": "lightning",
    "body": "Complete setup for watchtower protection: 1. Enable watchtower client Add to lnd.conf: [wtclient] wtclient.active=true 2. Restart LND systemctl restart lnd 3. Add public watchtowers lncli wtclient "
  },
  {
    "path": "/docs/lightning/watchtowers#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Watchtowers provide: Offline protection: Monitor blockchain when your node is down Automated response: Broadcast penalties without manual intervention Privacy preservation: Encrypted hints protect "
  },
  {
    "path": "/docs/lightning/watchtowers#best-practices",
    "title": "Best Practices",
    "section": "lightning",
    "body": "Use multiple watchtowers from different operators Run your own tower if possible for maximum privacy Verify tower reliability before trusting with real funds Combine with backups for complete "
  },
  {
    "path": "/docs/lightning/watchtowers#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Channels - Channel security and force close Anchor Outputs - Fee bumping for penalties"
  },
  {
    "path": "/docs/lightning/watchtowers#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT Draft: Watchtower Protocol LND Watchtower Documentation The Eye of Satoshi"
  },
  {
    "path": "/docs/lightning/anchor-outputs",
    "title": "Anchor Outputs",
    "section": "lightning",
    "body": "Anchor Outputs Anchor outputs are a modern channel format that allows commitment transactions to have their fees adjusted after broadcast. This solves the fee estimation problem in Lightning channels. The Fee Problem In original Lightning channels, commitment transaction fees were set at channel creation: Problems: Fees must be pre-committed before broadcast Can't predict future fee rates accurately High pre-set fees waste money during low congestion Low pre-set fees may cause transactions to "
  },
  {
    "path": "/docs/lightning/anchor-outputs#the-fee-problem",
    "title": "The Fee Problem",
    "section": "lightning",
    "body": "In original Lightning channels, commitment transaction fees were set at channel creation: Problems: Fees must be pre-committed before broadcast Can't predict future fee rates accurately High pre-set "
  },
  {
    "path": "/docs/lightning/anchor-outputs#how-anchor-outputs-work",
    "title": "How Anchor Outputs Work",
    "section": "lightning",
    "body": "Anchor outputs solve this by: Setting commitment transaction fees to minimum (1 sat/vB) Adding small \"anchor\" outputs that either party can spend Using CPFP (Child Pays for Parent) to boost fees at "
  },
  {
    "path": "/docs/lightning/anchor-outputs#anchor-output-structure",
    "title": "Anchor Output Structure",
    "section": "lightning",
    "body": "Each anchor output is exactly 330 satoshis with this script: OP_CHECKSIG OP_IFDUP OP_NOTIF OP_16 OP_CHECKSEQUENCEVERIFY OP_ENDIF This means: Owner can spend immediately with their signature Anyone "
  },
  {
    "path": "/docs/lightning/anchor-outputs#cpfp-fee-bumping",
    "title": "CPFP Fee Bumping",
    "section": "lightning",
    "body": "Child Pays for Parent (CPFP) allows boosting parent transaction fees: Broadcast commitment tx (low fee) Create child transaction spending anchor Child includes additional UTXO for fees Child pays "
  },
  {
    "path": "/docs/lightning/anchor-outputs#channel-types",
    "title": "Channel Types",
    "section": "lightning",
    "body": "Lightning supports multiple channel types negotiated at open: | Type | Feature Bit | Anchors | Zero-Fee HTLC | |------|-------------|---------|---------------| | Legacy | - | No | No | | Static "
  },
  {
    "path": "/docs/lightning/anchor-outputs#reserve-requirements",
    "title": "Reserve Requirements",
    "section": "lightning",
    "body": "Anchor channels require keeping a UTXO reserve for fee bumping: Recommended reserve: At least 1 UTXO per channel Size: Enough for emergency fee bump (10,000+ sats) Separate from channel funds "
  },
  {
    "path": "/docs/lightning/anchor-outputs#implementation-lnd",
    "title": "Implementation (LND)",
    "section": "lightning",
    "body": "Opening Anchor Channels Open channel requesting anchors (default in modern LND) lncli openchannel --node_key= --local_amt=100000 Explicitly request anchors lncli openchannel --node_key= "
  },
  {
    "path": "/docs/lightning/anchor-outputs#migration",
    "title": "Migration",
    "section": "lightning",
    "body": "Upgrading Existing Channels Existing non-anchor channels cannot be upgraded in place. Options: Close and reopen: Cooperative close, then open new anchor channel Splice (when available): Modify "
  },
  {
    "path": "/docs/lightning/anchor-outputs#trade-offs",
    "title": "Trade-offs",
    "section": "lightning",
    "body": "Advantages Fee flexibility: Adjust fees at broadcast time No stuck transactions: Can always bump fees higher Lower dust exposure: HTLC outputs can be smaller Safer force closes: Respond to fee spikes "
  },
  {
    "path": "/docs/lightning/anchor-outputs#common-issues",
    "title": "Common Issues",
    "section": "lightning",
    "body": "Cannot Bump Fees Problem: No UTXOs available for CPFP. Solutions: Maintain dedicated fee-bump reserve Fund on-chain wallet before force close Use RBF on the child transaction if possible Channel Open "
  },
  {
    "path": "/docs/lightning/anchor-outputs#best-practices",
    "title": "Best Practices",
    "section": "lightning",
    "body": "Maintain UTXO reserve: Keep 50,000+ sats in on-chain wallet per channel Monitor mempool: Know current fee rates for emergencies Use anchor channels: Default for new channels Automate fee bumping: "
  },
  {
    "path": "/docs/lightning/anchor-outputs#example-emergency-fee-bump",
    "title": "Example: Emergency Fee Bump",
    "section": "lightning",
    "body": "Scenario: Commitment transaction stuck, counterparty might cheat. 1. Check commitment tx status bitcoin-cli getmempoolentry 2. If not in mempool or low fee, bump it lncli wallet bumpforceclosefee "
  },
  {
    "path": "/docs/lightning/anchor-outputs#summary",
    "title": "Summary",
    "section": "lightning",
    "body": "Anchor outputs provide: Dynamic fees: Adjust commitment tx fees at broadcast time CPFP support: Bump fees using child transactions Stuck transaction prevention: Always confirmable with enough fee "
  },
  {
    "path": "/docs/lightning/anchor-outputs#related-topics",
    "title": "Related Topics",
    "section": "lightning",
    "body": "Channels - Channel lifecycle and force close Watchtowers - Automated breach response Zero-Conf Channels - Instant channel opening"
  },
  {
    "path": "/docs/lightning/anchor-outputs#resources",
    "title": "Resources",
    "section": "lightning",
    "body": "BOLT 3: Anchor Outputs LND Anchor Channels Guide"
  },
  {
    "path": "/docs/lightning/resources",
    "title": "Lightning Resources",
    "section": "lightning",
    "body": "Lightning Resources Curated links to Lightning Network tools, LSPs, dashboards, and routing/liquidity resources. For protocol docs, see Lightning Network and the BOLT specs. LSPs & Services Lightning Network+ (LNG) – Enterprise LSP and infrastructure. Voltage – Cloud Lightning node hosting and LSP. LNBits – Free, self-hostable Lightning wallet and extension server. Dashboards & Monitoring Amboss – Lightning network explorer and node analytics. 1ML – Lightning network statistics and node search. "
  },
  {
    "path": "/docs/lightning/resources#lsps-services",
    "title": "LSPs & Services",
    "section": "lightning",
    "body": "Lightning Network+ (LNG) – Enterprise LSP and infrastructure. Voltage – Cloud Lightning node hosting and LSP. LNBits – Free, self-hostable Lightning wallet and extension server."
  },
  {
    "path": "/docs/lightning/resources#dashboards-monitoring",
    "title": "Dashboards & Monitoring",
    "section": "lightning",
    "body": "Amboss – Lightning network explorer and node analytics. 1ML – Lightning network statistics and node search. Mempool.space – Lightning – Lightning graph and channel view."
  },
  {
    "path": "/docs/lightning/resources#routing-liquidity",
    "title": "Routing & Liquidity",
    "section": "lightning",
    "body": "Channel liquidity – BOLT 2 defines channel and liquidity semantics. Submarine Swaps – On-chain to Lightning and back."
  },
  {
    "path": "/docs/lightning/resources#learning-development",
    "title": "Learning & Development",
    "section": "lightning",
    "body": "Lightning Dev Kit (LDK) – Library for embedding Lightning in apps. Core Lightning – C implementation of the Lightning protocol. LND – Go implementation of the Lightning protocol. For a larger "
  },
  {
    "path": "/docs/development",
    "title": "Setup & Infrastructure",
    "section": "development",
    "body": "Setup & Infrastructure This section covers the setup and infrastructure needed for Bitcoin development: installing Bitcoin Core, testing and debugging, working with test networks, choosing libraries, understanding node architecture, and exploring Bitcoin Core internals. Hands-on learning: Try Bitcoin RPC commands directly in the Bitcoin CLI Terminal. No node setup required. Programming Languages in Bitcoin C++ (Bitcoin Core) The reference implementation of Bitcoin is written in C++. Used for: "
  },
  {
    "path": "/docs/development#programming-languages-in-bitcoin",
    "title": "Programming Languages in Bitcoin",
    "section": "development",
    "body": "C++ (Bitcoin Core) The reference implementation of Bitcoin is written in C++. Used for: Bitcoin Core development Performance-critical applications Protocol-level changes Consensus code Key libraries: "
  },
  {
    "path": "/docs/development#development-approaches",
    "title": "Development Approaches",
    "section": "development",
    "body": "1. Full Node Development Working directly with Bitcoin Core or alternative implementations. What you'll do: Run and configure full nodes Use RPC interface for queries Contribute to protocol "
  },
  {
    "path": "/docs/development#development-networks",
    "title": "Development Networks",
    "section": "development",
    "body": "Mainnet The real Bitcoin network. Use only for production applications. Characteristics: Real value at stake ~10 minute block times Full transaction fees Testnet Long-running test network. Coins have "
  },
  {
    "path": "/docs/development#essential-tools",
    "title": "Essential Tools",
    "section": "development",
    "body": "Block Explorers mempool.space: Beautiful, open-source explorer blockstream.info: Blockstream's explorer blockchain.info: Popular web explorer Development Tools Bitcoin Core: Reference implementation "
  },
  {
    "path": "/docs/development#development-workflow",
    "title": "Development Workflow",
    "section": "development",
    "body": "1. Start with Regtest Create a regtest environment bitcoind -regtest -daemon bitcoin-cli -regtest createwallet \"dev\" bitcoin-cli -regtest -generate 101 2. Move to Signet/Testnet Once your code works "
  },
  {
    "path": "/docs/development#common-pitfalls",
    "title": "Common Pitfalls",
    "section": "development",
    "body": "Security Never hardcode keys: Use environment variables or secure storage Validate all inputs: Especially amounts and addresses Use established libraries: Don't roll your own crypto Test on testnet "
  },
  {
    "path": "/docs/development#summary",
    "title": "Summary",
    "section": "development",
    "body": "Bitcoin development offers many paths: | Language | Best For | Key Library | |----------|----------|-------------| | C++ | Bitcoin Core, performance | libbitcoin | | Rust | Modern apps, security | "
  },
  {
    "path": "/docs/development#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Bitcoin Development - Practical development tasks including PSBT, transaction construction, address generation, key management, blockchain monitoring, and more Wallet Development - Building Bitcoin "
  },
  {
    "path": "/docs/development#resources",
    "title": "Resources",
    "section": "development",
    "body": "Bitcoin Developer Mailing List Bitcoin Stack Exchange Bitcoin Optech - Technical newsletter Bitcoin Core GitHub"
  },
  {
    "path": "/docs/development/install-bitcoin",
    "title": "Installing Bitcoin",
    "section": "development",
    "body": "Installing Bitcoin Bitcoin Core is the reference implementation of the Bitcoin protocol. Understanding how to install and run it is fundamental for development, running a full node, or participating in the network. Historical Context: The Original Bitcoin Client The original Bitcoin software released by Satoshi Nakamoto in January 2009 was a single monolithic application that bundled three distinct functions: Full Node - Validating and relaying transactions and blocks Wallet - Managing keys, "
  },
  {
    "path": "/docs/development/install-bitcoin#historical-context-the-original-bitcoin-client",
    "title": "Historical Context: The Original Bitcoin Client",
    "section": "development",
    "body": "The original Bitcoin software released by Satoshi Nakamoto in January 2009 was a single monolithic application that bundled three distinct functions: Full Node - Validating and relaying transactions "
  },
  {
    "path": "/docs/development/install-bitcoin#installation-methods",
    "title": "Installation Methods",
    "section": "development",
    "body": "Method 1: Download Pre-built Binaries (Recommended) Download the latest release from bitcoincore.org: Example for Linux x86_64 (check for latest version) wget "
  },
  {
    "path": "/docs/development/install-bitcoin#components",
    "title": "Components",
    "section": "development",
    "body": "After installation, you have access to several executables: | Binary | Purpose | |--------|---------| | bitcoind | Headless daemon (server mode) | | bitcoin-qt | GUI application with wallet | | "
  },
  {
    "path": "/docs/development/install-bitcoin#basic-configuration",
    "title": "Basic Configuration",
    "section": "development",
    "body": "Create a configuration file at ~/.bitcoin/bitcoin.conf (Linux/macOS) or %APPDATA%\\Bitcoin\\bitcoin.conf (Windows): Network (mainnet, testnet, signet, or regtest) testnet=1 signet=1 regtest=1 Enable "
  },
  {
    "path": "/docs/development/install-bitcoin#running-bitcoin-core",
    "title": "Running Bitcoin Core",
    "section": "development",
    "body": "Start the Daemon Start in background bitcoind -daemon Check status bitcoin-cli getblockchaininfo Initial Block Download (IBD) The first sync downloads and validates the entire blockchain history: "
  },
  {
    "path": "/docs/development/install-bitcoin#development-setup",
    "title": "Development Setup",
    "section": "development",
    "body": "For Bitcoin development, use regtest mode for instant block generation: Start regtest node bitcoind -regtest -daemon Create a wallet bitcoin-cli -regtest createwallet \"dev\" Generate blocks (mine to "
  },
  {
    "path": "/docs/development/install-bitcoin#alternative-implementations",
    "title": "Alternative Implementations",
    "section": "development",
    "body": "While Bitcoin Core is the reference implementation, alternatives exist: | Implementation | Language | Notes | |---------------|----------|-------| | Bitcoin Core | C++ | Reference implementation | | "
  },
  {
    "path": "/docs/development/install-bitcoin#system-requirements",
    "title": "System Requirements",
    "section": "development",
    "body": "Minimum (pruned): 2 GB RAM 10 GB disk space Broadband connection Recommended (full node): 4+ GB RAM 1 TB SSD Unmetered broadband For development: Any modern computer works with regtest SSD "
  },
  {
    "path": "/docs/development/install-bitcoin#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Test Networks - Development environments RPC Commands - Interacting with Bitcoin Core Libraries & SDKs - Development tools Hardware Evolution - How mining separated from nodes"
  },
  {
    "path": "/docs/development/install-bitcoin#resources",
    "title": "Resources",
    "section": "development",
    "body": "Bitcoin Core Documentation Bitcoin Core GitHub Learning Bitcoin from the Command Line"
  },
  {
    "path": "/docs/development/testing",
    "title": "Testing & Debugging",
    "section": "development",
    "body": "Testing & Debugging Bitcoin Applications Testing Bitcoin applications requires special considerations due to the financial nature of the software and the complexity of the protocol. This guide covers testing strategies, debugging techniques, and best practices. Testing Networks Regtest (Recommended for Development) Regtest provides a completely controlled environment where you can instantly generate blocks. Setup: Start Bitcoin Core in regtest mode bitcoind -regtest -daemon Create a wallet "
  },
  {
    "path": "/docs/development/testing#testing-networks",
    "title": "Testing Networks",
    "section": "development",
    "body": "Regtest (Recommended for Development) Regtest provides a completely controlled environment where you can instantly generate blocks. Setup: Start Bitcoin Core in regtest mode bitcoind -regtest -daemon "
  },
  {
    "path": "/docs/development/testing#unit-testing-strategies",
    "title": "Unit Testing Strategies",
    "section": "development",
    "body": "Testing Address Generation :::code-group #[test] fn test_address_generation() { let pubkey = PublicKey::from_str( \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\" ).unwrap(); let "
  },
  {
    "path": "/docs/development/testing#integration-testing",
    "title": "Integration Testing",
    "section": "development",
    "body": "Testing with Regtest Complete Test Flow: import subprocess import time import json import unittest class RegtestTestCase(unittest.TestCase): \"\"\"Base test case for Bitcoin regtest integration "
  },
  {
    "path": "/docs/development/testing#debugging-techniques",
    "title": "Debugging Techniques",
    "section": "development",
    "body": "Using bitcoin-cli for Debugging Inspect Transaction: Decode raw transaction bitcoin-cli decoderawtransaction Get transaction details bitcoin-cli getrawtransaction true Check mempool bitcoin-cli "
  },
  {
    "path": "/docs/development/testing#testing-lightning-applications",
    "title": "Testing Lightning Applications",
    "section": "development",
    "body": "Using Polar Polar provides a one-click Lightning Network for testing. Setup: Download from lightningpolar.com Create a new network Start nodes Open channels between nodes LND Testing import grpc "
  },
  {
    "path": "/docs/development/testing#mocking-and-stubbing",
    "title": "Mocking and Stubbing",
    "section": "development",
    "body": "Mocking RPC Calls from unittest.mock import Mock, patch class TestWithMocks: @patch('bitcoinrpc.RawProxy') def test_get_balance(self, mock_proxy): Setup mock "
  },
  {
    "path": "/docs/development/testing#test-data-generation",
    "title": "Test Data Generation",
    "section": "development",
    "body": "Creating Test Transactions def create_test_transaction(inputs, outputs): \"\"\"Create a transaction for testing.\"\"\" tx = CTransaction() for txid, vout in inputs: outpoint = "
  },
  {
    "path": "/docs/development/testing#continuous-integration",
    "title": "Continuous Integration",
    "section": "development",
    "body": "GitHub Actions Example name: Bitcoin Tests on: [push, pull_request] jobs: test: runs-on: ubuntu-latest steps: uses: actions/checkout@v3 name: Set up Python uses: actions/setup-python@v4 with: "
  },
  {
    "path": "/docs/development/testing#best-practices",
    "title": "Best Practices",
    "section": "development",
    "body": "Testing Checklist Unit Tests: Test individual functions in isolation Integration Tests: Test component interactions on regtest End-to-End Tests: Test full workflows on signet/testnet Edge Cases: Test "
  },
  {
    "path": "/docs/development/testing#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Test Networks - Regtest, Signet, and Testnet setup Getting Started - Development environment setup Libraries & SDKs - Testing utilities in each library"
  },
  {
    "path": "/docs/development/testnets",
    "title": "Test Networks",
    "section": "development",
    "body": "Signet & Testnet Deep Dive Test networks are essential for Bitcoin development. This guide covers the differences between testnet, signet, and regtest, along with setup instructions and best practices. Network Comparison | Feature | Mainnet | Testnet | Signet | Regtest | |---------|---------|---------|--------|---------| | Real Value | Yes | No | No | No | | Block Time | 10 min | Variable | 10 min | Instant | | Difficulty | Dynamic | Dynamic | Fixed | Minimal | | Public | Yes | Yes | Yes | ",
    "keywords": [
      "testnet",
      "test net",
      "testnet3",
      "regtest",
      "signet"
    ]
  },
  {
    "path": "/docs/development/testnets#network-comparison",
    "title": "Network Comparison",
    "section": "development",
    "body": "| Feature | Mainnet | Testnet | Signet | Regtest | |---------|---------|---------|--------|---------| | Real Value | Yes | No | No | No | | Block Time | 10 min | Variable | 10 min | Instant | | "
  },
  {
    "path": "/docs/development/testnets#testnet-testnet3",
    "title": "Testnet (Testnet3)",
    "section": "development",
    "body": "Overview Testnet is the original Bitcoin test network. It mirrors mainnet but with worthless coins. Configuration bitcoin.conf testnet=1 test] rpcuser=user rpcpassword=password rpcport=18332 Starting "
  },
  {
    "path": "/docs/development/testnets#signet",
    "title": "Signet",
    "section": "development",
    "body": "Overview Signet (BIP-325) provides a more controlled test environment. Blocks are signed by specific keys, ensuring predictable block production. Benefits Over Testnet Predictable Blocks: Consistent "
  },
  {
    "path": "/docs/development/testnets#regtest-regression-test",
    "title": "Regtest (Regression Test)",
    "section": "development",
    "body": "Overview Regtest is a local, private blockchain perfect for development and automated testing. Configuration bitcoin.conf regtest=1 [regtest] rpcuser=user rpcpassword=password rpcport=18443 Starting "
  },
  {
    "path": "/docs/development/testnets#lightning-network-testing",
    "title": "Lightning Network Testing",
    "section": "development",
    "body": "Polar (Recommended) Polar provides a GUI for managing Lightning test networks. Download from https://lightningpolar.com/ Create network with: - Bitcoin Core (regtest) - LND / Core Lightning / Eclair "
  },
  {
    "path": "/docs/development/testnets#automated-testing-setup",
    "title": "Automated Testing Setup",
    "section": "development",
    "body": "Docker Compose Example docker-compose.yml version: '3.8' services: bitcoind: image: ruimarinho/bitcoin-core:latest command: -regtest -rpcuser=test -rpcpassword=test -rpcallowip=0.0.0.0/0 "
  },
  {
    "path": "/docs/development/testnets#network-specific-code",
    "title": "Network-Specific Code",
    "section": "development",
    "body": "Selecting Network :::code-group use bitcoin::Network; fn get_network(network_type: &str) -> Network { match network_type { \"mainnet\" => Network::Bitcoin, \"testnet\" | \"signet\" => Network::Testnet, "
  },
  {
    "path": "/docs/development/testnets#testing-scenarios",
    "title": "Testing Scenarios",
    "section": "development",
    "body": "Testing RBF (Replace-By-Fee) On regtest 1. Create transaction with RBF enabled bitcoin-cli -regtest sendtoaddress 0.1 \"\" \"\" false true # replaceable=true 2. Get the txid TXID=$(bitcoin-cli -regtest "
  },
  {
    "path": "/docs/development/testnets#best-practices",
    "title": "Best Practices",
    "section": "development",
    "body": "Development Workflow Unit Tests → Regtest Fast iteration Complete control Automated testing Integration Tests → Signet More realistic environment Predictable timing Public network testing Final "
  },
  {
    "path": "/docs/development/testnets#summary",
    "title": "Summary",
    "section": "development",
    "body": "Each test network serves a purpose: Regtest: Local development and unit testing Signet: Predictable integration testing Testnet: Real-world simulation before mainnet Start with regtest for fast "
  },
  {
    "path": "/docs/development/testnets#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Testing & Debugging - Testing strategies and techniques Getting Started - Development setup guide RPC Commands - Bitcoin Core RPC interface"
  },
  {
    "path": "/docs/development/libraries",
    "title": "Libraries & SDKs",
    "section": "development",
    "body": "Libraries & SDKs Reference This guide compares major Bitcoin libraries across languages and provides practical examples for common development tasks. Library Versions Code examples in this documentation are tested with the following library versions: - bitcoinjs-lib: v6.x (uses factory pattern for bip32/ecpair) - bip32: v4.x (requires tiny-secp256k1 via BIP32Factory) - rust-bitcoin: v0.31.x - BDK: v0.29.x - python-bitcoinlib: v0.12.x - bip32utils: v0.3.x (use BIP32Key.fromSeed() for seed-based "
  },
  {
    "path": "/docs/development/libraries#library-overview",
    "title": "Library Overview",
    "section": "development",
    "body": "By Language | Language | Library | Best For | Maintenance | |----------|---------|----------|-------------| | JavaScript | bitcoinjs-lib | Web apps, general use | Active | | Rust | rust-bitcoin | "
  },
  {
    "path": "/docs/development/libraries#javascripttypescript",
    "title": "JavaScript/TypeScript",
    "section": "development",
    "body": "bitcoinjs-lib The most popular JavaScript Bitcoin library. Installation: npm install bitcoinjs-lib npm install ecpair tiny-secp256k1 # For signing npm install bip32 bip39 # For HD wallets Basic "
  },
  {
    "path": "/docs/development/libraries#rust",
    "title": "Rust",
    "section": "development",
    "body": "rust-bitcoin Low-level Bitcoin library for Rust. Cargo.toml: [dependencies] bitcoin = \"0.31\" secp256k1 = { version = \"0.28\", features = [\"global-context\"] } Basic Usage: use bitcoin::{ Address, "
  },
  {
    "path": "/docs/development/libraries#python",
    "title": "Python",
    "section": "development",
    "body": "python-bitcoinlib pip install python-bitcoinlib Basic Usage: from bitcoin import SelectParams from bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint, COIN from bitcoin.core.script import "
  },
  {
    "path": "/docs/development/libraries#go",
    "title": "Go",
    "section": "development",
    "body": "btcd/btcutil import ( \"github.com/btcsuite/btcd/btcec/v2\" \"github.com/btcsuite/btcd/btcutil\" \"github.com/btcsuite/btcd/chaincfg\" ) func generateAddress() { // Generate private key privateKey, _ := "
  },
  {
    "path": "/docs/development/libraries#common-tasks",
    "title": "Common Tasks",
    "section": "development",
    "body": "Generate Address (All Languages) // JavaScript const { address } = bitcoin.payments.p2wpkh({ pubkey: publicKey }); // Rust let address = Address::p2wpkh(&public_key, Network::Bitcoin)?; Python "
  },
  {
    "path": "/docs/development/libraries#choosing-a-library",
    "title": "Choosing a Library",
    "section": "development",
    "body": "Decision Matrix | Use Case | Recommended | |----------|-------------| | Web wallet | bitcoinjs-lib | | Mobile app (React Native) | bitcoinjs-lib | | Backend service | rust-bitcoin or btcd | | Wallet "
  },
  {
    "path": "/docs/development/libraries#summary",
    "title": "Summary",
    "section": "development",
    "body": "Each library has its strengths: bitcoinjs-lib: Best for web and cross-platform rust-bitcoin/BDK: Best for production applications python-bitcoinlib: Best for learning and scripting btcd: Best for Go "
  },
  {
    "path": "/docs/development/libraries#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Getting Started - Development environment setup Transaction Construction - Using libraries for transactions PSBT - Library support for PSBTs Testing & Debugging - Library testing utilities"
  },
  {
    "path": "/docs/development/node-types",
    "title": "Node Types & Architecture",
    "section": "development",
    "body": "Node Types & Architecture Bitcoin nodes come in different types, each with different capabilities, resource requirements, and trust models. Understanding node types helps you choose the right setup for your needs. Node Types Full Nodes Full nodes download and validate the entire blockchain: Characteristics: Downloads ~600GB+ blockchain data Validates all transactions and blocks Maintains complete UTXO set Maximum security and privacy Requires significant resources Use cases: Maximum security "
  },
  {
    "path": "/docs/development/node-types#node-types",
    "title": "Node Types",
    "section": "development",
    "body": "Full Nodes Full nodes download and validate the entire blockchain: Characteristics: Downloads ~600GB+ blockchain data Validates all transactions and blocks Maintains complete UTXO set Maximum "
  },
  {
    "path": "/docs/development/node-types#code-examples",
    "title": "Code Examples",
    "section": "development",
    "body": "Checking Node Type :::code-group use serde_json::json; use reqwest; async fn get_node_info() -> Result> { let client = reqwest::Client::new(); let response = client .post(\"http://localhost:8332\") "
  },
  {
    "path": "/docs/development/node-types#comparison",
    "title": "Comparison",
    "section": "development",
    "body": "| Feature | Full Node | Pruned Node | SPV Node | |---------|-----------|-------------|----------| | Storage | 600GB+ | 2GB | ~50MB | | Validation | Complete | Complete | Partial | | Privacy | Maximum "
  },
  {
    "path": "/docs/development/node-types#choosing-a-node-type",
    "title": "Choosing a Node Type",
    "section": "development",
    "body": "Use Full Node If: You need maximum security Privacy is critical You're developing Bitcoin software You want to contribute to network Use Pruned Node If: Storage is limited You still want full "
  },
  {
    "path": "/docs/development/node-types#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Bitcoin Core Internals - Node implementation P2P Network Protocol - Network communication Installing Bitcoin - Setup guide"
  },
  {
    "path": "/docs/development/node-types#resources",
    "title": "Resources",
    "section": "development",
    "body": "Bitcoin Core Documentation Running a Full Node"
  },
  {
    "path": "/docs/development/bitcoin-core-internals",
    "title": "Bitcoin Core Internals",
    "section": "development",
    "body": "Bitcoin Core Internals Bitcoin Core is the reference implementation of Bitcoin. Understanding its internal architecture helps developers contribute to Bitcoin Core, build compatible software, and debug issues. Architecture Overview Core Components Bitcoin Core: ├── Consensus Engine │ ├── Validation │ ├── Block processing │ └── Chain state ├── Network Layer │ ├── P2P protocol │ ├── Peer management │ └── Message handling ├── Wallet System │ ├── Key management │ ├── Transaction creation │ └── UTXO "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#architecture-overview",
    "title": "Architecture Overview",
    "section": "development",
    "body": "Core Components Bitcoin Core: ├── Consensus Engine │ ├── Validation │ ├── Block processing │ └── Chain state ├── Network Layer │ ├── P2P protocol │ ├── Peer management │ └── Message handling ├── "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#key-subsystems",
    "title": "Key Subsystems",
    "section": "development",
    "body": "1. Consensus Engine Validates transactions and blocks: Responsibilities: Verify transaction validity Check block validity Maintain chain state Enforce consensus rules 2. UTXO Set Tracks unspent "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#threading-model",
    "title": "Threading Model",
    "section": "development",
    "body": "Bitcoin Core is multi-threaded. The main bitcoind thread starts and shuts down the process and spawns worker threads. Key groups: Main and init Main (bitcoind): Startup, shutdown, and spawning other "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#database-systems",
    "title": "Database Systems",
    "section": "development",
    "body": "LevelDB Used for: Chainstate (chainstate/): UTXO set and related metadata. Block index (blocks/index/): Block metadata and header tree (most-work chain, orphans). Not affected by -blocksdir. Wallets "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#binaries-and-libraries",
    "title": "Binaries and Libraries",
    "section": "development",
    "body": "Bitcoin Core builds several executables: | Binary | Purpose | |--------|---------| | bitcoind | Headless node and built-in wallet. | | bitcoin-qt | Node and wallet with GUI. | | bitcoin-cli | RPC "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#code-structure",
    "title": "Code Structure",
    "section": "development",
    "body": "Key Directories src/ ├── consensus/ - Consensus rules and params ├── kernel/ - Libbitcoinkernel (consensus + validation core) ├── node/ - Node logic (chain, mempool, init) ├── net_processing/- P2P "
  },
  {
    "path": "/docs/development/bitcoin-core-internals#related-topics",
    "title": "Related Topics",
    "section": "development",
    "body": "Node Types - Different node configurations RPC Commands - JSON-RPC API P2P Network Protocol - Network communication Installing Bitcoin - Build and run Bitcoin Core"
  },
  {
    "path": "/docs/development/bitcoin-core-internals#resources",
    "title": "Resources",
    "section": "development",
    "body": "Bitcoin Core GitHub Bitcoin Core doc/ – Developer notes, files.md (data directory), REST, multiprocess, assumeutxo Bitcoin Core Academy – Architecture, components, threads, source organization "
  },
  {
    "path": "/docs/development/resources",
    "title": "Developer Resources",
    "section": "development",
    "body": "Developer Resources Curated links to Bitcoin development tools, node software, hardware, explorers, and APIs. For libraries and code examples, see Libraries & SDKs. Node Software Bitcoin Core – Reference implementation; run a full node and use the RPC API. Knots – Bitcoin Core with additional patches and features. Node Hardware Start9 – Hardware and software for running nodes at home. Nodl – Plug-and-play Bitcoin (and Lightning) nodes. Explorers & APIs Mempool.space – Block explorer, API, and "
  },
  {
    "path": "/docs/development/resources#node-software",
    "title": "Node Software",
    "section": "development",
    "body": "Bitcoin Core – Reference implementation; run a full node and use the RPC API. Knots – Bitcoin Core with additional patches and features."
  },
  {
    "path": "/docs/development/resources#node-hardware",
    "title": "Node Hardware",
    "section": "development",
    "body": "Start9 – Hardware and software for running nodes at home. Nodl – Plug-and-play Bitcoin (and Lightning) nodes."
  },
  {
    "path": "/docs/development/resources#explorers-apis",
    "title": "Explorers & APIs",
    "section": "development",
    "body": "Mempool.space – Block explorer, API, and fee estimates. Blockstream Explorer – Block explorer and API. Bitcoin Core RPC – Built-in RPC when running a node."
  },
  {
    "path": "/docs/development/resources#utilities",
    "title": "Utilities",
    "section": "development",
    "body": "Interactive Tools – CLI terminal, Stack Lab, Block Visualizer, Hash tool. Learn Me A Bitcoin – Tools – Hashing, keys, transaction builder, and more."
  },
  {
    "path": "/docs/bitcoin-development",
    "title": "Bitcoin Development",
    "section": "bitcoin-development",
    "body": "Bitcoin Development This section covers practical Bitcoin development tasks, the building blocks you'll use when creating Bitcoin applications. In Bitcoin Fundamentals you learned how Bitcoin works conceptually: the UTXO model, the blockchain, the trust model, and incentives. Here we turn those ideas into implementation. Keys prove ownership, addresses encode spending conditions, transactions move UTXOs, and tools like PSBTs coordinate signing while monitoring keeps your app in sync with the "
  },
  {
    "path": "/docs/bitcoin-development#core-development-tasks",
    "title": "Core Development Tasks",
    "section": "bitcoin-development",
    "body": "Key Management Securely generate, store, and manage Bitcoin private keys. Learn about key derivation, encryption, and hardware wallet integration. Key topics: Private key generation Key derivation "
  },
  {
    "path": "/docs/bitcoin-development#monitoring-integration",
    "title": "Monitoring & Integration",
    "section": "bitcoin-development",
    "body": "Payment Requests Request and receive Bitcoin payments: BIP 21 bitcoin: URIs, QR codes, verifying payment, and handling refunds. Use with Blockchain Monitoring to detect incoming payments and Price "
  },
  {
    "path": "/docs/bitcoin-development#advanced-topics",
    "title": "Advanced Topics",
    "section": "bitcoin-development",
    "body": "Mining Pools Pool setup, monitoring, Stratum protocol, share validation, and pool architecture are covered in the Mining section. Bitcoin Script Patterns Common Bitcoin script patterns and templates "
  },
  {
    "path": "/docs/bitcoin-development#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Setup & Infrastructure - Setup, testing, libraries, node architecture Wallet Development - HD wallets, coin selection, multisig Bitcoin Protocol - Script system, RPC, transaction structure UTXO Model "
  },
  {
    "path": "/docs/bitcoin-development#resources",
    "title": "Resources",
    "section": "bitcoin-development",
    "body": "Bitcoin Developer Reference - Official documentation BIPs - Bitcoin Improvement Proposals Bitcoin Optech - Technical newsletter and guides Bitcoin Stack Exchange - Q&A community"
  },
  {
    "path": "/docs/bitcoin-development/keys",
    "title": "Key Management",
    "section": "bitcoin-development",
    "body": "Key Management & Security In Bitcoin's trust model, you don't rely on a custodian; you prove ownership with private keys and signatures. \"Not your keys, not your coins\" means key management is the foundation of security. This guide covers HD wallets, seed phrases, derivation paths, and best practices so you can generate and use keys in code without trusting third parties. HD Wallets (BIP32) Hierarchical Deterministic (HD) wallets generate an entire tree of keys from a single seed. This enables: "
  },
  {
    "path": "/docs/bitcoin-development/keys#hd-wallets-bip32",
    "title": "HD Wallets (BIP32)",
    "section": "bitcoin-development",
    "body": "Hierarchical Deterministic (HD) wallets generate an entire tree of keys from a single seed. This enables: Backup Simplicity: One seed backs up all keys Key Organization: Structured derivation paths "
  },
  {
    "path": "/docs/bitcoin-development/keys#seed-phrases-bip39",
    "title": "Seed Phrases (BIP39)",
    "section": "bitcoin-development",
    "body": "Mnemonic Generation and Validation :::code-group use bip39::{Mnemonic, Language}; let mnemonic = Mnemonic::generate_in(Language::English, 24); let is_valid = "
  },
  {
    "path": "/docs/bitcoin-development/keys#derivation-paths",
    "title": "Derivation Paths",
    "section": "bitcoin-development",
    "body": "Standard Paths (BIPs) | BIP | Path | Purpose | Address Type | |-----|------|---------|--------------| | BIP44 | m/44'/0'/0' | Legacy | P2PKH (1...) | | BIP49 | m/49'/0'/0' | Nested SegWit | "
  },
  {
    "path": "/docs/bitcoin-development/keys#extended-keys-xpubxprv",
    "title": "Extended Keys (xpub/xprv)",
    "section": "bitcoin-development",
    "body": "Exporting Extended Keys // Export extended private key (KEEP SECRET!) const xprv = root.toBase58(); // xprv9s21ZrQH143K... // Export extended public key (safe to share for watch-only) const xpub = "
  },
  {
    "path": "/docs/bitcoin-development/keys#secure-key-storage",
    "title": "Secure Key Storage",
    "section": "bitcoin-development",
    "body": "In-Memory Security import { randomBytes } from 'crypto'; class SecureKeyStore { private encryptedKey: Buffer | null = null; private iv: Buffer | null = null; async store(privateKey: Buffer, password: "
  },
  {
    "path": "/docs/bitcoin-development/keys#multi-signature-setup",
    "title": "Multi-Signature Setup",
    "section": "bitcoin-development",
    "body": "Creating Multisig Wallet import * as bitcoin from 'bitcoinjs-lib'; interface MultisigConfig { m: number; // Required signatures n: number; // Total keys pubkeys: Buffer[]; } function "
  },
  {
    "path": "/docs/bitcoin-development/keys#backup-strategies",
    "title": "Backup Strategies",
    "section": "bitcoin-development",
    "body": "Seed Phrase Backup DO: ✓ Write on paper/metal (fire/water resistant) ✓ Store in multiple secure locations ✓ Consider splitting (e.g., 2-of-3 Shamir) ✓ Test recovery before storing funds DON'T: ✗ "
  },
  {
    "path": "/docs/bitcoin-development/keys#security-best-practices",
    "title": "Security Best Practices",
    "section": "bitcoin-development",
    "body": "Key Generation // SECURE: Use crypto.getRandomValues or crypto.randomBytes import { randomBytes } from 'crypto'; const entropy = randomBytes(32); // INSECURE: Never use Math.random() const badEntropy "
  },
  {
    "path": "/docs/bitcoin-development/keys#recovery-procedures",
    "title": "Recovery Procedures",
    "section": "bitcoin-development",
    "body": "From Mnemonic async function recoverWallet(mnemonic: string, passphrase = ''): Promise { // Validate mnemonic if (!bip39.validateMnemonic(mnemonic)) { throw new Error('Invalid mnemonic'); } // "
  },
  {
    "path": "/docs/bitcoin-development/keys#summary",
    "title": "Summary",
    "section": "bitcoin-development",
    "body": "Secure key management requires: HD Wallets: Use BIP32/39/44/49/84/86 standards Secure Generation: Cryptographically secure randomness Proper Storage: Encrypted storage, hardware wallets Backup "
  },
  {
    "path": "/docs/bitcoin-development/keys#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Address Generation - Creating addresses from keys Output Descriptors - Describing keys and derivation in descriptors HD Wallets - Hierarchical deterministic wallet concepts Multisig - Multi-signature "
  },
  {
    "path": "/docs/bitcoin-development/addresses",
    "title": "Address Generation",
    "section": "bitcoin-development",
    "body": "Address Generation & Validation In the UTXO model, coins are locked by output scripts (scriptPubKeys). Addresses are human-readable encodings of those scripts, so generating and validating addresses is how you turn Bitcoin Script into something users and APIs can use. This page covers the main address types (P2PKH, P2SH, P2WPKH, P2WSH, P2TR), encoding (Base58Check, Bech32, Bech32m), and how to derive and validate them in code. Decode and inspect addresses in the Address Decoder tool. Address "
  },
  {
    "path": "/docs/bitcoin-development/addresses#address-types-overview",
    "title": "Address Types Overview",
    "section": "bitcoin-development",
    "body": "Legacy Addresses (P2PKH) Format: Starts with 1 (mainnet) or m/n (testnet) 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2 Script: Pay-to-Public-Key-Hash OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG Script Hash "
  },
  {
    "path": "/docs/bitcoin-development/addresses#address-comparison",
    "title": "Address Comparison",
    "section": "bitcoin-development",
    "body": "| Type | Prefix | Size | Encoding | Fee Efficiency | |------|--------|------|----------|----------------| | P2PKH | 1 | 25 bytes | Base58Check | Lowest | | P2SH | 3 | 23 bytes | Base58Check | Low | | "
  },
  {
    "path": "/docs/bitcoin-development/addresses#generating-addresses",
    "title": "Generating Addresses",
    "section": "bitcoin-development",
    "body": "From Public Key to P2WPKH (Native SegWit) :::code-group use bitcoin::{Address, Network, PublicKey, CompressedPublicKey}; use bitcoin::secp256k1::{Secp256k1, SecretKey}; fn "
  },
  {
    "path": "/docs/bitcoin-development/addresses#validating-addresses",
    "title": "Validating Addresses",
    "section": "bitcoin-development",
    "body": ":::code-group use bitcoin::{Address, Network}; use std::str::FromStr; fn validate_address(addr_str: &str) -> Result { match Address::from_str(addr_str) { Ok(addr) => Ok(match addr.address_type() { "
  },
  {
    "path": "/docs/bitcoin-development/addresses#bech32-encoding-details",
    "title": "Bech32 Encoding Details",
    "section": "bitcoin-development",
    "body": "Bech32 vs Bech32m Bech32 (BIP-173): Used for SegWit v0 (P2WPKH, P2WSH) Checksum constant: 1 Bech32m (BIP-350): Used for SegWit v1+ (Taproot) Checksum constant: 0x2bc830a3 Why Bech32m? Bech32 had a "
  },
  {
    "path": "/docs/bitcoin-development/addresses#from-script-to-address",
    "title": "From Script to Address",
    "section": "bitcoin-development",
    "body": ":::code-group use bitcoin::{Address, Script, Network}; fn script_to_address(script: &Script) -> Option { Address::from_script(script, Network::Bitcoin).ok() } from bitcoin.core.script import CScript "
  },
  {
    "path": "/docs/bitcoin-development/addresses#address-derivation-paths",
    "title": "Address Derivation Paths",
    "section": "bitcoin-development",
    "body": "BIP Standards | BIP | Path | Address Type | Example | |-----|------|--------------|---------| | BIP44 | m/44'/0'/0' | P2PKH | 1... | | BIP49 | m/49'/0'/0' | P2SH-P2WPKH | 3... | | BIP84 | m/84'/0'/0' "
  },
  {
    "path": "/docs/bitcoin-development/addresses#multi-signature-addresses",
    "title": "Multi-Signature Addresses",
    "section": "bitcoin-development",
    "body": "Creating 2-of-3 Multisig :::code-group use bitcoin::{PublicKey, Script, Address}; use bitcoin::blockdata::script::Builder; fn create_multisig(m: usize, pubkeys: &PublicKey]) -> Address { let script = "
  },
  {
    "path": "/docs/bitcoin-development/addresses#common-mistakes",
    "title": "Common Mistakes",
    "section": "bitcoin-development",
    "body": "Address Validation Pitfalls BAD: Only checking prefix (address.startsWith('bc1')) GOOD: Full validation with checksum verification using library functions Network Mismatch Always use consistent "
  },
  {
    "path": "/docs/bitcoin-development/addresses#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "Address Handling Case Sensitivity: Bech32 is case-insensitive, Base58 is case-sensitive Display Formatting: Consider QR codes for long addresses Copy Protection: Use checksums to detect copy errors "
  },
  {
    "path": "/docs/bitcoin-development/addresses#summary",
    "title": "Summary",
    "section": "bitcoin-development",
    "body": "Understanding Bitcoin addresses requires knowledge of: Encoding Schemes: Base58Check, Bech32, Bech32m Script Types: P2PKH, P2SH, P2WPKH, P2WSH, P2TR Derivation: BIP32/39/44/49/84/86 standards "
  },
  {
    "path": "/docs/bitcoin-development/addresses#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Key Management - Managing private and public keys Output Descriptors - Deriving addresses from descriptors Payment Requests - bitcoin: URIs and receiving payments Address Types - Detailed address "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation",
    "title": "Fee Estimation",
    "section": "bitcoin-development",
    "body": "Fee Estimation When building transactions, you need a fee rate (sat/vB) so the transaction is included in a block within an acceptable time. Fee estimation uses the mempool and sometimes external APIs to suggest a rate. This guide covers getting fee rates from your node (e.g. Bitcoin Core RPC), from HTTP APIs, and how to use them in code. For the economics of fees, see Transaction Fees. Why Fee Estimation Matters Too low: Transaction may sit in the mempool or be dropped; user waits or payment "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#why-fee-estimation-matters",
    "title": "Why Fee Estimation Matters",
    "section": "bitcoin-development",
    "body": "Too low: Transaction may sit in the mempool or be dropped; user waits or payment fails. Too high: User overpays; acceptable for urgency, wasteful otherwise. Estimation is heuristic: the mempool "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#fee-rate-units",
    "title": "Fee Rate Units",
    "section": "bitcoin-development",
    "body": "sat/vB (satoshis per virtual byte): Standard unit. Virtual size comes from SegWit weight (weight/4). BTC/kB: Legacy unit; 1 BTC/kB = 100,000 sat/vB. Bitcoin Core's estimatesmartfee returns BTC/kB; "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#getting-fee-rates-from-your-node",
    "title": "Getting Fee Rates from Your Node",
    "section": "bitcoin-development",
    "body": "Bitcoin Core's estimatesmartfee RPC returns an estimated fee rate for a given confirmation target (number of blocks). :::code-group // Using jsonrpc or similar; returns feerate in BTC/kB // Convert "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#getting-fee-rates-from-an-api",
    "title": "Getting Fee Rates from an API",
    "section": "bitcoin-development",
    "body": "When you don't run a full node, you can use a third-party fee API (e.g. mempool.space API). These return fee rates for different confirmation targets (e.g. 1, 3, 6 blocks). :::code-group // Example: "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#choosing-a-confirmation-target",
    "title": "Choosing a Confirmation Target",
    "section": "bitcoin-development",
    "body": "1–2 blocks: High urgency; pay a premium (e.g. \"fastest\" from API or target 1 in estimatesmartfee). 3–6 blocks: Normal payments; balance cost and speed. 6+ blocks: Low urgency; often cheapest. Use the "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#limitations",
    "title": "Limitations",
    "section": "bitcoin-development",
    "body": "Reorgs: Short reorgs can delay confirmation; estimates don't account for this. Mempool churn: A sudden spike in demand can make your estimate stale; consider refreshing close to broadcast. Pruned "
  },
  {
    "path": "/docs/bitcoin-development/fee-estimation#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Transaction Construction - Using fee rate to set transaction fee Transaction Fees - Fee market and RBF/CPFP Mempool - How unconfirmed transactions are stored and selected Coin Selection - Selecting "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection",
    "title": "Coin Selection",
    "section": "bitcoin-development",
    "body": "Coin Selection When building a transaction, you must choose which UTXOs to spend so that their total value covers the payment amount plus fees. Coin selection is the process of picking those inputs and, when necessary, creating a change output back to your wallet. This page focuses on implementation: effective value, fee budget, and a simple selection loop. For algorithms (e.g. branch-and-bound, privacy-aware strategies) and wallet UX, see Coin Selection in Wallet Development. For fee rate "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#the-problem",
    "title": "The Problem",
    "section": "bitcoin-development",
    "body": "Given: A set of available UTXOs (each with amount and script/address type, so you can compute input size) A payment amount (in satoshis) A target fee rate (sat/vB) You must: Select inputs such that "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#effective-value",
    "title": "Effective Value",
    "section": "bitcoin-development",
    "body": "The effective value of a UTXO is its amount minus the cost to spend it at a given fee rate: effective_value = amount - (input_vbytes × fee_rate) Input size (vbytes) depends on the script type (e.g. "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#simple-selection-cover-amount-fee",
    "title": "Simple Selection: Cover Amount + Fee",
    "section": "bitcoin-development",
    "body": "A minimal approach: sort UTXOs by effective value (or amount), then greedily add inputs until total input value ≥ payment + estimated fee. Estimate fee from a baseline size (e.g. one input, two "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#change-output",
    "title": "Change Output",
    "section": "bitcoin-development",
    "body": "If selected inputs exceed payment + fee, the remainder is change. Create a new output (to an address you control) for that amount. If the remainder is below the dust threshold (e.g. 546 sats), you "
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#integration-with-transaction-building",
    "title": "Integration with Transaction Building",
    "section": "bitcoin-development",
    "body": "Use the selected UTXOs as inputs and amounts in your transaction: one output for the payment, and one for change (if any). Fee = sum(inputs) - sum(outputs). Get the fee rate from Fee Estimation."
  },
  {
    "path": "/docs/bitcoin-development/coin-selection#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Coin Selection - Algorithms, privacy, and wallet design Transaction Construction - Building the transaction from selected UTXOs Fee Estimation - Getting fee rate (sat/vB) Transaction Fees - Fee "
  },
  {
    "path": "/docs/bitcoin-development/transactions",
    "title": "Transaction Construction",
    "section": "bitcoin-development",
    "body": "Transaction Construction Building a transaction is the direct application of the UTXO model: you select unspent outputs as inputs, create new outputs (recipient and change), and sign to prove ownership. The transaction lifecycle (create, sign, broadcast, mempool, confirmed) is what your code drives; fee choice ties into the incentive structure of the network. This guide covers the complete process from UTXO selection to broadcasting. Transaction Lifecycle Understanding the complete lifecycle of "
  },
  {
    "path": "/docs/bitcoin-development/transactions#transaction-lifecycle",
    "title": "Transaction Lifecycle",
    "section": "bitcoin-development",
    "body": "Understanding the complete lifecycle of a transaction helps contextualize the construction process: Creation: User constructs a transaction specifying inputs (UTXOs to spend) and outputs (recipient "
  },
  {
    "path": "/docs/bitcoin-development/transactions#transaction-structure",
    "title": "Transaction Structure",
    "section": "bitcoin-development",
    "body": "Raw Bitcoin Transaction Bytes Byte Order: Most numeric fields (version, value, locktime, sequence, output index) are encoded in little endian. However, transaction IDs (TXIDs) and block hashes are "
  },
  {
    "path": "/docs/bitcoin-development/transactions#building-transactions",
    "title": "Building Transactions",
    "section": "bitcoin-development",
    "body": "Transaction Binary Map :::code-group use bitcoin::{Transaction, TxIn, TxOut, OutPoint, Sequence, Amount, ScriptBuf}; use bitcoin::absolute::LockTime; fn create_transaction(prev_txid: Txid, recipient: "
  },
  {
    "path": "/docs/bitcoin-development/transactions#input-selection",
    "title": "Input Selection",
    "section": "bitcoin-development",
    "body": "Coin Selection Algorithms Largest First function largestFirst(utxos: UTXO], target: number): UTXO[] { // Sort by value descending const sorted = [...utxos].sort((a, b) => b.value - a.value); const "
  },
  {
    "path": "/docs/bitcoin-development/transactions#fee-estimation",
    "title": "Fee Estimation",
    "section": "bitcoin-development",
    "body": "Fee Rate Sources async function getFeeRate(): Promise { // Option 1: mempool.space API const response = await fetch('https://mempool.space/api/v1/fees/recommended'); const fees = await "
  },
  {
    "path": "/docs/bitcoin-development/transactions#replace-by-fee-rbf",
    "title": "Replace-By-Fee (RBF)",
    "section": "bitcoin-development",
    "body": "Enabling RBF function createRBFTransaction(psbt: Psbt) { // Set sequence to enable RBF (< 0xFFFFFFFE) psbt.setInputSequence(0, 0xFFFFFFFD); // Alternative: Use the constant psbt.setInputSequence(0, "
  },
  {
    "path": "/docs/bitcoin-development/transactions#child-pays-for-parent-cpfp",
    "title": "Child-Pays-For-Parent (CPFP)",
    "section": "bitcoin-development",
    "body": "Creating CPFP Transaction function createCPFPTransaction( stuckTx: Transaction, stuckTxFee: number, targetFeeRate: number ): Psbt { // Find our output in the stuck transaction const ourOutput = "
  },
  {
    "path": "/docs/bitcoin-development/transactions#transaction-batching",
    "title": "Transaction Batching",
    "section": "bitcoin-development",
    "body": "Batch Multiple Payments interface Payment { address: string; amount: number; } function createBatchTransaction( utxos: UTXO[], payments: Payment[], feeRate: number, changeAddress: string ): Psbt { "
  },
  {
    "path": "/docs/bitcoin-development/transactions#time-locks",
    "title": "Time Locks",
    "section": "bitcoin-development",
    "body": "Absolute Time Lock (nLockTime) function createTimeLocked(lockTime: number): Psbt { const psbt = new bitcoin.Psbt(); // Set locktime (block height or Unix timestamp) psbt.setLocktime(lockTime); // "
  },
  {
    "path": "/docs/bitcoin-development/transactions#broadcasting-transactions",
    "title": "Broadcasting Transactions",
    "section": "bitcoin-development",
    "body": ":::code-group use reqwest; async fn broadcast_transaction(tx_hex: &str) -> Result> { let response = reqwest::Client::new() .post(\"https://mempool.space/api/tx\") .body(tx_hex.to_string()) "
  },
  {
    "path": "/docs/bitcoin-development/transactions#error-handling",
    "title": "Error Handling",
    "section": "bitcoin-development",
    "body": "Common Errors async function safebroadcast(txHex: string): Promise { try { return await broadcastTransaction(txHex); } catch (error) { const message = error.message.toLowerCase(); if "
  },
  {
    "path": "/docs/bitcoin-development/transactions#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "Transaction Construction Validate All Inputs: Verify UTXOs exist and are unspent Calculate Fees Carefully: Use appropriate fee rate for urgency Handle Dust: Don't create outputs below dust limit "
  },
  {
    "path": "/docs/bitcoin-development/transactions#summary",
    "title": "Summary",
    "section": "bitcoin-development",
    "body": "Transaction construction involves: Building: Creating inputs, outputs, and metadata Coin Selection: Choosing optimal UTXOs to spend Fee Estimation: Calculating appropriate fees Signing: Adding valid "
  },
  {
    "path": "/docs/bitcoin-development/transactions#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "PSBT - Partially Signed Bitcoin Transactions Coin Selection - Selecting UTXOs for transaction building Fee Estimation - Getting fee rate (sat/vB) Fee Bumping - RBF and CPFP when transactions are "
  },
  {
    "path": "/docs/bitcoin-development/signing",
    "title": "Signing & Sighash",
    "section": "bitcoin-development",
    "body": "Signing & Sighash When you build a transaction, each input must be signed so that the script spending condition is satisfied. The sighash type controls which parts of the transaction are committed to when signing. This page covers how to choose and use sighash types in code, signing order for multisig, and how signing fits into PSBT workflows. For the protocol definition of sighash types, see Sighash Types. Sighash Types in Practice SIGHASH_ALL (0x01) or SIGHASH_DEFAULT (0x00) for Taproot: "
  },
  {
    "path": "/docs/bitcoin-development/signing#sighash-types-in-practice",
    "title": "Sighash Types in Practice",
    "section": "bitcoin-development",
    "body": "SIGHASH_ALL (0x01) or SIGHASH_DEFAULT (0x00) for Taproot: Normal payments. Signer commits to all inputs and all outputs. Use this unless you need a contract pattern. SIGHASH_ALL | "
  },
  {
    "path": "/docs/bitcoin-development/signing#setting-sighash-type-when-signing",
    "title": "Setting Sighash Type When Signing",
    "section": "bitcoin-development",
    "body": ":::code-group use bitcoin::sighash::EcdsaSighashType; use bitcoin::secp256k1::Secp256k1; // Default: SIGHASH_ALL let sighash_type = EcdsaSighashType::All; // For CoinJoin-style: commit to all "
  },
  {
    "path": "/docs/bitcoin-development/signing#signing-order-in-multisig",
    "title": "Signing Order in Multisig",
    "section": "bitcoin-development",
    "body": "For M-of-N multisig, each of the M signers must sign the same transaction (or PSBT). Order does not matter for validity: any M signers can sign in any order. The resulting witness is a stack of M "
  },
  {
    "path": "/docs/bitcoin-development/signing#single-input-sign-and-attach",
    "title": "Single Input: Sign and Attach",
    "section": "bitcoin-development",
    "body": "For a single-sig input, you compute the sighash for that input (using the chosen sighash type), sign it with the private key, and place the signature (and public key if needed) in the witness or "
  },
  {
    "path": "/docs/bitcoin-development/signing#psbt-signing-flow",
    "title": "PSBT Signing Flow",
    "section": "bitcoin-development",
    "body": "Creator builds an unsigned PSBT (inputs, outputs, optional descriptors). Signers each call “sign” for the inputs they control; the PSBT stores partial signatures. Finalizer combines partial "
  },
  {
    "path": "/docs/bitcoin-development/signing#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Sighash Types - Protocol definition of sighash types Transaction Construction - Building and signing transactions PSBT - Partially signed transactions and multi-party signing Key Management - Private "
  },
  {
    "path": "/docs/bitcoin-development/psbt",
    "title": "PSBT",
    "section": "bitcoin-development",
    "body": "Partially Signed Bitcoin Transactions (PSBT) PSBTs (BIP-174) provide a standardized format for passing unsigned or partially signed transactions between different software and hardware. They're essential for multi-party signing, hardware wallet integration, and air-gapped setups. Before PSBT, passing transactions between wallets was ad-hoc: each wallet had its own format, hardware wallets needed custom integrations, multi-signature coordination was complex, and there was no standard way to ",
    "keywords": [
      "psbt",
      "partially signed bitcoin transaction",
      "partially signed bitcoin transactions"
    ]
  },
  {
    "path": "/docs/bitcoin-development/psbt#psbt-structure",
    "title": "PSBT Structure",
    "section": "bitcoin-development",
    "body": "Components [PSBT] ├── Global Data │ ├── Unsigned Transaction │ └── Extended Public Keys (optional) ├── Input Data per input │ ├── Non-Witness UTXO │ ├── Witness UTXO │ ├── Partial Signatures │ ├── "
  },
  {
    "path": "/docs/bitcoin-development/psbt#creating-psbts",
    "title": "Creating PSBTs",
    "section": "bitcoin-development",
    "body": "Using Bitcoin Core Create a PSBT bitcoin-cli walletcreatefundedpsbt \\ '[]' \\ '[{\"bc1q...address...\": 0.5}]' \\ 0 \\ '{\"includeWatching\": true}' Result: {\"psbt\": \"cHNidP8BAH0CAAAA...\", \"fee\": "
  },
  {
    "path": "/docs/bitcoin-development/psbt#signing-psbts",
    "title": "Signing PSBTs",
    "section": "bitcoin-development",
    "body": "Single Signature // Using bitcoinjs-lib import ECPairFactory from 'ecpair'; import * as ecc from 'tiny-secp256k1'; const ECPair = ECPairFactory(ecc); // Parse PSBT const psbt = "
  },
  {
    "path": "/docs/bitcoin-development/psbt#combining-psbts",
    "title": "Combining PSBTs",
    "section": "bitcoin-development",
    "body": "When multiple parties sign the same PSBT independently: // Party A signs const psbtA = Psbt.fromBase64(originalPsbt); psbtA.signInput(0, keyPairA); const signedA = psbtA.toBase64(); // Party B signs "
  },
  {
    "path": "/docs/bitcoin-development/psbt#finalizing-psbts",
    "title": "Finalizing PSBTs",
    "section": "bitcoin-development",
    "body": "Manual Finalization const psbt = Psbt.fromBase64(signedPsbt); // Finalize each input for (let i = 0; i input.finalScriptSig || input.finalScriptWitness)) { const tx = psbt.extractTransaction(); "
  },
  {
    "path": "/docs/bitcoin-development/psbt#psbt-workflow-examples",
    "title": "PSBT Workflow Examples",
    "section": "bitcoin-development",
    "body": "Air-Gapped Signing sequenceDiagram participant Online1 as Online Computer (Creator/Updater) participant AirGap as Air-Gapped Computer (Signer) participant Online2 as Online Computer "
  },
  {
    "path": "/docs/bitcoin-development/psbt#psbt-version-2-bip-370",
    "title": "PSBT Version 2 (BIP-370)",
    "section": "bitcoin-development",
    "body": "PSBT v2 introduces improvements for interactive protocols: Key Differences | Feature | PSBT v0 | PSBT v2 | |---------|---------|---------| | Transaction Storage | Global | Reconstructed from fields | "
  },
  {
    "path": "/docs/bitcoin-development/psbt#error-handling",
    "title": "Error Handling",
    "section": "bitcoin-development",
    "body": "Common PSBT Errors try { const psbt = Psbt.fromBase64(psbtString); } catch (e) { if (e.message.includes('Invalid PSBT magic')) { console.error('Not a valid PSBT'); } else if "
  },
  {
    "path": "/docs/bitcoin-development/psbt#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "For PSBT Creators Include All Metadata: Add derivation paths, scripts, and UTXOs Use Deterministic Inputs: Order inputs consistently Set Appropriate Sighash: Default to SIGHASH_ALL Validate Before "
  },
  {
    "path": "/docs/bitcoin-development/psbt#summary",
    "title": "Summary",
    "section": "bitcoin-development",
    "body": "PSBTs provide a standardized way to: Create unsigned transactions with full metadata Update with UTXO and script information Sign with one or multiple parties Combine signatures from different "
  },
  {
    "path": "/docs/bitcoin-development/psbt#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Transaction Construction - Building transactions from scratch Key Management - Managing signing keys Address Generation - Creating and validating addresses Multisig - Multi-signature wallet setups"
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping",
    "title": "Fee Bumping",
    "section": "bitcoin-development",
    "body": "Fee Bumping When a transaction is stuck in the mempool because the fee rate is too low, you can increase the effective fee using Replace-by-Fee (RBF) or Child Pays for Parent (CPFP). This page is a developer-focused guide: when to use which, how to signal RBF, and how to build replacement or child transactions in code. For the protocol rules and fee market, see Transaction Fees and Mempool. When to Use RBF vs CPFP | Situation | Use | |-----------|-----| | You are the sender and control the "
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping#when-to-use-rbf-vs-cpfp",
    "title": "When to Use RBF vs CPFP",
    "section": "bitcoin-development",
    "body": "| Situation | Use | |-----------|-----| | You are the sender and control the inputs | RBF: Create a replacement transaction that pays a higher fee (must meet BIP 125 rules). | | You are the recipient "
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping#rbf-replace-by-fee",
    "title": "RBF: Replace-by-Fee",
    "section": "bitcoin-development",
    "body": "To allow RBF, the original transaction must signal replaceability: at least one input has nSequence &lt; 0xfffffffe (e.g. 0xfffffffd). Then you can broadcast a replacement that spends the same "
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping#cpfp-child-pays-for-parent",
    "title": "CPFP: Child Pays for Parent",
    "section": "bitcoin-development",
    "body": "If you received an output from the stuck transaction, you can create a child transaction that spends that output and attaches a high fee. Miners evaluate the package (parent + child) by combined fee "
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping#package-relay-and-package-rbf",
    "title": "Package Relay and Package RBF",
    "section": "bitcoin-development",
    "body": "Package relay and package RBF allow nodes to accept and relay a package (e.g. parent + child) as a unit and, for package RBF, to replace a package with a new one. These are optional node policies "
  },
  {
    "path": "/docs/bitcoin-development/fee-bumping#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Transaction Fees - RBF/CPFP rules and fee market Transaction Construction - Building and signing transactions Mempool - How unconfirmed transactions are stored and selected Fee Estimation - Getting a "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests",
    "title": "Payment Requests",
    "section": "bitcoin-development",
    "body": "Payment Requests Requesting and receiving Bitcoin payments in applications involves generating a address (or reusing a dedicated one per invoice), communicating amount and recipient to the payer (e.g. via a bitcoin: URI or QR code), and verifying that payment was received. This guide covers BIP 21 bitcoin: URIs, generating and parsing payment requests, and handling verification and refunds. For fiat conversion on invoices, see Price Tracking. For watching addresses, see Blockchain Monitoring. "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#one-address-per-invoice",
    "title": "One Address per Invoice",
    "section": "bitcoin-development",
    "body": "Use a unique address per payment request so you can match incoming transactions to the correct order or customer. Do not reuse a single address for multiple invoices if you need to know who paid what."
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#bip-21-bitcoin-uri",
    "title": "BIP 21 bitcoin: URI",
    "section": "bitcoin-development",
    "body": "BIP 21 defines the bitcoin: URI scheme so wallets can pre-fill address and amount. Format: bitcoin:?amount=&label=&message= address: Required; Bitcoin address (e.g. P2WPKH, P2TR). amount: Optional; "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#generating-a-bitcoin-uri",
    "title": "Generating a bitcoin: URI",
    "section": "bitcoin-development",
    "body": ":::code-group use urlencoding::encode; fn bitcoin_uri(address: &str, amount_sats: Option, label: Option, message: Option) -> String { let mut uri = format!(\"bitcoin:{}\", address); let mut params = "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#parsing-a-bitcoin-uri",
    "title": "Parsing a bitcoin: URI",
    "section": "bitcoin-development",
    "body": ":::code-group use url::Url; fn parse_bitcoin_uri(uri: &str) -> Result, Option, Option), Box> { let u = Url::parse(uri)?; if u.scheme() != \"bitcoin\" { return Err(\"not a bitcoin URI\".into()); } let "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#qr-codes",
    "title": "QR Codes",
    "section": "bitcoin-development",
    "body": "Encode the bitcoin: URI in a QR code so mobile wallets can scan it. Use a QR library for your language (e.g. qrcode in Rust, qrcode in Python, go-qrcode in Go). The payload is the URI string; error "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#verifying-payment",
    "title": "Verifying Payment",
    "section": "bitcoin-development",
    "body": "Unconfirmed: The transaction is in the mempool; it can be replaced (RBF) or double-spent. Do not treat as final for high-value or physical goods unless you accept the risk. Confirmations: Each block "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#refunds",
    "title": "Refunds",
    "section": "bitcoin-development",
    "body": "Never refund to \"the address that sent\" by default: that address may belong to an exchange or shared wallet, not the customer. Either ask the customer for a refund address or use a refund address "
  },
  {
    "path": "/docs/bitcoin-development/payment-requests#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Address Generation - Generating unique addresses per invoice Blockchain Monitoring - Watching for incoming payments Price Tracking - Converting fiat to satoshis for invoice amount Transaction "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring",
    "title": "Blockchain Monitoring",
    "section": "bitcoin-development",
    "body": "Blockchain Monitoring The blockchain is an ordered chain of blocks; the timechain view emphasizes that ordering as a source of time and finality. Monitoring it lets your application react to new blocks, track confirmations, and handle reorgs. Whether you're waiting for payment confirmations, updating balances, or logging chain tip and mempool activity, you need a reliable way to subscribe to block and transaction events. Real-time monitoring allows you to detect new blocks instantly, track "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#zmq-notifications",
    "title": "ZMQ Notifications",
    "section": "bitcoin-development",
    "body": "ZeroMQ (ZMQ) provides real-time notifications for blockchain events without polling. It's much more efficient than repeatedly calling RPC commands. Benefits Instant notifications: No polling delays "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#block-detection",
    "title": "Block Detection",
    "section": "bitcoin-development",
    "body": "Real-Time Block Monitoring with ZMQ :::code-group // In Cargo.toml: hex = \"0.4\" use hex; use zmq; fn monitor_blocks() -> Result> { let context = zmq::Context::new(); let socket = "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#mining-pool-identification",
    "title": "Mining Pool Identification",
    "section": "bitcoin-development",
    "body": "Coinbase Transaction Analysis Mining pools often embed their name or identifier in the coinbase transaction. Extract Pool Information: def identify_pool(block): coinbase_tx = block'tx' coinbase_hex = "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#op-return-analysis",
    "title": "OP_RETURN Analysis",
    "section": "bitcoin-development",
    "body": "Extracting OP_RETURN Data :::code-group fn extract_op_return(tx: &bitcoin::Transaction) -> Vec> { tx.output.iter() .filter_map(|out| { if out.script_pubkey.is_op_return() { "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#transaction-monitoring",
    "title": "Transaction Monitoring",
    "section": "bitcoin-development",
    "body": "Mempool Monitoring with ZMQ :::code-group // In Cargo.toml: hex = \"0.4\" use hex; fn monitor_mempool() -> Result> { let context = zmq::Context::new(); let socket = context.socket(zmq::SUB)?; "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#statistics-and-logging",
    "title": "Statistics and Logging",
    "section": "bitcoin-development",
    "body": "Block Statistics Track Block Metrics: def log_block_stats(block): stats = { 'height': block['height'], 'hash': block['hash'], 'tx_count': len(block['tx']), 'size': block['size'], 'pool': "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#error-handling",
    "title": "Error Handling",
    "section": "bitcoin-development",
    "body": "ZMQ Connection Failures Handle ZMQ Errors: try: socket = context.socket(zmq.SUB) socket.connect(\"tcp://127.0.0.1:28332\") except zmq.ZMQError as e: print(f\"ZMQ connection failed: {e}\") Fall back to "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "For Monitoring Applications Use ZMQ First: Try ZMQ, fall back to polling Error Handling: Handle all error cases Logging: Log important events Rate Limiting: Don't overwhelm RPC Caching: Cache "
  },
  {
    "path": "/docs/bitcoin-development/blockchain-monitoring#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Payment Requests - Watching for incoming payments RPC Commands - Bitcoin Core RPC interface Mempool - Transaction mempool details Block Construction - How miners build blocks Getting Started - "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking",
    "title": "Price Tracking",
    "section": "bitcoin-development",
    "body": "Bitcoin Price Tracking Bitcoin amounts are usually stored and transmitted in satoshis; for user-facing apps you often need to show equivalent value in fiat or other units. Price feeds power balance displays, conversion inputs, and fee estimation in familiar currencies. This guide covers integrating price APIs, handling rate limits, and caching. API Providers CoinGecko Advantages: Free tier available Good rate limits Historical data Multiple currencies :::code-group use reqwest; use "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#api-providers",
    "title": "API Providers",
    "section": "bitcoin-development",
    "body": "CoinGecko Advantages: Free tier available Good rate limits Historical data Multiple currencies :::code-group use reqwest; use serde_json::Value; async fn get_price_coingecko() -> Result> { let url = "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#centralized-price-service",
    "title": "Centralized Price Service",
    "section": "bitcoin-development",
    "body": "Service Architecture Benefits: Single source of truth Caching reduces API calls Fallback mechanisms Rate limit management Implementation: class BitcoinPriceService: def init(self): self.cache = {} "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#caching-strategies",
    "title": "Caching Strategies",
    "section": "bitcoin-development",
    "body": "In-Memory Caching :::code-group use std::collections::HashMap; use std::time::{Duration, Instant}; struct PriceCache { cache: HashMap, duration: Duration, } impl PriceCache { fn get(&self, currency: "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#rate-limiting",
    "title": "Rate Limiting",
    "section": "bitcoin-development",
    "body": "Implementing Rate Limits Simple Rate Limiter: import time from collections import deque class RateLimiter: def init(self, max_calls=10, period=60): self.max_calls = max_calls self.period = period "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#multi-source-fallbacks",
    "title": "Multi-Source Fallbacks",
    "section": "bitcoin-development",
    "body": "Fallback Chain Priority Order: Primary: CoinGecko (best rate limits) Secondary: Yahoo Finance (backup) Tertiary: Local cache (if available) Implementation: def "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#error-handling",
    "title": "Error Handling",
    "section": "bitcoin-development",
    "body": "API Errors Handle Common Errors: def get_price_safe(currency='USD'): try: response = requests.get(url, timeout=5) response.raise_for_status() return response.json() except "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#thread-safety",
    "title": "Thread Safety",
    "section": "bitcoin-development",
    "body": "Concurrent Access Thread-Safe Cache: import threading class ThreadSafePriceService: def init(self): self.cache = {} self.lock = threading.Lock() def get_price(self, currency='USD'): with self.lock: "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "For Developers Use Caching: Reduce API calls Implement Fallbacks: Multiple data sources Rate Limiting: Respect API limits Error Handling: Handle all error cases Thread Safety: Support concurrent "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#common-issues",
    "title": "Common Issues",
    "section": "bitcoin-development",
    "body": "Rate Limit Exceeded Problem: API rate limit reached Solutions: Implement caching Use multiple API sources Reduce request frequency Upgrade API tier (if available) Stale Data Problem: Cached data too "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#summary",
    "title": "Summary",
    "section": "bitcoin-development",
    "body": "Price tracking requires: API Integration: Multiple data sources Caching: Reduce API calls and improve performance Rate Limiting: Respect API limits Fallbacks: Multiple sources for reliability Error "
  },
  {
    "path": "/docs/bitcoin-development/price-tracking#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Payment Requests - Fiat amounts on invoices and payment requests Getting Started - Bitcoin development introduction Libraries & SDKs - HTTP client libraries for each language Blockchain Monitoring - "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns",
    "title": "Bitcoin Script Patterns",
    "section": "bitcoin-development",
    "body": "Bitcoin Script Patterns Bitcoin Script defines spending conditions in locking scripts; Smart Contracts & Advanced Scripting describes how those conditions act as contracts. The patterns here are reusable templates you can turn into scriptPubKeys and use in address generation and transaction construction. You can build and experiment with them in Stack Lab. For a policy language that compiles to Script, see Miniscript. Common Patterns 1. Pay-to-Pubkey-Hash (P2PKH) Standard single-signature: "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#common-patterns",
    "title": "Common Patterns",
    "section": "bitcoin-development",
    "body": "1. Pay-to-Pubkey-Hash (P2PKH) Standard single-signature: ScriptPubKey: OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG ScriptSig: 2. Multisig Multiple signatures required: ScriptPubKey: ... "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#advanced-patterns",
    "title": "Advanced Patterns",
    "section": "bitcoin-development",
    "body": "Escrow Contract Three-party escrow: 2-of-3 Multisig: Buyer + Seller Buyer + Escrow Seller + Escrow Vault Contract Time-delayed recovery: Structure: Hot key: Immediate spend (small) Cold key: Delayed "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#code-examples",
    "title": "Code Examples",
    "section": "bitcoin-development",
    "body": "Creating Common Patterns :::code-group use bitcoin::{Script, ScriptBuf}; use bitcoin::opcodes::all::*; // P2PKH fn create_p2pkh_script(pubkey_hash: &[u8; 20]) -> ScriptBuf { let mut script = "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#miniscript",
    "title": "Miniscript",
    "section": "bitcoin-development",
    "body": "Miniscript is a structured language for expressing spending policies that compiles to Bitcoin Script. Instead of writing raw OP codes directly, you define what must hold (e.g., \"2-of-3 keys\" or \"key "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#best-practices",
    "title": "Best Practices",
    "section": "bitcoin-development",
    "body": "For Developers Use established patterns: Don't reinvent Prefer Miniscript for complex policies: Compile from policy when possible Test thoroughly: Script bugs are costly Consider Taproot: Better "
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Bitcoin Script - Script system OP Codes - Available operations Miniscript - Policy-to-script compiler Smart Contracts - Contract patterns"
  },
  {
    "path": "/docs/bitcoin-development/script-patterns#resources",
    "title": "Resources",
    "section": "bitcoin-development",
    "body": "Bitcoin Script Patterns Miniscript - Playground and reference"
  },
  {
    "path": "/docs/bitcoin-development/miniscript",
    "title": "Miniscript",
    "section": "bitcoin-development",
    "body": "Miniscript Miniscript is a structured language for writing Bitcoin Script that is easier to analyze, compose, and reason about than raw Script. It maps to a well-defined subset of Script and provides guarantees about spending conditions, costs, and the number and type of signatures required. It sits on top of Bitcoin Script and the same smart contract spending conditions, giving you a policy language that compiles to correct Script. Why Miniscript? Raw Bitcoin Script is flexible but hard to "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#why-miniscript",
    "title": "Why Miniscript?",
    "section": "bitcoin-development",
    "body": "Raw Bitcoin Script is flexible but hard to work with: Opaque: Deciding what a script does, what can satisfy it, and how much it costs requires careful analysis. Brittle: Small changes can produce "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#policy-and-fragments",
    "title": "Policy and Fragments",
    "section": "bitcoin-development",
    "body": "Policy A policy is a high-level description of who can spend and under what conditions. Examples: pk(A) — A’s key alone 2 of pk(A), pk(B), pk(C)] — 2-of-3 multisig and(pk(A), after(100)) — A, but "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#correctness-and-safety",
    "title": "Correctness and Safety",
    "section": "bitcoin-development",
    "body": "Miniscript distinguishes: Correctness: Every valid satisfaction (according to the policy) is accepted by the compiled Script. Safety: No satisfaction is possible that the policy was not meant to "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#compilation-to-script",
    "title": "Compilation to Script",
    "section": "bitcoin-development",
    "body": "A Miniscript policy is compiled down to Script (and thus to P2WSH or P2TR Tapscript). The exact output depends on: The target (pre-Taproot P2WSH vs Taproot Tapscript) Optimization options (e.g., "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#use-cases",
    "title": "Use Cases",
    "section": "bitcoin-development",
    "body": "Wallets: Encode withdrawal policies (multisig, timelocks, recovery) and compile to Script; derive addresses and PSBT flows. Vaults and covenants: Express \"can only go to addresses of type X\" or \"must "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#taproot-and-miniscript",
    "title": "Taproot and Miniscript",
    "section": "bitcoin-development",
    "body": "Taproot and Tapscript add: Schnorr and OP_CHECKSIGADD New rules and limits (e.g., 32-byte x-only pubkeys) Miniscript has been extended (see BIP 382 and implementations) to support Tapscript, so the "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#tools-and-libraries",
    "title": "Tools and Libraries",
    "section": "bitcoin-development",
    "body": "miniscript.bitcoin.sipa.be: Playground and reference rust-miniscript: Rust; used in BDK and other wallets C++ miniscript: In Bitcoin Core (e.g., for descriptors and output script analysis) "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Bitcoin Script - Script system Output Descriptors - Miniscript compiles to descriptors Script Patterns - Common patterns and Miniscript Smart Contracts - Contract patterns and Miniscript Taproot - "
  },
  {
    "path": "/docs/bitcoin-development/miniscript#resources",
    "title": "Resources",
    "section": "bitcoin-development",
    "body": "Miniscript (bitcoin.sipa.be) - Playground and specification BIP 382: Miniscript for Tapscript rust-miniscript - Rust implementation"
  },
  {
    "path": "/docs/bitcoin-development/descriptors",
    "title": "Output Descriptors",
    "section": "bitcoin-development",
    "body": "Output Descriptors Output descriptors (BIP 380, BIP 386) are a standardized, human-readable way to describe which output scripts and addresses a wallet can generate. They encode script type, keys, and derivation paths in a single string, so wallets can interoperate, export watch-only setups, and back up \"what to derive\" without ambiguity. This guide covers descriptor syntax, common script expressions, key expressions, and how to use them in code. For policies that compile to Script, see "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#what-descriptors-solve",
    "title": "What Descriptors Solve",
    "section": "bitcoin-development",
    "body": "Traditional backups (e.g. BIP 39 mnemonic) describe keys but not which script types or paths to use. After SegWit and Taproot, \"restore from seed\" could mean P2PKH, P2WPKH, P2TR, or custom scripts. "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#descriptor-structure",
    "title": "Descriptor Structure",
    "section": "bitcoin-development",
    "body": "A descriptor typically has: Script expression: e.g. wpkh, wsh, tr, sh(wpkh(...)) Key expression: e.g. xpub with derivation path Optional checksum: 8 characters after # for error detection Example "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#common-script-expressions",
    "title": "Common Script Expressions",
    "section": "bitcoin-development",
    "body": "| Expression | Meaning | |------------|--------| | pk(key) | Pay to raw public key | | pkh(key) | Pay to public key hash (P2PKH) | | wpkh(key) | Pay to witness public key hash (P2WPKH) | | sh(script) "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#key-expressions-and-derivation",
    "title": "Key Expressions and Derivation",
    "section": "bitcoin-development",
    "body": "xpub / xprv: BIP 32 extended key; path like fingerprint/84h/0h/0h]xpub.../0/ means receive addresses, /1/ means change. Origin: The part in [] (e.g. [d34db33f/84h/0h/0h]) is the key origin; optional "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#parsing-and-validating-descriptors",
    "title": "Parsing and Validating Descriptors",
    "section": "bitcoin-development",
    "body": ":::code-group // Using bdk or rust-bitcoin descriptor support use bdk::descriptor::Descriptor; use std::str::FromStr; fn parse_descriptor(desc: &str) -> Result, Box> { let (desc_with_checksum, _) = "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#deriving-addresses-from-a-descriptor",
    "title": "Deriving Addresses from a Descriptor",
    "section": "bitcoin-development",
    "body": "Bitcoin Core RPCs: getdescriptorinfo (validate and add checksum), deriveaddresses (derive addresses for an index range), importdescriptors (import watch-only or with keys). Other libraries (e.g. BDK, "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#use-cases",
    "title": "Use Cases",
    "section": "bitcoin-development",
    "body": "Watch-only wallets: Export an xpub descriptor (no private keys); another app can derive addresses and watch the blockchain. See Blockchain Monitoring. Backup and restore: One descriptor string (with "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#relation-to-miniscript",
    "title": "Relation to Miniscript",
    "section": "bitcoin-development",
    "body": "Miniscript compiles policies to Script; the result is often wrapped in a descriptor (e.g. wsh(miniscript_expression) or Taproot). So: policy → Miniscript → Script → descriptor. Descriptors can also "
  },
  {
    "path": "/docs/bitcoin-development/descriptors#related-topics",
    "title": "Related Topics",
    "section": "bitcoin-development",
    "body": "Key Management - HD keys and derivation paths Address Generation - Address types and encoding Miniscript - Policy to script and descriptors PSBT - Descriptors in PSBT global map and inputs"
  },
  {
    "path": "/docs/bitcoin-development/descriptors#resources",
    "title": "Resources",
    "section": "bitcoin-development",
    "body": "BIP 380 - Output Script Descriptors BIP 386 - Miniscript within descriptors Bitcoin Core descriptors - Implementation notes"
  },
  {
    "path": "/docs/controversies",
    "title": "Controversies",
    "section": "controversies",
    "body": "Bitcoin Controversies Bitcoin's history is marked by intense debates that have shaped its development and philosophy. These controversies reveal the tensions inherent in a decentralized system: how do you change something designed to resist change? Who decides the rules when there is no ruler? Why Controversies Matter Every major Bitcoin controversy teaches us something about decentralized governance: The Blocksize Wars showed that users, not miners or corporations, ultimately control Bitcoin "
  },
  {
    "path": "/docs/controversies#why-controversies-matter",
    "title": "Why Controversies Matter",
    "section": "controversies",
    "body": "Every major Bitcoin controversy teaches us something about decentralized governance: The Blocksize Wars showed that users, not miners or corporations, ultimately control Bitcoin Mt. Gox taught us "
  },
  {
    "path": "/docs/controversies#antifragile-by-design",
    "title": "Antifragile by Design",
    "section": "controversies",
    "body": "Bitcoin is antifragile: a term coined by Nassim Taleb for systems that don't just survive stress, but grow stronger from it. Every attack has hardened Bitcoin's defenses. Every scam has educated its "
  },
  {
    "path": "/docs/controversies#the-nature-of-bitcoin-debates",
    "title": "The Nature of Bitcoin Debates",
    "section": "controversies",
    "body": "Bitcoin controversies tend to follow a pattern: A proposal emerges that would change Bitcoin's rules or purpose Camps form around different visions for Bitcoin's future Technical arguments mix with "
  },
  {
    "path": "/docs/controversies#major-controversies",
    "title": "Major Controversies",
    "section": "controversies",
    "body": "Protocol Debates The Blocksize Wars (2015-2017) The defining battle over Bitcoin's scaling approach. Big blockers wanted larger blocks for more transactions; small blockers prioritized "
  },
  {
    "path": "/docs/controversies/blocksize-wars",
    "title": "Blocksize Wars",
    "section": "controversies",
    "body": "The Blocksize Wars The Blocksize Wars (2015-2017) were a period of intense debate and conflict within the Bitcoin community over whether to increase Bitcoin's block size limit. This controversy ultimately led to the hard fork that created Bitcoin Cash and fundamentally shaped Bitcoin's development philosophy. The Core Issue The Problem Bitcoin's block size was limited to 1 MB (set by Satoshi Nakamoto in 2010). As Bitcoin adoption grew, this limit became a bottleneck: Transaction Backlog: "
  },
  {
    "path": "/docs/controversies/blocksize-wars#the-core-issue",
    "title": "The Core Issue",
    "section": "controversies",
    "body": "The Problem Bitcoin's block size was limited to 1 MB (set by Satoshi Nakamoto in 2010). As Bitcoin adoption grew, this limit became a bottleneck: Transaction Backlog: Transactions waiting hours or "
  },
  {
    "path": "/docs/controversies/blocksize-wars#the-two-sides",
    "title": "The Two Sides",
    "section": "controversies",
    "body": "Big Blockers Core Belief: Bitcoin should scale on-chain Increase block size to handle more transactions Keep all transactions on the main chain Lower fees through increased capacity Proposed "
  },
  {
    "path": "/docs/controversies/blocksize-wars#timeline-of-events",
    "title": "Timeline of Events",
    "section": "controversies",
    "body": "2010: The 1 MB Limit Satoshi Nakamoto sets 1 MB block size limit Initially a spam protection measure Blocks were mostly empty at the time Limit was meant to be temporary 2015: Early Proposals Bitcoin "
  },
  {
    "path": "/docs/controversies/blocksize-wars#key-arguments",
    "title": "Key Arguments",
    "section": "controversies",
    "body": "Arguments for Bigger Blocks On-Chain Scaling More transactions per block = lower fees Simpler solution (no complex Layer 2) Users want on-chain transactions User Experience Faster confirmations Lower "
  },
  {
    "path": "/docs/controversies/blocksize-wars#technical-details",
    "title": "Technical Details",
    "section": "controversies",
    "body": "Block Size Limits Bitcoin (BTC): Base block size: 1 MB With SegWit: ~2-4 MB effective capacity Weight limit: 4,000,000 weight units Bitcoin Cash (BCH): Started: 8 MB Current: 32 MB Plans for even "
  },
  {
    "path": "/docs/controversies/blocksize-wars#the-outcome",
    "title": "The Outcome",
    "section": "controversies",
    "body": "Bitcoin (BTC) Won Results: Maintained 1 MB base block size Implemented SegWit for scaling Lightning Network developed Focus on decentralization preserved Current Status: ~80% of transactions use "
  },
  {
    "path": "/docs/controversies/blocksize-wars#lessons-learned",
    "title": "Lessons Learned",
    "section": "controversies",
    "body": "1. Hard Forks Are Risky Created permanent chain split Divided community and resources Both chains continue separately 2. Soft Forks Preferred SegWit was a soft fork (backward compatible) No chain "
  },
  {
    "path": "/docs/controversies/blocksize-wars#impact-on-bitcoin",
    "title": "Impact on Bitcoin",
    "section": "controversies",
    "body": "Positive Outcomes Clarified Vision: Bitcoin's focus on decentralization was reinforced SegWit Activation: Enabled Lightning Network and other innovations Community Cohesion: Core developers and "
  },
  {
    "path": "/docs/controversies/blocksize-wars#current-status",
    "title": "Current Status",
    "section": "controversies",
    "body": "Bitcoin (BTC) Block Size: 1 MB base, ~2-4 MB with SegWit Scaling: Lightning Network + SegWit Philosophy: Decentralization first Status: Dominant Bitcoin implementation Bitcoin Cash (BCH) Block Size: "
  },
  {
    "path": "/docs/controversies/blocksize-wars#related-topics",
    "title": "Related Topics",
    "section": "controversies",
    "body": "OP_RETURN Debate - Another major Bitcoin controversy History: Forks - Complete fork history including Bitcoin Cash Lightning Network - The scaling solution that emerged"
  },
  {
    "path": "/docs/controversies/op-return",
    "title": "OP_RETURN Debate",
    "section": "controversies",
    "body": "The OP_RETURN Debate: Bitcoin as Database vs. Financial Network An analysis of the ongoing debate about OP_RETURN, carrier size limits, and Bitcoin's fundamental purpose. OP_RETURN is a Bitcoin Script opcode that creates provably unspendable outputs. When executed, it immediately terminates script execution and marks the transaction as invalid. Script Pattern: OP_RETURN Key Characteristics: Outputs are unspendable: they cannot be used as inputs in future transactions Data is permanently stored "
  },
  {
    "path": "/docs/controversies/op-return#the-technical-reality",
    "title": "The Technical Reality",
    "section": "controversies",
    "body": "Current Implementation (Bitcoin Core v30+) Default Limits Before v30 (Historical): Default limit: 80 bytes per OP_RETURN output Configurable via -datacarriersize parameter Multiple OP_RETURN outputs "
  },
  {
    "path": "/docs/controversies/op-return#the-historical-context",
    "title": "The Historical Context",
    "section": "controversies",
    "body": "2009-2013: Early Days No OP_RETURN: Initially, people used other methods to store data Encoding data in addresses (P2PKH outputs) Using fake addresses with embedded data These methods bloated the "
  },
  {
    "path": "/docs/controversies/op-return#the-recent-controversy",
    "title": "The Recent Controversy",
    "section": "controversies",
    "body": "Bitcoin Core v30 Changes What Changed: Default -datacarriersize increased from 80 bytes to ~1 MB Effectively allows up to 4 MB of data per transaction (block size limit) Can still be configured by "
  },
  {
    "path": "/docs/controversies/op-return#arguments-for-increasing-limits",
    "title": "Arguments For Increasing Limits",
    "section": "controversies",
    "body": "1. \"Users Pay Fees\" Argument: If users are willing to pay transaction fees, they should be able to use block space as they see fit Market forces (fees) will naturally limit abuse No one is forced to "
  },
  {
    "path": "/docs/controversies/op-return#arguments-against-increasing-limits",
    "title": "Arguments Against Increasing Limits",
    "section": "controversies",
    "body": "1. Mission Creep Argument: Bitcoin's purpose is to be \"sound money\" Adding data storage dilutes the mission Should focus on financial transactions, not general data storage 2. Blockchain Bloat "
  },
  {
    "path": "/docs/controversies/op-return#technical-implications",
    "title": "Technical Implications",
    "section": "controversies",
    "body": "Storage Impact Current Blockchain Size: ~500 GB (2024) Growing ~50-100 GB per year With increased OP_RETURN: Could grow faster Pruning: OP_RETURN data can be pruned But initial download still "
  },
  {
    "path": "/docs/controversies/op-return#the-philosophical-divide",
    "title": "The Philosophical Divide",
    "section": "controversies",
    "body": "Two Competing Visions Vision 1: Bitcoin as \"Sound Money\" Core Belief: Bitcoin should be focused solely on being digital gold Financial transactions are the priority Data storage is a distraction \"Do "
  },
  {
    "path": "/docs/controversies/op-return#current-status-and-alternatives",
    "title": "Current Status and Alternatives",
    "section": "controversies",
    "body": "Bitcoin Core (v30+) Status: Default limit: ~1 MB (effectively up to block size) Configurable by node operators Change implemented in v30 Configuration: Disable OP_RETURN entirely -datacarrier=0 Set "
  },
  {
    "path": "/docs/controversies/op-return#conclusion",
    "title": "Conclusion",
    "section": "controversies",
    "body": "The OP_RETURN debate represents a fundamental philosophical divide in the Bitcoin community: Technical Reality: OP_RETURN limits are policy, not consensus Can be configured by node operators Data can "
  },
  {
    "path": "/docs/controversies/ordinals",
    "title": "Ordinals and Inscriptions",
    "section": "controversies",
    "body": "Ordinals and Inscriptions Controversy Ordinals and inscriptions let users attach arbitrary data (images, text, JSON) to individual satoshis using witness data. Introduced in early 2023 by Casey Rodarmor, the Ordinals protocol and related tokens (e.g. BRC-20) sparked a heated debate: are they legitimate use of block space or spam that raises fees and distorts Bitcoin’s purpose? What Are Ordinals and Inscriptions? Ordinals: A numbering scheme that assigns a unique index to each satoshi and tracks "
  },
  {
    "path": "/docs/controversies/ordinals#what-are-ordinals-and-inscriptions",
    "title": "What Are Ordinals and Inscriptions?",
    "section": "controversies",
    "body": "Ordinals: A numbering scheme that assigns a unique index to each satoshi and tracks how they move when UTXOs are spent. It does not change consensus; it is an indexing convention. Inscriptions: Data "
  },
  {
    "path": "/docs/controversies/ordinals#the-debate",
    "title": "The Debate",
    "section": "controversies",
    "body": "“Spam” / “Blockspace for Money Only” Arguments: Bitcoin exists to be sound money and peer-to-peer cash. Storing images, JSON, or token metadata is not monetary use and crowds out normal transactions. "
  },
  {
    "path": "/docs/controversies/ordinals#relation-to-other-disputes",
    "title": "Relation to Other Disputes",
    "section": "controversies",
    "body": "OP_RETURN debate: OP_RETURN stores data in the base transaction and has explicit policy limits (e.g. -datacarriersize). Inscriptions use witness data, which is discounted and prunable; the limits and "
  },
  {
    "path": "/docs/controversies/ordinals#current-state",
    "title": "Current State",
    "section": "controversies",
    "body": "Ordinals and inscriptions are valid under current consensus rules. Changing that would require a soft fork or stricter relay/miner policy. Some node and miner software offers optional filters; there "
  },
  {
    "path": "/docs/controversies/ordinals#for-beginners",
    "title": "For Beginners",
    "section": "controversies",
    "body": "Understanding Ordinals highlights two recurring themes in Bitcoin: Neutrality: The base layer does not distinguish “good” vs “bad” use of block space; it enforces consensus and fee rules. Debates "
  },
  {
    "path": "/docs/controversies/ordinals#see-also",
    "title": "See Also",
    "section": "controversies",
    "body": "Ordinals & Inscriptions – Technical overview OP_RETURN Debate – Data on Bitcoin and policy limits Transaction Fees – Fee market and fee estimation"
  },
  {
    "path": "/docs/controversies/energy-consumption",
    "title": "Energy Consumption",
    "section": "controversies",
    "body": "Energy Consumption Bitcoin's energy consumption is one of the most debated topics in the cryptocurrency space. Critics argue that Bitcoin uses too much energy, while supporters point out that energy use is a security feature and that Bitcoin's consumption should be viewed in context with other global energy uses. The Energy Debate Energy Use Is Not Inherently Bad Using energy is not a moral failing. It is the signature of civilization. The Kardashev scale measures a civilization's advancement "
  },
  {
    "path": "/docs/controversies/energy-consumption#the-energy-debate",
    "title": "The Energy Debate",
    "section": "controversies",
    "body": "Energy Use Is Not Inherently Bad Using energy is not a moral failing. It is the signature of civilization. The Kardashev scale measures a civilization's advancement by its energy consumption. A Type "
  },
  {
    "path": "/docs/controversies/energy-consumption#energy-use-as-a-security-feature",
    "title": "Energy Use as a Security Feature",
    "section": "controversies",
    "body": "Bitcoin's proof-of-work mechanism requires significant computational resources, which translates to energy consumption. This is by design: Attack Cost: To attack Bitcoin, an attacker would need to "
  },
  {
    "path": "/docs/controversies/energy-consumption#renewable-energy-usage",
    "title": "Renewable Energy Usage",
    "section": "controversies",
    "body": "Bitcoin mining has increasingly moved toward renewable energy sources: Hydroelectric Power: Many mining operations use excess hydroelectric power Solar and Wind: Mining operations located near "
  },
  {
    "path": "/docs/controversies/energy-consumption#energy-consumption-in-context",
    "title": "Energy Consumption in Context",
    "section": "controversies",
    "body": "To understand Bitcoin's energy consumption, it's helpful to compare it with other global energy uses. The following data is from 2021: Global Energy Consumption Comparison | Sector | Annual Energy "
  },
  {
    "path": "/docs/controversies/energy-consumption#energy-efficiency-trends",
    "title": "Energy Efficiency Trends",
    "section": "controversies",
    "body": "Bitcoin mining has become more energy-efficient over time: Hardware Improvements: ASIC miners have become more efficient Renewable Energy Adoption: Increasing use of renewable energy sources Hash "
  },
  {
    "path": "/docs/controversies/energy-consumption#the-value-proposition",
    "title": "The Value Proposition",
    "section": "controversies",
    "body": "Supporters argue that Bitcoin's energy consumption is justified by the value it provides: Financial Sovereignty: Enables censorship-resistant, borderless transactions Store of Value: Provides a "
  },
  {
    "path": "/docs/controversies/energy-consumption#environmental-concerns",
    "title": "Environmental Concerns",
    "section": "controversies",
    "body": "Carbon Emissions The environmental impact depends on the energy sources used: Renewable Energy: Minimal carbon footprint Fossil Fuels: Higher carbon emissions Mixed Sources: Impact varies by region "
  },
  {
    "path": "/docs/controversies/energy-consumption#future-outlook",
    "title": "Future Outlook",
    "section": "controversies",
    "body": "Potential Changes Renewable Energy Growth: As renewable energy becomes cheaper, mining will likely use more renewables Efficiency Gains: Continued hardware improvements will increase efficiency "
  },
  {
    "path": "/docs/controversies/energy-consumption#conclusion",
    "title": "Conclusion",
    "section": "controversies",
    "body": "While Bitcoin does consume significant energy, it's important to view this consumption in context: Bitcoin uses a relatively small fraction of global energy Energy consumption is a security feature, "
  },
  {
    "path": "/docs/controversies/energy-consumption#related-topics",
    "title": "Related Topics",
    "section": "controversies",
    "body": "Proof-of-Work - How Bitcoin's consensus mechanism works Mining Economics - Economic incentives in Bitcoin mining Blocksize Wars - Another major Bitcoin controversy"
  },
  {
    "path": "/docs/controversies/energy-consumption#resources",
    "title": "Resources",
    "section": "controversies",
    "body": "Cambridge Bitcoin Electricity Consumption Index - Real-time Bitcoin energy consumption estimates Bitcoin Energy Consumption - Alternative energy consumption estimates"
  },
  {
    "path": "/docs/controversies/criminal-use",
    "title": "Bitcoin and Criminal Use",
    "section": "controversies",
    "body": "Bitcoin and Criminal Use Bitcoin is often framed as the currency of choice for criminals: drug dealers, ransom attacks, money launderers. Critics cite Silk Road, darknet markets, and ransomware as evidence that Bitcoin is inherently a tool for illicit activity. This framing is misleading. Bitcoin is just money. What people do with it is their decision. The vast majority of illicit financial activity globally occurs in US dollars and the traditional banking system, not in Bitcoin. Money Is "
  },
  {
    "path": "/docs/controversies/criminal-use#money-is-neutral",
    "title": "Money Is Neutral",
    "section": "controversies",
    "body": "A Tool, Not an Actor Money is a tool. Like a knife, a car, or a phone, it can be used for good or ill. A knife can prepare dinner or commit violence. A car can transport family or flee a crime. Cash "
  },
  {
    "path": "/docs/controversies/criminal-use#the-usd-reality",
    "title": "The USD Reality",
    "section": "controversies",
    "body": "Where Illicit Activity Actually Lives Most illicit financial activity globally occurs in US dollars and the traditional banking system. Money laundering, sanctions evasion, corruption, drug "
  },
  {
    "path": "/docs/controversies/criminal-use#why-bitcoin-gets-the-blame",
    "title": "Why Bitcoin Gets the Blame",
    "section": "controversies",
    "body": "Transparency Bitcoin's blockchain is public. Every transaction is recorded. When Bitcoin appears in a crime (a ransom payment, a darknet sale), it is visible, traceable, and widely reported. "
  },
  {
    "path": "/docs/controversies/criminal-use#the-traceability-irony",
    "title": "The Traceability Irony",
    "section": "controversies",
    "body": "Bitcoin is one of the least attractive currencies for sophisticated criminals who want to evade detection. Public ledger: Every transaction is recorded. Blockchain monitoring and chain analysis can "
  },
  {
    "path": "/docs/controversies/criminal-use#the-real-question",
    "title": "The Real Question",
    "section": "controversies",
    "body": "The question is not \"Is Bitcoin ever used by criminals?\" Any valuable tool is. The question is: Should we hold money itself responsible for its users' choices? The answer is no. Bitcoin is neutral. "
  },
  {
    "path": "/docs/controversies/criminal-use#related-topics",
    "title": "Related Topics",
    "section": "controversies",
    "body": "Blockchain Monitoring - How on-chain activity can be traced and analyzed Wallet Privacy - Privacy considerations when using Bitcoin Energy Consumption - Another external criticism of Bitcoin"
  },
  {
    "path": "/docs/controversies/criminal-use#resources",
    "title": "Resources",
    "section": "controversies",
    "body": "UNODC Illicit Financial Flows and FinCEN SAR Statistics: reports on illicit financial flows (predominantly fiat) Chainalysis Crypto Crime Report: research on the share of crypto transaction volume "
  },
  {
    "path": "/docs/controversies/etf-rejections",
    "title": "ETF Rejections",
    "section": "controversies",
    "body": "Bitcoin ETF Rejections (2017–2023) For years, the U.S. Securities and Exchange Commission (SEC) rejected or delayed applications for a spot Bitcoin ETF. The main reasons were concerns about manipulation, custody, and market maturity. In January 2024, the SEC finally approved the first spot Bitcoin ETFs. The long refusal and eventual approval are an important part of Bitcoin’s regulatory history. What Is a Spot Bitcoin ETF? A spot Bitcoin ETF holds actual bitcoin (or claims backed by it) and "
  },
  {
    "path": "/docs/controversies/etf-rejections#what-is-a-spot-bitcoin-etf",
    "title": "What Is a Spot Bitcoin ETF?",
    "section": "controversies",
    "body": "A spot Bitcoin ETF holds actual bitcoin (or claims backed by it) and tracks its price. This is different from futures-based ETFs, which use Bitcoin futures contracts. Spot ETFs give traditional "
  },
  {
    "path": "/docs/controversies/etf-rejections#the-rejection-era-20172023",
    "title": "The Rejection Era (2017–2023)",
    "section": "controversies",
    "body": "Main SEC Concerns The SEC repeatedly pointed to: Manipulation: Bitcoin spot markets were seen as more exposed to manipulation (wash trading, spoofing, limited oversight) than regulated futures "
  },
  {
    "path": "/docs/controversies/etf-rejections#january-2024-spot-bitcoin-etfs-approved",
    "title": "January 2024: Spot Bitcoin ETFs Approved",
    "section": "controversies",
    "body": "On January 10, 2024, the SEC approved 11 spot Bitcoin ETF applications (including from BlackRock, Fidelity, Grayscale, and others). Trading began shortly after. The approvals followed: The Grayscale "
  },
  {
    "path": "/docs/controversies/etf-rejections#why-this-controversy-matters",
    "title": "Why This Controversy Matters",
    "section": "controversies",
    "body": "Regulation vs innovation: The rejections showed that regulators can block or delay access to Bitcoin for a long time, even when demand exists. Approval showed that legal and political pressure, plus "
  },
  {
    "path": "/docs/controversies/etf-rejections#see-also",
    "title": "See Also",
    "section": "controversies",
    "body": "Bitcoin ETF – Glossary definition Historical Milestones – 2024 Spot Bitcoin ETFs Not Your Keys, Not Your Coins – Self-custody"
  },
  {
    "path": "/docs/controversies/mt-gox",
    "title": "Mt. Gox Collapse",
    "section": "controversies",
    "body": "Mt. Gox Collapse Mt. Gox was once the world's largest Bitcoin exchange, handling over 70% of all Bitcoin transactions at its peak. In February 2014, it collapsed spectacularly, losing approximately 850,000 BTC (worth ~$450 million at the time, and tens of billions at later prices). The Mt. Gox disaster became Bitcoin's defining cautionary tale and permanently shaped how the community thinks about custody, exchange security, and the principle of \"not your keys, not your coins.\" The Rise of Mt. "
  },
  {
    "path": "/docs/controversies/mt-gox#the-rise-of-mt-gox",
    "title": "The Rise of Mt. Gox",
    "section": "controversies",
    "body": "Origins Mt. Gox began as a trading platform for Magic: The Gathering cards (the name stands for \"Magic: The Gathering Online eXchange\"). In 2010, programmer Jed McCaleb repurposed it as a Bitcoin "
  },
  {
    "path": "/docs/controversies/mt-gox#the-collapse",
    "title": "The Collapse",
    "section": "controversies",
    "body": "Warning Signs Problems had been brewing for years: 2011 Hack: Mt. Gox was hacked, losing 25,000 BTC. This was kept quiet. Withdrawal Delays: Users increasingly reported slow or failed withdrawals "
  },
  {
    "path": "/docs/controversies/mt-gox#what-happened",
    "title": "What Happened?",
    "section": "controversies",
    "body": "The Official Story Mt. Gox blamed \"transaction malleability\", a known Bitcoin quirk where transaction IDs could be changed before confirmation without invalidating the transaction. The exchange "
  },
  {
    "path": "/docs/controversies/mt-gox#the-aftermath",
    "title": "The Aftermath",
    "section": "controversies",
    "body": "Victims Approximately 24,000 creditors lost funds. Many were early Bitcoin adopters who had their entire holdings on the exchange. The bankruptcy proceedings have dragged on for nearly a decade. "
  },
  {
    "path": "/docs/controversies/mt-gox#lessons-learned",
    "title": "Lessons Learned",
    "section": "controversies",
    "body": "\"Not Your Keys, Not Your Coins\" The Mt. Gox collapse became the defining argument for self-custody. When you leave Bitcoin on an exchange: You don't own Bitcoin; you own an IOU You trust the "
  },
  {
    "path": "/docs/controversies/mt-gox#the-ongoing-saga",
    "title": "The Ongoing Saga",
    "section": "controversies",
    "body": "Bankruptcy Proceedings The Mt. Gox bankruptcy has been one of the longest and most complex in cryptocurrency history: Civil Rehabilitation: In 2018, proceedings converted from bankruptcy to civil "
  },
  {
    "path": "/docs/controversies/mt-gox#historical-significance",
    "title": "Historical Significance",
    "section": "controversies",
    "body": "Mt. Gox represents a pivotal moment in Bitcoin history: End of Innocence: Bitcoin's early, naive era ended. The community learned that enthusiasm wasn't enough; security and proper engineering "
  },
  {
    "path": "/docs/controversies/mt-gox#conclusion",
    "title": "Conclusion",
    "section": "controversies",
    "body": "Mt. Gox is the ghost that haunts every Bitcoin exchange. Its collapse cost early adopters billions of dollars and years of legal limbo. But it also taught the Bitcoin community invaluable lessons "
  },
  {
    "path": "/docs/controversies/mt-gox#related-topics",
    "title": "Related Topics",
    "section": "controversies",
    "body": "Blocksize Wars - Another major Bitcoin controversy Energy Consumption - The energy debate OP_RETURN Debate - Data storage on Bitcoin"
  },
  {
    "path": "/docs/controversies/mt-gox#resources",
    "title": "Resources",
    "section": "controversies",
    "body": "Mt. Gox Legal - Official bankruptcy proceedings Wizsec Research - Detailed investigation into the Mt. Gox hack"
  },
  {
    "path": "/docs/controversies/craig-wright",
    "title": "Craig Wright",
    "section": "controversies",
    "body": "Craig Wright / \"Faketoshi\" Craig Steven Wright is an Australian computer scientist who has claimed since 2016 to be Satoshi Nakamoto, the pseudonymous creator of Bitcoin. Despite years of assertions, lawsuits, and media appearances, Wright has never provided cryptographic proof of his claim. This is something the real Satoshi could trivially do by signing a message with Satoshi's known private keys. The Bitcoin community overwhelmingly rejects Wright's claims, derisively calling him "
  },
  {
    "path": "/docs/controversies/craig-wright#the-claim",
    "title": "The Claim",
    "section": "controversies",
    "body": "What Would Prove It The real Satoshi Nakamoto has access to: Private keys that mined the earliest Bitcoin blocks The private key behind the genesis block Keys controlling approximately 1 million "
  },
  {
    "path": "/docs/controversies/craig-wright#timeline-of-events",
    "title": "Timeline of Events",
    "section": "controversies",
    "body": "2015: Initial Leaks In December 2015, Wired and Gizmodo published articles suggesting Craig Wright might be Satoshi, based on leaked documents and emails. Within days, Australian police raided "
  },
  {
    "path": "/docs/controversies/craig-wright#evidence-of-fraud",
    "title": "Evidence of Fraud",
    "section": "controversies",
    "body": "Forged Documents Multiple documents Wright presented as evidence have been proven to be backdated or fabricated: PGP keys: Keys allegedly created in 2008 were shown to use cryptographic parameters "
  },
  {
    "path": "/docs/controversies/craig-wright#community-response",
    "title": "Community Response",
    "section": "controversies",
    "body": "Bitcoin Community The Bitcoin community overwhelmingly rejects Wright's claims: \"Faketoshi\": The derisive nickname is universally used Developers: Bitcoin Core developers have been vocal in their "
  },
  {
    "path": "/docs/controversies/craig-wright#why-does-it-matter",
    "title": "Why Does It Matter?",
    "section": "controversies",
    "body": "Protocol Control If Wright were accepted as Satoshi, he could claim authority over Bitcoin's direction. His vision involves: Massive block sizes (128MB+) Removing privacy features Making Bitcoin more "
  },
  {
    "path": "/docs/controversies/craig-wright#the-real-satoshi",
    "title": "The Real Satoshi",
    "section": "controversies",
    "body": "While Wright is not Satoshi, the real Satoshi's identity remains unknown. Key facts: Satoshi's coins haven't moved: The ~1 million BTC from early mining remain untouched since 2010 No public "
  },
  {
    "path": "/docs/controversies/craig-wright#conclusion",
    "title": "Conclusion",
    "section": "controversies",
    "body": "The Craig Wright saga is a bizarre footnote in Bitcoin history: a man who claims to be the creator but cannot prove it, who has forged documents and lost lawsuits, yet continues to assert his "
  },
  {
    "path": "/docs/controversies/craig-wright#related-topics",
    "title": "Related Topics",
    "section": "controversies",
    "body": "Mt. Gox Collapse - Exchange disaster that shaped Bitcoin culture Blocksize Wars - The scaling debate that led to Bitcoin Cash OP_RETURN Debate - Data storage controversy"
  },
  {
    "path": "/docs/controversies/craig-wright#resources",
    "title": "Resources",
    "section": "controversies",
    "body": "COPA v. Wright Judgment - The full UK court ruling Wizsec: Wright's Fake Documents - Detailed forensic analysis stopcraigwright.com - Community documentation of Wright's claims"
  },
  {
    "path": "/docs/advanced",
    "title": "Advanced Topics",
    "section": "advanced",
    "body": "Advanced Topics This section covers advanced, experimental, and specialized Bitcoin topics that extend beyond the core protocol and standard development practices. What's in This Section Layer 2 & Scaling Solutions Sidechains & Layer 2 - Alternative scaling approaches including Liquid Network and Rootstock Statechains - Federated sidechains for state transfer Zero-Conf Channels - Experimental Lightning channels usable before confirmation Trampoline Routing - Advanced Lightning routing for "
  },
  {
    "path": "/docs/advanced#whats-in-this-section",
    "title": "What's in This Section",
    "section": "advanced",
    "body": "Layer 2 & Scaling Solutions Sidechains & Layer 2 - Alternative scaling approaches including Liquid Network and Rootstock Statechains - Federated sidechains for state transfer Zero-Conf Channels - "
  },
  {
    "path": "/docs/advanced#experimental-features",
    "title": "Experimental Features",
    "section": "advanced",
    "body": "Warning: Some topics in this section describe experimental or early-stage features: Zero-Conf Channels: Requires trust assumptions Trampoline Routing: Limited implementation support DLCs: Emerging "
  },
  {
    "path": "/docs/advanced#related-sections",
    "title": "Related Sections",
    "section": "advanced",
    "body": "Bitcoin Protocol - Core protocol documentation Lightning Network - Standard Lightning features Wallets - Privacy techniques and smart contracts Setup & Infrastructure - Setup and infrastructure for "
  },
  {
    "path": "/docs/advanced/sidechains",
    "title": "Sidechains & Layer 2",
    "section": "advanced",
    "body": "Sidechains & Layer 2 Alternatives Sidechains are separate blockchains that are pegged to Bitcoin, allowing bitcoin to be moved between the main chain and sidechain. They provide alternative scaling solutions and specialized features. Sidechains are independent blockchains with their own consensus rules that are pegged to Bitcoin: --- Bitcoin Mainnet --- Lock bitcoin] --> [Receive sidechain tokens] --- Sidechain --- [Receive tokens] --> [Use sidechain features] --> [Unlock to return to Bitcoin "
  },
  {
    "path": "/docs/advanced/sidechains#major-sidechains",
    "title": "Major Sidechains",
    "section": "advanced",
    "body": "Liquid Network Liquid is a federated sidechain: Features: Faster blocks (1 minute) Confidential transactions Asset issuance Federated consensus (functionaries) Use cases: Exchange settlements Faster "
  },
  {
    "path": "/docs/advanced/sidechains#how-sidechains-work",
    "title": "How Sidechains Work",
    "section": "advanced",
    "body": "Two-Way Peg Lock bitcoin on mainnet Wait for confirmation period Receive tokens on sidechain Use sidechain features Lock tokens on sidechain Wait for confirmation Receive bitcoin on mainnet Peg "
  },
  {
    "path": "/docs/advanced/sidechains#comparison-with-lightning",
    "title": "Comparison with Lightning",
    "section": "advanced",
    "body": "| Feature | Sidechains | Lightning Network | |---------|------------|-------------------| | Trust Model | Varies (federated/SPV) | Trustless | | Speed | Sidechain block time | Instant | | Features | "
  },
  {
    "path": "/docs/advanced/sidechains#limitations",
    "title": "Limitations",
    "section": "advanced",
    "body": "Trust Requirements Federated sidechains: Require trust in functionaries SPV sidechains: More trustless but complex Security: Sidechain security separate from Bitcoin Trade-offs Trust vs. Features: "
  },
  {
    "path": "/docs/advanced/sidechains#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Lightning Network - Payment channel network Statechains - Alternative approach Governance - How Bitcoin evolves Bitcoin Adoption - Adoption and outlook (Layer 2, sidechains, ecosystem trends)"
  },
  {
    "path": "/docs/advanced/sidechains#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "Liquid Network Rootstock"
  },
  {
    "path": "/docs/advanced/atomic-swaps",
    "title": "Atomic Swaps",
    "section": "advanced",
    "body": "Atomic Swaps Atomic swaps enable trustless peer-to-peer exchange of cryptocurrencies across different blockchains without requiring a trusted third party or centralized exchange. Atomic swaps use hash time-locked contracts (HTLCs) to ensure that either both parties receive their funds or neither does: Atomic Swap: Alice wants to trade BTC for LTC Bob wants to trade LTC for BTC Either both succeed or both fail No trusted intermediary needed How Atomic Swaps Work Process sequenceDiagram "
  },
  {
    "path": "/docs/advanced/atomic-swaps#how-atomic-swaps-work",
    "title": "How Atomic Swaps Work",
    "section": "advanced",
    "body": "Process sequenceDiagram participant Alice participant Bob Alice->>Alice: Creates HTLC on Bitcoin (locks BTC, hash lock, time lock) Bob->>Bob: Creates HTLC on Litecoin (same hash, shorter time lock) "
  },
  {
    "path": "/docs/advanced/atomic-swaps#code-examples",
    "title": "Code Examples",
    "section": "advanced",
    "body": "Creating HTLC :::code-group use bitcoin::{Script, ScriptBuf}; use bitcoin::opcodes::all::*; fn create_htlc_script( hash: &[u8; 32], recipient_pubkey: &[u8; 33], refund_pubkey: &[u8; 33], locktime: "
  },
  {
    "path": "/docs/advanced/atomic-swaps#lightning-network-swaps",
    "title": "Lightning Network Swaps",
    "section": "advanced",
    "body": "Atomic swaps can also work on Lightning Network: Lightning Atomic Swap: Swap between Lightning channels Instant execution Lower fees Requires channel liquidity"
  },
  {
    "path": "/docs/advanced/atomic-swaps#limitations",
    "title": "Limitations",
    "section": "advanced",
    "body": "Requirements Compatible blockchains: Both must support HTLCs Hash function compatibility: Same hash function Timing coordination: Time locks must be coordinated Liquidity: Both parties need funds "
  },
  {
    "path": "/docs/advanced/atomic-swaps#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "HTLCs - Hash time-locked contracts Timelocks - Time-based conditions Lightning Network - Off-chain swaps"
  },
  {
    "path": "/docs/advanced/atomic-swaps#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "Atomic Swaps"
  },
  {
    "path": "/docs/advanced/dlcs",
    "title": "Discreet Log Contracts",
    "section": "advanced",
    "body": "Discreet Log Contracts (DLCs) Discreet Log Contracts (DLCs) enable Bitcoin smart contracts that depend on external data (oracles) without revealing contract details on-chain until execution. DLCs are smart contracts that: Use oracles: Depend on external data (prices, events) Privacy-preserving: Contract terms hidden until execution Trustless: No need to trust oracle (uses adaptor signatures) Bitcoin-native: Work on Bitcoin blockchain How DLCs Work Oracle Attestation Oracle signs outcome data "
  },
  {
    "path": "/docs/advanced/dlcs#how-dlcs-work",
    "title": "How DLCs Work",
    "section": "advanced",
    "body": "Oracle Attestation Oracle signs outcome data Signature reveals outcome Contract parties use signature Contract executes based on outcome Adaptor Signatures DLCs use adaptor signatures: Adaptor "
  },
  {
    "path": "/docs/advanced/dlcs#use-cases",
    "title": "Use Cases",
    "section": "advanced",
    "body": "Sports Bet (Concrete Example) Two parties create a DLC: \"Team A wins\" vs \"Team B wins.\" An oracle attests to the match result. The contract settles automatically: the winner's key can spend the "
  },
  {
    "path": "/docs/advanced/dlcs#code-examples",
    "title": "Code Examples",
    "section": "advanced",
    "body": "Creating a DLC :::code-group // DLC implementation requires specialized libraries // This is a conceptual example struct DLCOutcome { value: u64, oracle_signature: [u8; 64], } fn execute_dlc( "
  },
  {
    "path": "/docs/advanced/dlcs#oracle-providers",
    "title": "Oracle Providers",
    "section": "advanced",
    "body": "Types of Oracles Single Oracle: One data source Multi-Oracle: Multiple sources, consensus Decentralized Oracles: Distributed data sources Trust Model Oracle Trust: Oracle provides data Parties trust "
  },
  {
    "path": "/docs/advanced/dlcs#limitations",
    "title": "Limitations",
    "section": "advanced",
    "body": "Current State Early stage: Active development Limited tooling: Few user-friendly implementations Oracle dependency: Requires trusted oracles Complexity: Technical knowledge required Challenges Oracle "
  },
  {
    "path": "/docs/advanced/dlcs#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Smart Contracts - Bitcoin scripting Timelocks - Time-based conditions Taproot - Better privacy for contracts"
  },
  {
    "path": "/docs/advanced/dlcs#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "DLC Specification DLC Developers"
  },
  {
    "path": "/docs/advanced/statechains",
    "title": "Statechains",
    "section": "advanced",
    "body": "Statechains Statechains are a scaling solution that allows transferring bitcoin ownership off-chain through a federated service without requiring on-chain transactions for each transfer. Statechains enable off-chain bitcoin transfers: Concept: Lock bitcoin on-chain once Transfer ownership off-chain No on-chain transaction per transfer Federated service manages state How Statechains Work Initial Setup User locks bitcoin on-chain Creates statechain entry Federated service holds key share User "
  },
  {
    "path": "/docs/advanced/statechains#how-statechains-work",
    "title": "How Statechains Work",
    "section": "advanced",
    "body": "Initial Setup User locks bitcoin on-chain Creates statechain entry Federated service holds key share User holds key share Transfers User transfers to recipient Key shares updated off-chain No "
  },
  {
    "path": "/docs/advanced/statechains#benefits",
    "title": "Benefits",
    "section": "advanced",
    "body": "Advantages No on-chain fees: Per transfer Fast transfers: Instant off-chain Bitcoin native: Uses real bitcoin No channel limits: No liquidity constraints Limitations Federated trust: Requires trusted "
  },
  {
    "path": "/docs/advanced/statechains#comparison",
    "title": "Comparison",
    "section": "advanced",
    "body": "| Feature | Statechains | Lightning | Sidechains | |---------|-------------|-----------|------------| | Trust | Federated | Trustless | Varies | | Fees | Low | Very low | Sidechain fees | | Speed | "
  },
  {
    "path": "/docs/advanced/statechains#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Sidechains - Alternative scaling Lightning Network - Payment channels Privacy Techniques - Privacy improvements"
  },
  {
    "path": "/docs/advanced/statechains#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "Statechains Research"
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions",
    "title": "Ordinals & Inscriptions",
    "section": "advanced",
    "body": "Ordinals & Inscriptions Ordinals and inscriptions are a method for attaching arbitrary data to individual satoshis on the Bitcoin blockchain. Introduced in early 2023 by Casey Rodarmor, the Ordinals protocol assigns unique identifiers to satoshis and allows \"inscribing\" content (images, text, JSON, or other files) into witness data that gets stored on-chain. The Ordinals protocol assigns a unique, sequential number to each satoshi based on the order it was mined. This creates a way to identify "
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#inscriptions",
    "title": "Inscriptions",
    "section": "advanced",
    "body": "Inscriptions use the Ordinals protocol to attach content to a specific satoshi. The content is stored in the witness (SegWit) portion of a transaction, often in an OP_IF/OP_ENDIF or similar pattern "
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#brc-20-and-other-token-standards",
    "title": "BRC-20 and Other Token Standards",
    "section": "advanced",
    "body": "BRC-20 is an experimental, fungible token standard on Bitcoin that uses JSON inscriptions to define \"transfer\" and \"mint\" operations. Similar in concept to ERC-20 on Ethereum, BRC-20 tokens do not "
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#impact-on-bitcoin",
    "title": "Impact on Bitcoin",
    "section": "advanced",
    "body": "Blockspace and Fees Inscriptions and BRC-20 can generate many transactions competing for block space During peaks, fee rates increased, affecting users making ordinary on-chain payments Consensus and "
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#technical-summary",
    "title": "Technical Summary",
    "section": "advanced",
    "body": "| Aspect | Ordinals | Inscriptions | |--------|----------|---------------| | Purpose | Number and track satoshis | Attach data to a satoshi | | Storage | No extra data; ordering only | Witness "
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "OP_RETURN Debate – Data on Bitcoin and blockspace use SegWit – Witness discount and structure Transaction Fees – Fee market and fee estimation Mempool – How transactions are queued"
  },
  {
    "path": "/docs/advanced/ordinals-inscriptions#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "Ordinals Handbook – Official Ordinals documentation BRC-20 Spec – BRC-20 experiment description Runes – Runes protocol overview"
  },
  {
    "path": "/docs/advanced/bloom-filters",
    "title": "Bloom Filters",
    "section": "advanced",
    "body": "Bloom Filters Bloom filters are a probabilistic data structure used by SPV (Simplified Payment Verification) clients to request relevant transactions from full nodes without revealing exactly which addresses they're interested in. Bloom filters allow SPV clients to: Request transactions: Without revealing addresses Privacy: Partial privacy protection Efficiency: Compact representation False positives: Possible but manageable sequenceDiagram participant SPV as SPV client participant Node as Full "
  },
  {
    "path": "/docs/advanced/bloom-filters#how-bloom-filters-work",
    "title": "How Bloom Filters Work",
    "section": "advanced",
    "body": "Construction Add addresses to filter Hash addresses multiple times Set bits in filter array Send filter to full node Node filters transactions Returns matching transactions Querying Full Node: "
  },
  {
    "path": "/docs/advanced/bloom-filters#privacy-trade-offs",
    "title": "Privacy Trade-offs",
    "section": "advanced",
    "body": "Privacy Benefits Address hiding: Doesn't reveal exact addresses Plausible deniability: False positives provide cover Privacy Limitations Pattern analysis: Multiple queries reveal patterns False "
  },
  {
    "path": "/docs/advanced/bloom-filters#modern-alternatives",
    "title": "Modern Alternatives",
    "section": "advanced",
    "body": "Compact Block Filters (BIP 158) Compact block filters replace bloom filters: Benefits: Better privacy More efficient Standardized format Used by modern SPV clients Comparison | Feature | Bloom "
  },
  {
    "path": "/docs/advanced/bloom-filters#code-examples",
    "title": "Code Examples",
    "section": "advanced",
    "body": "Creating a Bloom Filter :::code-group use bitcoin::bloom::BloomFilter; use bitcoin::hashes::Hash; use bitcoin::hash_types::FilterHash; fn create_bloom_filter(addresses: &[String]) -> BloomFilter { "
  },
  {
    "path": "/docs/advanced/bloom-filters#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "SPV - Simplified payment verification Node Types - Different node configurations Privacy Techniques - Privacy improvements"
  },
  {
    "path": "/docs/advanced/bloom-filters#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "BIP 37: Bloom Filters BIP 158: Compact Block Filters"
  },
  {
    "path": "/docs/advanced/zero-conf-channels",
    "title": "Zero-Conf Channels",
    "section": "advanced",
    "body": "Zero-Conf Channels Zero-conf channels (also called turbo channels) allow Lightning channels to be used immediately after the funding transaction is broadcast, without waiting for blockchain confirmations. The Confirmation Problem Standard Lightning channel opening requires: Broadcast funding transaction Wait for 3-6 confirmations (30-60 minutes) Channel becomes usable Impact: Users must wait before they can send or receive payments through the new channel. How Zero-Conf Works Zero-conf channels "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#the-confirmation-problem",
    "title": "The Confirmation Problem",
    "section": "advanced",
    "body": "Standard Lightning channel opening requires: Broadcast funding transaction Wait for 3-6 confirmations (30-60 minutes) Channel becomes usable Impact: Users must wait before they can send or receive "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#how-zero-conf-works",
    "title": "How Zero-Conf Works",
    "section": "advanced",
    "body": "Zero-conf channels allow immediate use by accepting unconfirmed funding: Standard Channel: Fund tx broadcast → Wait 3-6 blocks → Channel active Zero-Conf Channel: Fund tx broadcast → Channel active "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#use-cases",
    "title": "Use Cases",
    "section": "advanced",
    "body": "Lightning Service Providers (LSPs) Most common use case: User → LSP: \"I want inbound liquidity\" LSP → User: Opens zero-conf channel User: Can receive payments immediately LSP: Trusts their own "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#trust-model",
    "title": "Trust Model",
    "section": "advanced",
    "body": "Who Trusts Whom? | Scenario | Trust Required | |----------|----------------| | LSP opens to user | LSP trusts itself | | User opens to LSP | LSP trusts user (risky) | | Peer-to-peer | Mutual trust "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#implementation",
    "title": "Implementation",
    "section": "advanced",
    "body": "LND Configuration lnd.conf - Enable zero-conf channels [protocol] protocol.option-scid-alias=true protocol.zero-conf=true Per-peer trust (open with --zero_conf flag) lncli openchannel --node_key= "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#feature-negotiation",
    "title": "Feature Negotiation",
    "section": "advanced",
    "body": "Zero-conf requires both peers to support: | Feature Bit | Name | Purpose | |-------------|------|---------| | 44/45 | option_scid_alias | Alias-based channel IDs | | 50/51 | option_zeroconf | "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#limitations",
    "title": "Limitations",
    "section": "advanced",
    "body": "No Forwarding Zero-conf channels cannot forward payments until confirmed: Before Confirmation: Can send through channel: Yes Can receive to channel: Yes Can route THROUGH channel: No This prevents "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#security-considerations",
    "title": "Security Considerations",
    "section": "advanced",
    "body": "Double-Spend Attack Most significant risk: Attacker opens zero-conf channel Victim accepts and provides value Attacker broadcasts competing tx (double-spend) Funding tx never confirms Channel never "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#best-practices",
    "title": "Best Practices",
    "section": "advanced",
    "body": "For LSPs Only open TO users: Don't accept zero-conf from untrusted peers Monitor funding txs: Watch for conflicts in mempool Limit exposure: Cap zero-conf channel sizes Fast confirmation: Use "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#flow-diagram",
    "title": "Flow Diagram",
    "section": "advanced",
    "body": "sequenceDiagram participant User participant LSP User->>LSP: Request channel LSP->>User: Accept (zero-conf) LSP->>User: Funding tx created LSP->>User: Channel active! (no wait) Note over User,LSP: "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#comparison",
    "title": "Comparison",
    "section": "advanced",
    "body": "| Aspect | Standard | Zero-Conf | |--------|----------|-----------| | Time to use | 30-60 min | Seconds | | Trust needed | None | Yes (funder) | | Can forward | Yes | After confirm | | Double-spend "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#summary",
    "title": "Summary",
    "section": "advanced",
    "body": "Zero-conf channels provide: Instant usability: No waiting for confirmations Better UX: Seamless onboarding experience LSP friendly: Perfect for liquidity providers Trust trade-off: Speed in exchange "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#when-to-use-zero-conf",
    "title": "When to Use Zero-Conf",
    "section": "advanced",
    "body": "Good fit: LSP opening channel to user Merchant onboarding via trusted provider Mobile wallet initial setup Poor fit: Peer-to-peer with strangers Large channel amounts When you're the one providing "
  },
  {
    "path": "/docs/advanced/zero-conf-channels#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Channels - Channel lifecycle Anchor Outputs - Modern channel format"
  },
  {
    "path": "/docs/advanced/zero-conf-channels#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "BOLT 2: Zero-Conf LND Zero-Conf Guide"
  },
  {
    "path": "/docs/advanced/trampoline-routing",
    "title": "Trampoline Routing",
    "section": "advanced",
    "body": "Trampoline Routing Trampoline routing allows lightweight Lightning clients to delegate pathfinding to intermediate nodes. Instead of computing the entire route, the sender specifies trampoline nodes that find the path to the destination. The Mobile Routing Problem Standard Lightning routing requires: Downloading the entire network graph (~100MB+) Keeping the graph synchronized Computing routes through thousands of nodes Problems for mobile: Bandwidth: Downloading/syncing graph uses data "
  },
  {
    "path": "/docs/advanced/trampoline-routing#the-mobile-routing-problem",
    "title": "The Mobile Routing Problem",
    "section": "advanced",
    "body": "Standard Lightning routing requires: Downloading the entire network graph (~100MB+) Keeping the graph synchronized Computing routes through thousands of nodes Problems for mobile: Bandwidth: "
  },
  {
    "path": "/docs/advanced/trampoline-routing#how-trampoline-works",
    "title": "How Trampoline Works",
    "section": "advanced",
    "body": "Instead of full pathfinding, the sender: Picks one or more \"trampoline nodes\" Creates an onion to the first trampoline Tells the trampoline where to forward (next trampoline or destination) "
  },
  {
    "path": "/docs/advanced/trampoline-routing#architecture",
    "title": "Architecture",
    "section": "advanced",
    "body": "Two-Layer Onion Trampoline uses nested onion routing: [Outer Onion sender builds] ├── Layer 1: First hop ├── Layer 2: Second hop └── Layer 3: Trampoline T1 ├── Next trampoline: T2 └── Or: Final "
  },
  {
    "path": "/docs/advanced/trampoline-routing#privacy-trade-offs",
    "title": "Privacy Trade-offs",
    "section": "advanced",
    "body": "What Trampolines Learn | Information | Standard | Trampoline | |-------------|----------|------------| | Sender identity | Hidden | Hidden from T2+, known to T1 | | Recipient identity | Hidden | "
  },
  {
    "path": "/docs/advanced/trampoline-routing#implementation",
    "title": "Implementation",
    "section": "advanced",
    "body": "Feature Bits Trampoline support advertised via: | Bit | Name | Description | |-----|------|-------------| | 56/57 | trampoline_routing | Trampoline node support | TLV Payload Trampoline data in inner "
  },
  {
    "path": "/docs/advanced/trampoline-routing#use-cases",
    "title": "Use Cases",
    "section": "advanced",
    "body": "Mobile Wallets Primary use case: Mobile App: No graph storage needed Instant payments (no route calculation) Lower bandwidth usage Better battery life Hardware Wallets Limited devices benefit from "
  },
  {
    "path": "/docs/advanced/trampoline-routing#current-support",
    "title": "Current Support",
    "section": "advanced",
    "body": "Phoenix Wallet (ACINQ) Primary trampoline implementation: Uses ACINQ nodes as trampolines Fully mobile-optimized No graph download required Eclair ACINQ's node implementation supports trampoline. "
  },
  {
    "path": "/docs/advanced/trampoline-routing#comparison",
    "title": "Comparison",
    "section": "advanced",
    "body": "| Aspect | Standard | Trampoline | |--------|----------|------------| | Graph needed | Yes (~100MB) | No | | Pathfinding | Client | Trampoline node | | Privacy | Maximum | Reduced | | Latency | "
  },
  {
    "path": "/docs/advanced/trampoline-routing#security-considerations",
    "title": "Security Considerations",
    "section": "advanced",
    "body": "Trust in Trampolines You trust trampolines to: Actually forward your payment Not charge excessive fees Maintain privacy (within limits) Mitigations: Use reputable trampoline providers Specify max "
  },
  {
    "path": "/docs/advanced/trampoline-routing#multi-trampoline-routes",
    "title": "Multi-Trampoline Routes",
    "section": "advanced",
    "body": "For better privacy and reliability: Single Trampoline: Sender → T1 → [...] → Recipient (T1 knows sender AND recipient) Multi-Trampoline: Sender → T1 → [...] → T2 → [...] → Recipient (T1 knows sender, "
  },
  {
    "path": "/docs/advanced/trampoline-routing#fee-structure",
    "title": "Fee Structure",
    "section": "advanced",
    "body": "Trampoline fees typically include: Base Fee: Fixed per-payment charge Proportional: Percentage of amount Route Budget: Max for underlying route Example: Payment: 100,000 sats Trampoline base: 1,000 "
  },
  {
    "path": "/docs/advanced/trampoline-routing#future-developments",
    "title": "Future Developments",
    "section": "advanced",
    "body": "BOLT12 Integration Trampoline may integrate with offers: Recipient specifies preferred trampolines Automatic trampoline selection Better privacy through randomization Trampoline Networks Potential "
  },
  {
    "path": "/docs/advanced/trampoline-routing#summary",
    "title": "Summary",
    "section": "advanced",
    "body": "Trampoline routing provides: Mobile optimization: No graph sync needed Delegated pathfinding: Trampolines compute routes Reduced bandwidth: Minimal data requirements Battery savings: Less computation "
  },
  {
    "path": "/docs/advanced/trampoline-routing#when-to-use-trampoline",
    "title": "When to Use Trampoline",
    "section": "advanced",
    "body": "Good fit: Mobile wallets Hardware wallets Constrained devices Casual users prioritizing convenience Poor fit: Privacy-focused users Routing nodes When you need full control over route selection"
  },
  {
    "path": "/docs/advanced/trampoline-routing#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Onion Routing - Privacy-preserving routing Routing & HTLCs - Standard routing mechanics"
  },
  {
    "path": "/docs/advanced/trampoline-routing#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "Trampoline Routing Proposal ACINQ Trampoline Blog Phoenix Wallet - Trampoline-based wallet"
  },
  {
    "path": "/docs/advanced/covenants",
    "title": "Covenants",
    "section": "advanced",
    "body": "Covenants Covenants are a proposed type of Bitcoin Script constraint that would restrict how outputs from a transaction can be spent in future transactions. Unlike today’s scripts, which only define “who can spend and under what conditions,” covenants would allow “this UTXO may only be spent in a transaction that looks like X” (e.g., only to certain address types, or only after passing through a timelocked recovery path). No covenant opcodes are in consensus today. This page describes the "
  },
  {
    "path": "/docs/advanced/covenants#main-proposals",
    "title": "Main Proposals",
    "section": "advanced",
    "body": "OP_CAT (and similar) OP_CAT (concatenate two values on the stack) was disabled in early Bitcoin. Re-enabling it (or adding a constrained variant) could, in combination with hashing and equality "
  },
  {
    "path": "/docs/advanced/covenants#risks-and-trade-offs",
    "title": "Risks and Trade-offs",
    "section": "advanced",
    "body": "Recursion and complexity: Covenants that can chain arbitrarily may make scripts harder to reason about, audit, and fee-estimate. Proposals often limit recursion or the power of the opcode. "
  },
  {
    "path": "/docs/advanced/covenants#status",
    "title": "Status",
    "section": "advanced",
    "body": "| Covenant | In consensus? | Proposal | |----------|----------------|----------| | OP_CTV | No | BIP 119; discussion on bitcoin-dev | | SIGHASH_ANYPREVOUT (APO) | No | Active design; would enable "
  },
  {
    "path": "/docs/advanced/covenants#related-topics",
    "title": "Related Topics",
    "section": "advanced",
    "body": "Smart Contracts - Covenant-like patterns and Miniscript Miniscript - Policy and script; future covenant targets Sighash Types - How signing commits to transaction parts; APO extends this Lightning - "
  },
  {
    "path": "/docs/advanced/covenants#resources",
    "title": "Resources",
    "section": "advanced",
    "body": "BIP 119: CheckTemplateVerify (OP_CTV) Bitcoin Optech: Covenants bitcoin-dev mailing list - Covenant and APO discussion"
  },
  {
    "path": "/docs/investment",
    "title": "Bitcoin as Investment",
    "section": "investment",
    "body": "Bitcoin as Investment Bitcoin represents a unique investment opportunity that combines technological innovation with monetary properties never before seen in human history. Whether you're considering your first Bitcoin purchase or looking to deepen your understanding of Bitcoin as an asset, these guides will help you make informed decisions. Why Consider Bitcoin? Understanding Bitcoin as an investment requires recognizing both its potential and its risks. Bitcoin exhibits several "
  },
  {
    "path": "/docs/investment#why-consider-bitcoin",
    "title": "Why Consider Bitcoin?",
    "section": "investment",
    "body": "Understanding Bitcoin as an investment requires recognizing both its potential and its risks. Bitcoin exhibits several characteristics that make it attractive as an investment: Scarcity: With a fixed "
  },
  {
    "path": "/docs/investment#invest-only-what-you-understand",
    "title": "Invest Only What You Understand",
    "section": "investment",
    "body": "A fundamental principle among experienced Bitcoin investors is: only invest as much as you understand Bitcoin. This principle serves multiple purposes: Risk Management Bitcoin is a volatile asset. If "
  },
  {
    "path": "/docs/investment#education-first",
    "title": "Education First",
    "section": "investment",
    "body": "Before investing, prioritize education: Understand the technology: Learn how Bitcoin works at a technical level Study the economics: Understand monetary policy, supply dynamics, and network effects "
  },
  {
    "path": "/docs/investment#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Monetary Properties - Economic characteristics of Bitcoin Wallet Security & Self-Custody - Securing your Bitcoin holdings Investment Strategy - DCA and long-term holding strategies Understanding "
  },
  {
    "path": "/docs/investment/risk-management",
    "title": "Risk Management",
    "section": "investment",
    "body": "Risk Management Investing in Bitcoin carries significant risks that every investor should understand. This guide helps you identify, assess, and manage these risks appropriately. Key Risks Volatility Risk What it is: Bitcoin's price can experience dramatic swings. Short-term volatility can be 20-50% or more in a single day. Why it happens: Bitcoin is a relatively new asset class with a smaller market cap than traditional assets. Lower liquidity and market sentiment can cause significant price "
  },
  {
    "path": "/docs/investment/risk-management#key-risks",
    "title": "Key Risks",
    "section": "investment",
    "body": "Volatility Risk What it is: Bitcoin's price can experience dramatic swings. Short-term volatility can be 20-50% or more in a single day. Why it happens: Bitcoin is a relatively new asset class with a "
  },
  {
    "path": "/docs/investment/risk-management#risk-assessment-framework",
    "title": "Risk Assessment Framework",
    "section": "investment",
    "body": "Before Investing, Ask Yourself: Can I afford to lose this money? Only invest what you can afford to lose completely. Do I understand Bitcoin? Your investment size should match your understanding. "
  },
  {
    "path": "/docs/investment/risk-management#risk-mitigation-strategies",
    "title": "Risk Mitigation Strategies",
    "section": "investment",
    "body": "Diversification While Bitcoin can be a significant part of a portfolio, consider: Not putting all your savings into Bitcoin Maintaining an emergency fund in traditional currency Diversifying across "
  },
  {
    "path": "/docs/investment/risk-management#common-risk-management-mistakes",
    "title": "Common Risk Management Mistakes",
    "section": "investment",
    "body": "Investing more than you can afford to lose: This is the most common mistake. Only invest what you can afford to lose completely. Panic selling during downturns: Volatility is part of Bitcoin's "
  },
  {
    "path": "/docs/investment/risk-management#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Wallet Security & Self-Custody - Securing your Bitcoin holdings Investment Strategy - DCA and long-term holding strategies Understanding Market Cycles - Navigating volatility and market psychology "
  },
  {
    "path": "/docs/investment/investment-strategy",
    "title": "Investment Strategy",
    "section": "investment",
    "body": "Investment Strategy Investment strategies for Bitcoin focus on disciplined approaches that help you build and maintain a position over time, regardless of short-term market volatility. This guide covers proven strategies used by long-term Bitcoin investors. Dollar Cost Averaging Dollar Cost Averaging (DCA) is an investment strategy where you invest a fixed amount of money at regular intervals, regardless of the asset's price. This approach helps reduce the impact of volatility and removes the "
  },
  {
    "path": "/docs/investment/investment-strategy#dollar-cost-averaging",
    "title": "Dollar Cost Averaging",
    "section": "investment",
    "body": "Dollar Cost Averaging (DCA) is an investment strategy where you invest a fixed amount of money at regular intervals, regardless of the asset's price. This approach helps reduce the impact of "
  },
  {
    "path": "/docs/investment/investment-strategy#hodling",
    "title": "HODLing",
    "section": "investment",
    "body": "The HODLing philosophy (holding Bitcoin for the long term regardless of short-term price volatility) has become a cornerstone of Bitcoin investment strategy. This approach aligns with Bitcoin's "
  },
  {
    "path": "/docs/investment/investment-strategy#combining-dca-and-hodling",
    "title": "Combining DCA and HODLing",
    "section": "investment",
    "body": "DCA and HODLing work exceptionally well together: DCA + HODL: Use Dollar Cost Averaging to build your position over time, then hold everything you've accumulated. This combines the discipline of DCA "
  },
  {
    "path": "/docs/investment/investment-strategy#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Risk Management - Understanding investment risks Interactive Tools - Where to execute your investment strategy Wallet Security & Self-Custody - Securing your Bitcoin holdings Understanding Market "
  },
  {
    "path": "/docs/investment/tools",
    "title": "Interactive Tools",
    "section": "investment",
    "body": "Interactive Tools This guide provides an overview of essential tools and resources for Bitcoin investors, from exchanges and wallets to blockchain explorers and educational materials. The focus is on reputable, well-established tools that can help you invest, manage, and learn about Bitcoin. Exchanges Exchanges are platforms where you can buy, sell, and trade Bitcoin. Understanding the different types of exchanges and their trade-offs is essential for making informed decisions. Centralized "
  },
  {
    "path": "/docs/investment/tools#exchanges",
    "title": "Exchanges",
    "section": "investment",
    "body": "Exchanges are platforms where you can buy, sell, and trade Bitcoin. Understanding the different types of exchanges and their trade-offs is essential for making informed decisions. Centralized "
  },
  {
    "path": "/docs/investment/tools#wallet-tools",
    "title": "Wallet Tools",
    "section": "investment",
    "body": "Wallets are essential for storing and managing your Bitcoin. For detailed information on wallet security, see Wallet Security & Self-Custody. Wallet Types Comparison | Wallet Type | Security | "
  },
  {
    "path": "/docs/investment/tools#blockchain-explorers",
    "title": "Blockchain Explorers",
    "section": "investment",
    "body": "What blockchain explorers are: Web tools that let you view and search the Bitcoin blockchain. What you can do: View transactions Check addresses and balances See block information Track transaction "
  },
  {
    "path": "/docs/investment/tools#price-tracking-analytics",
    "title": "Price Tracking & Analytics",
    "section": "investment",
    "body": "Price Tracking Tools What they do: Track Bitcoin's price in real-time and provide historical data. Popular Options: CoinGecko: Extensive price data, good charts CoinMarketCap: Popular, good data and "
  },
  {
    "path": "/docs/investment/tools#educational-resources",
    "title": "Educational Resources",
    "section": "investment",
    "body": "Books Essential Reading: \"The Bitcoin Standard\" by Saifedean Ammous: Economic perspective \"Mastering Bitcoin\" by Andreas M. Antonopoulos: Technical deep dive \"The Internet of Money\" by Andreas M. "
  },
  {
    "path": "/docs/investment/tools#other-helpful-tools",
    "title": "Other Helpful Tools",
    "section": "investment",
    "body": "Tax Reporting Tools What they do: Help you calculate and report Bitcoin taxes. Features: Import transaction history Calculate gains/losses Generate tax reports Support for various jurisdictions "
  },
  {
    "path": "/docs/investment/tools#tool-selection-criteria",
    "title": "Tool Selection Criteria",
    "section": "investment",
    "body": "| Criteria | Key Questions | |----------|---------------| | Security | Good reputation? Open-source? Security practices? | | Privacy | KYC required? Data collection? Privacy features? | | Usability | "
  },
  {
    "path": "/docs/investment/tools#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Wallet Security & Self-Custody - Securing your Bitcoin holdings Privacy - Privacy considerations and tools Investment Strategy - DCA and long-term holding strategies Risk Management - Understanding "
  },
  {
    "path": "/docs/investment/wallet-security",
    "title": "Wallet Security & Self-Custody",
    "section": "investment",
    "body": "Wallet Security & Self-Custody Not your keys, not your coins. This fundamental principle of Bitcoin ownership means that if you don't control your private keys, you don't truly own your Bitcoin. This guide explains how to securely store your Bitcoin using cold wallets, hardware wallets, and air-gapped systems. Why Self-Custody Matters When you store Bitcoin on an exchange or custodial service, you're trusting a third party with your funds. While this may be convenient, it comes with significant "
  },
  {
    "path": "/docs/investment/wallet-security#why-self-custody-matters",
    "title": "Why Self-Custody Matters",
    "section": "investment",
    "body": "When you store Bitcoin on an exchange or custodial service, you're trusting a third party with your funds. While this may be convenient, it comes with significant risks: Exchange hacks: Exchanges can "
  },
  {
    "path": "/docs/investment/wallet-security#understanding-private-keys-and-seed-phrases",
    "title": "Understanding Private Keys and Seed Phrases",
    "section": "investment",
    "body": "Private Keys A private key is a secret cryptographic key that proves ownership of Bitcoin. Whoever controls the private key controls the Bitcoin. If you lose your private key, you lose your Bitcoin "
  },
  {
    "path": "/docs/investment/wallet-security#types-of-wallets",
    "title": "Types of Wallets",
    "section": "investment",
    "body": "| Wallet Type | Connection | Security | Convenience | Best For | |-------------|------------|----------|-------------|----------| | Hot Wallets | Internet-connected | Lower | High | Small amounts, "
  },
  {
    "path": "/docs/investment/wallet-security#hardware-wallets",
    "title": "Hardware Wallets",
    "section": "investment",
    "body": "A hardware wallet is a physical device designed specifically for storing private keys securely. It's a specialized computer that: Generates private keys offline Signs transactions without exposing "
  },
  {
    "path": "/docs/investment/wallet-security#air-gapped-systems",
    "title": "Air-Gapped Systems",
    "section": "investment",
    "body": "An air-gapped system is a computer or device that has never been connected to the internet. This provides the highest level of security because: No network attacks possible No malware can reach the "
  },
  {
    "path": "/docs/investment/wallet-security#seed-phrase-security",
    "title": "Seed Phrase Security",
    "section": "investment",
    "body": "Physical Storage Best practices: Write your seed phrase on paper or metal (fire/water resistant) Store in multiple secure locations Never store digitally (photos, cloud, email, notes apps) Consider "
  },
  {
    "path": "/docs/investment/wallet-security#multi-signature-wallets",
    "title": "Multi-Signature Wallets",
    "section": "investment",
    "body": "A multi-signature (multisig) wallet requires multiple private keys to authorize a transaction. For example, a 2-of-3 multisig requires 2 out of 3 keys to sign. Benefits No single point of failure: "
  },
  {
    "path": "/docs/investment/wallet-security#security-best-practices-by-amount",
    "title": "Security Best Practices by Amount",
    "section": "investment",
    "body": "| Amount | Wallet Type | Seed Backup | Additional Security | |--------|-------------|-------------|---------------------| | * $10,000* | Hardware/air-gapped | Multiple locations, metal backups | "
  },
  {
    "path": "/docs/investment/wallet-security#common-security-mistakes",
    "title": "Common Security Mistakes",
    "section": "investment",
    "body": "Storing seed phrase digitally: Photos, cloud storage, email, or notes apps can be hacked. Never store seed phrases digitally. Sharing seed phrase: Never share your seed phrase with anyone, even if "
  },
  {
    "path": "/docs/investment/wallet-security#physical-security",
    "title": "Physical Security",
    "section": "investment",
    "body": "Home Storage Use a fireproof safe Consider a safety deposit box for backups Don't store all copies in one location Tell trusted family members where backups are (but not the seed phrase itself) "
  },
  {
    "path": "/docs/investment/wallet-security#recovery-planning",
    "title": "Recovery Planning",
    "section": "investment",
    "body": "Test Your Recovery Before storing significant amounts: Create a test wallet Write down the seed phrase Delete the wallet Restore from seed phrase Verify you can access the wallet Critical: If you "
  },
  {
    "path": "/docs/investment/wallet-security#when-to-use-custodial-services",
    "title": "When to Use Custodial Services",
    "section": "investment",
    "body": "While self-custody is generally recommended, custodial services may make sense for: Very small amounts: Convenience may outweigh risk Active trading: Exchanges are necessary for trading Institutional "
  },
  {
    "path": "/docs/investment/wallet-security#getting-started",
    "title": "Getting Started",
    "section": "investment",
    "body": "Start small: Begin with a small amount while you learn Choose a hardware wallet: Research and purchase a reputable hardware wallet Set up securely: Follow the device's setup instructions carefully "
  },
  {
    "path": "/docs/investment/wallet-security#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Risk Management - Understanding investment risks, including custody risk Privacy - Privacy considerations for protecting your financial information Interactive Tools - Wallet tools and other helpful "
  },
  {
    "path": "/docs/investment/privacy",
    "title": "Privacy",
    "section": "investment",
    "body": "Privacy Bitcoin transactions are pseudonymous, not anonymous. While Bitcoin addresses don't directly reveal your identity, sophisticated blockchain analysis can link transactions and potentially identify you. This guide covers practical privacy considerations for Bitcoin investors, helping you understand the risks and tools available to protect your financial privacy. Understanding Bitcoin Privacy Pseudonymity vs Anonymity Pseudonymity means your transactions are linked to addresses, not your "
  },
  {
    "path": "/docs/investment/privacy#understanding-bitcoin-privacy",
    "title": "Understanding Bitcoin Privacy",
    "section": "investment",
    "body": "Pseudonymity vs Anonymity Pseudonymity means your transactions are linked to addresses, not your real-world identity. However, if someone connects an address to your identity (through KYC, address "
  },
  {
    "path": "/docs/investment/privacy#kyc-know-your-customer",
    "title": "KYC (Know Your Customer)",
    "section": "investment",
    "body": "KYC (Know Your Customer) is a regulatory requirement that forces financial institutions, including Bitcoin exchanges, to verify your identity by collecting personal information such as: "
  },
  {
    "path": "/docs/investment/privacy#mixing-utxos-coinjoin",
    "title": "Mixing UTXOs (CoinJoin)",
    "section": "investment",
    "body": "UTXO mixing (also called CoinJoin) is a privacy technique that combines multiple users' transactions into a single transaction, making it difficult to determine which inputs belong to which outputs. "
  },
  {
    "path": "/docs/investment/privacy#running-your-own-node",
    "title": "Running Your Own Node",
    "section": "investment",
    "body": "Why Running Your Own Node Improves Privacy When you use a wallet that connects to someone else's node (like most mobile and desktop wallets), you're revealing information: Your IP Address: The node "
  },
  {
    "path": "/docs/investment/privacy#additional-privacy-topics",
    "title": "Additional Privacy Topics",
    "section": "investment",
    "body": "Address Reuse and Why to Avoid It Address reuse means using the same Bitcoin address for multiple transactions. Why it's bad: Links all transactions to that address Reveals your transaction history "
  },
  {
    "path": "/docs/investment/privacy#privacy-best-practices-for-investors",
    "title": "Privacy Best Practices for Investors",
    "section": "investment",
    "body": "Privacy-Aware Exchange Selection When choosing exchanges, consider: KYC Requirements: What information do they require? Data Retention: How long do they keep your data? Privacy Policy: What do they "
  },
  {
    "path": "/docs/investment/privacy#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Wallet Security & Self-Custody - Securing your Bitcoin holdings Privacy Techniques - Technical privacy techniques (for developers) UTXO Model - Understanding how UTXOs work Coin Selection - "
  },
  {
    "path": "/docs/investment/market-cycles",
    "title": "Understanding Market Cycles",
    "section": "investment",
    "body": "Understanding Market Cycles Bitcoin's price is characterized by extreme volatility and cyclical patterns. Understanding these cycles (driven by halving events, market psychology, and adoption waves) can help you navigate Bitcoin's market without making emotional decisions. Bitcoin's Volatility Why Bitcoin is Volatile Bitcoin's volatility comes from several factors: Small market cap: Compared to traditional assets, Bitcoin's market cap is relatively small. This means large buy or sell orders can "
  },
  {
    "path": "/docs/investment/market-cycles#bitcoins-volatility",
    "title": "Bitcoin's Volatility",
    "section": "investment",
    "body": "Why Bitcoin is Volatile Bitcoin's volatility comes from several factors: Small market cap: Compared to traditional assets, Bitcoin's market cap is relatively small. This means large buy or sell "
  },
  {
    "path": "/docs/investment/market-cycles#the-halving-cycle",
    "title": "The Halving Cycle",
    "section": "investment",
    "body": "A halving is an event where Bitcoin's block subsidy (the reward miners receive) is cut in half. This happens approximately every four years (every 210,000 blocks). Halvings are programmed into "
  },
  {
    "path": "/docs/investment/market-cycles#market-psychology",
    "title": "Market Psychology",
    "section": "investment",
    "body": "The Emotional Cycle Bitcoin markets follow a predictable emotional cycle: | Phase | Emotion | Market Condition | Investor Behavior | |-------|---------|------------------|-------------------| | 1 | "
  },
  {
    "path": "/docs/investment/market-cycles#bull-markets",
    "title": "Bull Markets",
    "section": "investment",
    "body": "Characteristics | Indicator | Description | |-----------|-------------| | Rising prices | Sustained upward price movement over months or years | | High volume | Increased trading volume as more "
  },
  {
    "path": "/docs/investment/market-cycles#bear-markets",
    "title": "Bear Markets",
    "section": "investment",
    "body": "Characteristics | Indicator | Description | |-----------|-------------| | Falling prices | Sustained downward price movement over months or years | | Low volume | Reduced trading volume as "
  },
  {
    "path": "/docs/investment/market-cycles#market-phases",
    "title": "Market Phases",
    "section": "investment",
    "body": "| Phase | Characteristics | Strategy | |-------|----------------|----------| | Accumulation | • Prices are low and stable• Low media attention• Few new investors• Long-term holders accumulate | This "
  },
  {
    "path": "/docs/investment/market-cycles#navigating-cycles-without-emotion",
    "title": "Navigating Cycles Without Emotion",
    "section": "investment",
    "body": "Have a Plan Before investing: Define your time horizon Set your investment strategy (DCA, lump sum, etc.) Determine your risk tolerance Decide when you might sell (if ever) Stick to your plan: Don't "
  },
  {
    "path": "/docs/investment/market-cycles#historical-patterns",
    "title": "Historical Patterns",
    "section": "investment",
    "body": "Past Cycles | Period | Cycle Phase | Key Events | Peak Price | |--------|-------------|------------|------------| | 2010-2013 | Early adoption, first major bull run | First exchanges, early adoption "
  },
  {
    "path": "/docs/investment/market-cycles#common-mistakes-during-cycles",
    "title": "Common Mistakes During Cycles",
    "section": "investment",
    "body": "| Mistake | Why It's Problematic | Better Approach | |---------|----------------------|-----------------| | Buying at the top | FOMO-driven purchases during euphoria often lead to buying at peaks | "
  },
  {
    "path": "/docs/investment/market-cycles#related-topics",
    "title": "Related Topics",
    "section": "investment",
    "body": "Investment Strategy - DCA and long-term holding strategies for navigating cycles Risk Management - Understanding and managing investment risks Halvings - Understanding Bitcoin's halving events and "
  },
  {
    "path": "/docs/adoption",
    "title": "Bitcoin Adoption",
    "section": "adoption",
    "body": "Bitcoin Adoption Bitcoin is more than code and cryptography. It's a tool being used by real people to solve real problems. From energy producers monetizing waste to rural communities accessing financial services, Bitcoin adoption is happening in diverse and innovative ways around the world. Bitcoin vs Internet Adoption Why Real-World Examples Matter Understanding Bitcoin's technical foundations is essential, but seeing how Bitcoin is actually used reveals its practical value: Energy Innovation: "
  },
  {
    "path": "/docs/adoption#why-real-world-examples-matter",
    "title": "Why Real-World Examples Matter",
    "section": "adoption",
    "body": "Understanding Bitcoin's technical foundations is essential, but seeing how Bitcoin is actually used reveals its practical value: Energy Innovation: Bitcoin mining is turning wasted energy into "
  },
  {
    "path": "/docs/adoption#adoption-stories",
    "title": "Adoption Stories",
    "section": "adoption",
    "body": "Stranded Energy and Flared Gas Bitcoin mining is uniquely suited to use energy that would otherwise be wasted. Oil fields flare natural gas because it's not economical to transport. Hydroelectric "
  },
  {
    "path": "/docs/adoption#the-adoption-cycle",
    "title": "The Adoption Cycle",
    "section": "adoption",
    "body": "Bitcoin adoption follows a pattern: Early Adopters: Technical users and cypherpunks understand Bitcoin's potential Use Case Discovery: People find specific problems Bitcoin solves Network Effects: As "
  },
  {
    "path": "/docs/adoption#related-topics",
    "title": "Related Topics",
    "section": "adoption",
    "body": "Monetary Properties - Why Bitcoin has value Energy Consumption - The energy debate Lightning Network - Fast, cheap payments Trust Model - How Bitcoin enables trustless transactions Decentralization - "
  },
  {
    "path": "/docs/adoption/stranded-energy",
    "title": "Stranded Energy and Flared Gas",
    "section": "adoption",
    "body": "Stranded Energy and Flared Gas Bitcoin mining has a unique property: it can monetize energy that would otherwise be wasted. This creates economic value from stranded energy sources like flared natural gas, excess hydroelectric capacity, and curtailed renewable generation. Bitcoin mine in remote Zambia What is Stranded Energy? Stranded energy is energy that is produced but cannot be economically used, stored, or transmitted. Common sources include: Flared natural gas: Gas produced at oil wells "
  },
  {
    "path": "/docs/adoption/stranded-energy#what-is-stranded-energy",
    "title": "What is Stranded Energy?",
    "section": "adoption",
    "body": "Stranded energy is energy that is produced but cannot be economically used, stored, or transmitted. Common sources include: Flared natural gas: Gas produced at oil wells that's burned off because "
  },
  {
    "path": "/docs/adoption/stranded-energy#flared-natural-gas",
    "title": "Flared Natural Gas",
    "section": "adoption",
    "body": "The Problem Oil production often produces natural gas as a byproduct. In many locations, this gas: Has no pipeline infrastructure to transport it Is too expensive to capture and process Must be "
  },
  {
    "path": "/docs/adoption/stranded-energy#excess-renewable-energy",
    "title": "Excess Renewable Energy",
    "section": "adoption",
    "body": "The Problem Renewable energy sources like solar and wind have variable output: Solar: Generates during daylight hours, peak at midday Wind: Generates when wind is blowing, often at night Grid demand: "
  },
  {
    "path": "/docs/adoption/stranded-energy#environmental-benefits",
    "title": "Environmental Benefits",
    "section": "adoption",
    "body": "Bitcoin mining using stranded energy has several environmental benefits: Reducing Waste Less flaring: Using flared gas reduces methane emissions More renewable utilization: Excess renewable energy is "
  },
  {
    "path": "/docs/adoption/stranded-energy#economic-model",
    "title": "Economic Model",
    "section": "adoption",
    "body": "Bitcoin mining with stranded energy creates a unique economic model: For Energy Producers New revenue stream: Monetize energy that has no other use Reduced waste: Less flaring, less curtailment "
  },
  {
    "path": "/docs/adoption/stranded-energy#challenges-and-limitations",
    "title": "Challenges and Limitations",
    "section": "adoption",
    "body": "Technical Challenges Intermittent supply: Stranded energy may be intermittent Remote locations: Deploying and maintaining equipment in remote areas Scaling: Small amounts of energy may not justify "
  },
  {
    "path": "/docs/adoption/stranded-energy#future-potential",
    "title": "Future Potential",
    "section": "adoption",
    "body": "The potential for Bitcoin mining to use stranded energy is significant: Flared gas: Billions of cubic meters of gas are flared annually Renewable curtailment: Growing renewable capacity increases "
  },
  {
    "path": "/docs/adoption/stranded-energy#related-topics",
    "title": "Related Topics",
    "section": "adoption",
    "body": "Energy Consumption - The broader energy debate Proof-of-Work - How Bitcoin mining works Mining Economics - The economics of Bitcoin mining Monetary Properties - Why Bitcoin has value Bitcoin mining's "
  },
  {
    "path": "/docs/adoption/rural-communities",
    "title": "Rural Communities and Financial Inclusion",
    "section": "adoption",
    "body": "Rural Communities and Financial Inclusion Bitcoin, combined with the Lightning Network, is enabling financial services for communities that traditional banking has failed to serve. From remittances to savings to daily payments, Bitcoin is providing financial access to billions of people worldwide. The Banking Gap The Problem Over 1.7 billion adults worldwide lack access to traditional banking services. They face: No bank accounts: Banks don't operate in remote or underserved areas High fees: "
  },
  {
    "path": "/docs/adoption/rural-communities#the-banking-gap",
    "title": "The Banking Gap",
    "section": "adoption",
    "body": "The Problem Over 1.7 billion adults worldwide lack access to traditional banking services. They face: No bank accounts: Banks don't operate in remote or underserved areas High fees: Remittances can "
  },
  {
    "path": "/docs/adoption/rural-communities#remittances",
    "title": "Remittances",
    "section": "adoption",
    "body": "The Traditional Remittance Problem Remittances (money sent by migrant workers to their families) are a lifeline for millions. But traditional remittances have major problems: High fees: Average fees "
  },
  {
    "path": "/docs/adoption/rural-communities#savings-and-store-of-value",
    "title": "Savings and Store of Value",
    "section": "adoption",
    "body": "The Inflation Problem Many developing countries experience high inflation: Venezuela: Hyperinflation destroyed the bolivar's value Argentina: Persistent high inflation erodes savings Turkey: Currency "
  },
  {
    "path": "/docs/adoption/rural-communities#daily-payments",
    "title": "Daily Payments",
    "section": "adoption",
    "body": "The Payment Problem In many rural and developing areas: Cash-only: Limited acceptance of digital payments No credit cards: Card networks don't serve these areas Mobile money limitations: Services "
  },
  {
    "path": "/docs/adoption/rural-communities#el-salvador-national-adoption",
    "title": "El Salvador: National Adoption",
    "section": "adoption",
    "body": "The Experiment In September 2021, El Salvador became the first country to adopt Bitcoin as legal tender. The government: Made Bitcoin legal tender: Bitcoin must be accepted alongside the US dollar "
  },
  {
    "path": "/docs/adoption/rural-communities#challenges-and-solutions",
    "title": "Challenges and Solutions",
    "section": "adoption",
    "body": "Technical Challenges Internet access: Bitcoin requires internet connectivity Solution: Mobile data is increasingly available, even in rural areas Offline options: Some wallets support offline "
  },
  {
    "path": "/docs/adoption/rural-communities#future-potential",
    "title": "Future Potential",
    "section": "adoption",
    "body": "The potential for Bitcoin to serve the unbanked is enormous: 1.7 billion unbanked adults: Massive addressable market Growing smartphone adoption: More people can access Bitcoin Improving "
  },
  {
    "path": "/docs/adoption/rural-communities#related-topics",
    "title": "Related Topics",
    "section": "adoption",
    "body": "Lightning Network - Fast, cheap payments Monetary Properties - Why Bitcoin has value Trust Model - How Bitcoin enables trustless transactions Wallets - How to use Bitcoin wallets Bitcoin is providing "
  },
  {
    "path": "/docs/adoption/use-cases",
    "title": "Bitcoin Use Cases",
    "section": "adoption",
    "body": "Bitcoin Use Cases Bitcoin adoption spans individuals, businesses, and nations. From remittances to corporate treasuries to national adoption, Bitcoin is being used in diverse and innovative ways. Remittances The Global Remittance Market Remittances (money sent by migrant workers to their families) total over $800 billion annually. Traditional remittances face: High fees: Average 6-10%, often much higher for small amounts Slow transfers: Can take days or weeks Limited access: Recipients may need "
  },
  {
    "path": "/docs/adoption/use-cases#remittances",
    "title": "Remittances",
    "section": "adoption",
    "body": "The Global Remittance Market Remittances (money sent by migrant workers to their families) total over $800 billion annually. Traditional remittances face: High fees: Average 6-10%, often much higher "
  },
  {
    "path": "/docs/adoption/use-cases#store-of-value",
    "title": "Store of Value",
    "section": "adoption",
    "body": "The Inflation Hedge Bitcoin's fixed supply and predictable issuance make it attractive as a store of value, especially in high-inflation environments: Fixed supply: Only 21 million bitcoin will ever "
  },
  {
    "path": "/docs/adoption/use-cases#corporate-adoption",
    "title": "Corporate Adoption",
    "section": "adoption",
    "body": "Treasury Reserves Companies are holding Bitcoin as part of their treasury reserves: MicroStrategy: The largest corporate Bitcoin holder, with over 190,000 BTC as of 2024. The company uses Bitcoin as "
  },
  {
    "path": "/docs/adoption/use-cases#country-level-adoption",
    "title": "Country-Level Adoption",
    "section": "adoption",
    "body": "El Salvador In September 2021, El Salvador became the first country to adopt Bitcoin as legal tender: Legal tender status: Bitcoin must be accepted alongside US dollar Government wallet: Chivo wallet "
  },
  {
    "path": "/docs/adoption/use-cases#humanitarian-aid",
    "title": "Humanitarian Aid",
    "section": "adoption",
    "body": "The Problem Traditional aid delivery faces challenges: Corruption: Aid can be stolen or misdirected Intermediaries: Multiple layers add costs and delays Restrictions: Governments can block or "
  },
  {
    "path": "/docs/adoption/use-cases#individual-adoption-stories",
    "title": "Individual Adoption Stories",
    "section": "adoption",
    "body": "Financial Freedom Individuals use Bitcoin for: Wealth preservation: Protect savings from inflation Cross-border transfers: Send money internationally Censorship resistance: Access money when accounts "
  },
  {
    "path": "/docs/adoption/use-cases#business-integration",
    "title": "Business Integration",
    "section": "adoption",
    "body": "Payment Acceptance Businesses accept Bitcoin for: Global payments: Accept payments from anywhere Lower fees: Especially with Lightning Network No chargebacks: Bitcoin transactions are final New "
  },
  {
    "path": "/docs/adoption/use-cases#investment-and-speculation",
    "title": "Investment and Speculation",
    "section": "adoption",
    "body": "Investment Use Case Many people hold Bitcoin as an investment: Portfolio diversification: Non-correlated asset Inflation hedge: Protect against currency devaluation Growth potential: Potential for "
  },
  {
    "path": "/docs/adoption/use-cases#adoption-metrics",
    "title": "Adoption Metrics",
    "section": "adoption",
    "body": "Growing Adoption Bitcoin adoption is growing across multiple metrics: Number of users: Millions of Bitcoin users worldwide Transaction volume: Growing transaction volume Hash rate: Increasing network "
  },
  {
    "path": "/docs/adoption/use-cases#challenges-to-adoption",
    "title": "Challenges to Adoption",
    "section": "adoption",
    "body": "Technical Challenges Complexity: Bitcoin has a learning curve Scalability: On-chain transactions have capacity limits User experience: Wallets and services need improvement Infrastructure: Requires "
  },
  {
    "path": "/docs/adoption/use-cases#future-potential",
    "title": "Future Potential",
    "section": "adoption",
    "body": "The potential for Bitcoin adoption is enormous: Global remittances: $800+ billion market Unbanked population: 1.7 billion adults Corporate treasuries: Trillions in corporate cash Store of value: "
  },
  {
    "path": "/docs/adoption/use-cases#related-topics",
    "title": "Related Topics",
    "section": "adoption",
    "body": "Monetary Properties - Why Bitcoin has value Lightning Network - Fast, cheap payments Bitcoin as Investment - Investment strategies Trust Model - How Bitcoin enables trustless transactions "
  }
]